[{"title":"「16」如何构建通用存储中间层","date":"2018-11-16T02:27:00.000Z","path":"2018/11/16/016.how-to-build-a-common-storage-layer/","text":"零、问题的由来开门见山地说，这篇文章【又】是一篇安利软文~，安利的对象就是 tua-storage。 顾名思义，这就是一款存储数据的工具。 用 tua-storage 好处大大的有么？ 那必须滴~，下面开始我的表演~ 多端统一 api 支持数据同步 数据过期逻辑 自动清理过期数据 支持永久保存 支持批量操作 一、多端统一 api日常开发中，在不同的平台下由于有不同的存储层接口，所以往往导致相同逻辑的同一份代码要写几份儿。 例如，小程序中保存数据要使用【异步】的 wx.setStorage、wx.getStorage 或对应的同步方法； 而在 web 端使用 localStorage 的话，则是【同步】的 setItem、getItem 等方法； 在 React-Native 的场景下，使用的又是 AsyncStorage 中【异步】的 setItem、getItem… 1.1.异步方法然而，经过 tua-storage 的二次封装，以上两个方法统一变成了： save: 异步保存 load: 异步读取 此外还有一些其他方法： clear: 异步清除（删除多个） remove: 异步删除（删除单个） getInfo: 异步获取信息（如 keys） 详情参阅这里的文档 1.2.同步方法在某些场景下正好需要调用同步方法的话，咋办咧？ 与 Node.js 的 api 风格差不多，在上述异步方法后面加上 Sync 就是对应的同步方法： saveSync loadSync clearSync removeSync getInfoSync 那么在 AsyncStorage 的场景下，压根就没有同步方法时调用以上方法会怎么样呢？ 嗯，你猜得没错，会直接报错… 1.3.区分场景 如何区分不同的场景呢？ 在初始化的时候传递 storageEngine 即可： 123456789101112131415import TuaStorage from 'tua-storage'const tuaStorage = new TuaStorage(&#123; // 小程序 storageEngine: wx, // web storageEngine: localStorage, // React-Native storageEngine: AsyncStorage, // Node.js storageEngine: &#123;&#125;,&#125;) 注意：传递的是【对象】，而非字符串！ 二、支持数据同步对于一个二次封装多端存储层的库来说，保证多端 api 的统一仅仅是常规操作而已。 tua-storage 的另一大亮点就是数据同步功能。 想想平时我们是怎么使用存储层的 读取一个数据 正好存储层里有这个数据 返回数据（皆大欢喜，happy ending~） 假如存储层里没这个数据 手动调用各种方法去同步这个数据 手动存到存储层中，以便下次读取 各位有没有看出其中麻烦的地方在哪儿？ 数据同步部分的复杂度全留给了业务侧。 让我们回归这件事的【初心】：我仅仅需要获取这个数据！我不管它是来自存储层、来自接口数据、还是来自其他什么地方… 2.1.数据同步函数因此 tua-storage 在读取数据时很贴心地提供了一个 syncFn 参数，作为数据同步的函数，当请求的数据不存在或已过期时自动调用该函数。并且数据同步后默认会保存下来，这样下次再请求时存储层中就有数据了。 syncParams 的使用场景是接口需要传参时，这些参数会传给 syncFn。 123456tuaStorage.load(&#123; key: 'some data', syncFn: (&#123; a &#125;) =&gt; axios('some api url' + a), // 以下参数会传到 syncFn 中 syncParams: &#123; a: 'a' &#125;,&#125;) 这么一来，存储层就和接口层对接起来了。业务侧再也不用手动调用 api 获取数据。 注意：添加了 syncParams 后被保存的数据 key 会添加 query，即变成了 some data?a=a这样就保证了不同参数的同一接口数据保存的 key 值不同。 2.2.合并分散配置每次读取数据时如果都要手动传同步函数，实际编码时还是很麻烦… 不急，吃口药~ tua-storage 在初始化时能够传递一个叫做 syncFnMap 参数。顾名思义，这是一个将 key 和 syncFn 映射起来的对象。 1234567891011const tuaStorage = new TuaStorage(&#123; // ... syncFnMap: &#123; 'data one': () =&gt; axios('data one api'), 'data two': () =&gt; axios('data two api'), // ... &#125;,&#125;)// 不用手动传 syncFn，默认匹配 syncFnMap 中的对应函数tuaStorage.load(&#123; key: 'data one' &#125;) 2.3.自动生成配置其实手动编写每个 api 请求函数也是很繁琐的，要是有个根据配置自动生成请求函数的库就好了~ 诶~，巧了么不是~。各位开发者老爷们了解一下同样跨平台的 tua-api ~？ tua-storage 搭配 tua-api 之后会变成这样 123456789import TuaStorage from 'tua-storage'import &#123; getSyncFnMapByApis &#125; from 'tua-api'// 本地写好的各种接口配置import * as apis from '@/apis'const tuaStorage = new TuaStorage(&#123; syncFnMap: getSyncFnMapByApis(apis),&#125;) 三、数据过期逻辑一般各个平台的存储层都没有数据过期这一逻辑。但在使用 tua-storage 时默认每个数据都有过期时间这一属性。 3.1.默认过期时间默认为 30 秒，可以在初始化时配置默认超时时间。 12345678910111213141516171819202122232425262728import TuaStorage from 'tua-storage'const tuaStorage = new TuaStorage(&#123; // 改为 60 秒 defaultExpires: 60,&#125;)// 返回一个 PromisetuaStorage .save(&#123; key: 'data key', data: &#123; foo: 'bar' &#125;, // 这里传递的过期时间优先级更高 expires: 90, &#125;) .then(console.log) .catch(console.error)// 保存到 storage 中的数据大概长这样// key 之前会加上初始化传入的默认前缀&#123; 'TUA_STORAGE_PREFIX: data key': &#123; expires: 90, rawData: &#123; foo: 'bar' &#125;, &#125;,&#125; 3.2.数据保存前缀为了保证存在 storage 中的数据名称不冲突，以及实现版本控制，tua-storage 默认有一个存储前缀：storageKeyPrefix。 默认值为 TUA_STORAGE_PREFIX:，所以在上一小节中保存的数据会有一个奇怪的前缀。 保证名称不冲突很好理解，如何实现版本控制呢？ 3.3.白名单机制clear 函数能够接受一个白名单数组（因为内部是通过 indexOf 来判断的，所以不必填写完整的 key 值）。 123456789101112131415161718192021import TuaStorage from 'tua-storage'const tuaStorage = new TuaStorage(&#123; ... &#125;)tuaStorage.clear(['key']) .then(console.log) .catch(console.error)// 假设现在 storage 中有以下数据&#123; 'foo': &#123;&#125;, 'bar': &#123;&#125;, 'foo-key': &#123;&#125;, 'bar-key': &#123;&#125;,&#125;// 清除后剩下的数据是&#123; 'foo-key': &#123;&#125;, 'bar-key': &#123;&#125;,&#125; 所以在调用 clear 时，在白名单中传入新的存储前缀，即可实现删除上一版本数据的功能。 1234567891011121314151617import TuaStorage from 'tua-storage'// 上一版本的前缀const prefix1 = 'STORAGE_PREFIX_V1.0: '// 这一版本的前缀const prefix2 = 'STORAGE_PREFIX_V1.1: 'const tuaStorage = new TuaStorage(&#123; // 将默认前缀切换成新版本的 storageKeyPrefix: prefix2,&#125;)// 开始清除上个版本的数据tuaStorage.clear([ prefix2 ]) .then(console.log) .catch(console.error) 更多默认配置参阅这里的文档 四、自动清理过期数据默认在启动时会进行一次过期数据清理（可以关闭），之后每过一段时间会再次清理。 什么样的数据会被清理呢？ 4.1.清理逻辑首先当然是清理已到过期时间的数据，即有一个属性为 expires 的数据，且当前时间已超过了该时间。 一旦遇到不满足格式的数据（非对象、没有 expires 属性）则跳过，这样就不会误清除其他程序保存的数据。 4.2.清理时间间隔在初始化时可传入 autoClearTime 修改默认自动清理时间间隔。 默认为一分钟，注意是以秒为单位。 五、支持永久保存在某些场景下，可能不方便写过期时间，这时默认可以传递 expires: null，标记该数据永不过期。 不喜欢用 null 标记？ 大丈夫~，初始化时传递 neverExpireMark 即可修改为你喜欢的别的标记。 123456789101112import TuaStorage from 'tua-storage'const tuaStorage = new TuaStorage(&#123; neverExpireMark: 'never',&#125;)// 永不过期tuaStorage.save(&#123; key: 'some key', data: 'some data', expires: 'never',&#125;) 六、支持批量操作假设现在有一组数据需要保存或读取，常规操作就是使用 Promise.all 发起多个操作。 1234567891011121314151617import TuaStorage from 'tua-storage'const tuaStorage = new TuaStorage(&#123; ... &#125;)const dataToBeSaved = [ &#123; key: 'key one', data: 'some data' &#125;, &#123; key: 'key two', data: 'some data' &#125;,]// 异步const result = dataToBeSaved .map(tuaStorage.save.bind(tuaStorage)) .then(Promise.all.bind(Promise))// 同步const result = dataToBeSaved .map(tuaStorage.saveSync.bind(tuaStorage)) 讲道理这样写还是挺烦的…所以 tua-storage 的各个 api 还支持直接传入数组： 1234567// 异步tuaStorage.save(dataToBeSaved) .then(console.log) .catch(console.log)// 同步tuaStorage.saveSync(dataToBeSaved) 七、小结还在为 web 端、小程序端、React-Native 端、node 端业务侧代码使用不一样的方式调用存储层烦恼么？还在为手动数据同步，保存数据，处理过期逻辑而烦躁么？各位开发者老爷们不妨试一试 tua-storage，（挤需体验三番钟，里造会干我一样，爱象介款工具）。 灵感来源inspired by react-native-storage","tags":[{"name":"tua","slug":"tua","permalink":"https://buptsteve.github.io/blog/tags/tua/"},{"name":"storage","slug":"storage","permalink":"https://buptsteve.github.io/blog/tags/storage/"}]},{"title":"「15」如何构建通用 api 中间层","date":"2018-11-05T03:08:00.000Z","path":"2018/11/05/015.how-to-build-a-common-api-layer/","text":"零、问题的由来开门见山地说，这篇文章是一篇安利软文~，安利的对象就是最近搞的 tua-api。 顾名思义，这就是一款辅助获取接口数据的工具。 发请求相关的工具辣么多，那我为啥要用你呢？ 理想状态下，项目中应该有一个 api 中间层。各种接口在这里定义，业务侧不应该手动编写接口地址，而应该调用接口层导出的函数。 123456import &#123; fooApi &#125; from '@/apis/'fooApi .bar(&#123; a: '1', b: '2' &#125;) // 发起请求，a、b 是请求参数 .then(console.log) // 收到响应 .catch(console.error) // 处理错误 那么如何组织实现这个 api 中间层呢？这里涉及两方面： 如何发请求，即“武器”部分 如何组织管理 api 地址 让我们先回顾一下有关发请求的历史。 一、如何发请求1.1.原生 XHR (XMLHttpRequest)说到发请求，最经典的方式莫过于调用浏览器原生的 XHR。在此不赘述，有兴趣可以看看MDN 上的文档。 123456789101112131415161718192021222324var xhr = window.XMLHttpRequest ? new XMLHttpRequest() // 在万恶的 IE 上可能还没有 XMLHttpRequest 这对象 : new ActiveXObject('Microsoft.XMLHTTP')xhr.open('GET', 'some url')xhr.responseType = 'json'// 传统使用 onreadystatechangexhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; console.log(xhr.responseText) &#125;&#125;// 或者直接使用 onload 事件xhr.onload = function () &#123; console.log(xhr.response)&#125;// 处理出错xhr.onerror = console.errorxhr.send() 这代码都不用看，想想就头皮发麻… 1.2.jQuery 封装的 ajax由于原生 XHR 写起来太繁琐，再加上当时 jQuery 如日中天。日常开发中用的比较多的还是 jQuery 提供的 ajax 方法。jQuery ajax 文档点这里 12345678var params = &#123; url: 'some url', data: &#123; name: 'Steve', location: 'Beijing' &#125;,&#125;$.ajax(params) .done(console.log) .fail(console.error) jQuery 不仅封装了 XHR，还十分贴心地提供跨域的 jsonp 功能。 1234567$.ajax(&#123; url: 'some url', data: &#123; name: 'Steve', location: 'Beijing' &#125;, dataType: 'jsonp', success: console.log, error: console.error,&#125;) 讲道理，jQuery 的 ajax 已经很好用了。然而随着 Vue、React、Angular 的兴起，连 jQuery 本身都被革命了。新项目为了发个请求还引入巨大的 jQuery 肯定不合理，当然后面这些替代方案也功不可没… 1.3.现代浏览器的原生 fetchXHR 是一个设计粗糙的 API。记得当年笔试某部门的实习生的时候就有手写 XHR 的题目，我反正记不住 api，并没有写出来… fetch api 基于 Promise 设计，调用起来比 XHR 方便多了。 1234fetch(url) .then(res =&gt; res.json()) .then(console.log) .catch(console.error) async/await 自然也能使用 123456try &#123; const data = await fetch(url).then(res =&gt; res.json()) console.log(data)&#125; catch (e) &#123; console.error(e)&#125; 当然 fetch 也有不少的问题 兼容性问题 使用繁琐，详见参考文献之 fetch 没有你想象的那么美 不支持 jsonp（虽然理论上不应该支持，但实际上日常还是需要使用的） 只对网络请求报错，对400，500都当做成功的请求，需要二次封装 默认不会带 cookie，需要添加配置项 不支持 abort，不支持超时控制，使用 setTimeout 及 Promise.race 的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费 没有办法原生监测请求的进度，而 XHR 可以 1.4.基于 Promise 的 axiosaxios 算是请求框架中的明星项目了。目前 github 5w+ 的 star… 先来看看有什么特性吧~ 同时支持浏览器端和服务端的请求。（XMLHttpRequests、http） 支持 Promise 支持请求和和数据返回的拦截 转换请求返回数据，自动转换JSON数据 支持取消请求 客户端防止 xsrf 攻击 嗯，看起来确实是居家旅行全栈开发必备好库，但是 axios 并不支持 jsonp… 1.5.不得不用的 jsonp在服务器端不方便配置跨域头的情况下，采用 jsonp 的方式发起跨域请求是一种常规操作。 在此不探究具体的实现，原理上来说就是 由于 script 标签可以设置跨域的来源，所以首先动态插入一个 script，将 src 设置为目标地址 服务端收到请求后，根据回调函数名（可自己约定，或作为参数传递）将 json 数据填入（即 json padding，所以叫 jsonp…）。例如 callback({ &quot;foo&quot;: &quot;bar&quot; })。 浏览器端收到响应后自然会执行该 script 即调用该函数，那么回调函数就收到了服务端填入的 json 数据了。 上面讲到新项目一般都弃用 jQuery 了，那么跨域请求还是得发呀。所以可能你还需要一个发送 jsonp 的库。（实践中选了 fetch-jsonp，当然其他库也可以） 综上，日常开发在框架的使用上以 axios 为主，实在不得不发 jsonp 请求时，就用 fetch-jsonp。这就是我们中间层的基础，即“武器”部分。 1.6.小程序场景在小程序场景没得选，只能使用官方的 wx.request 函数… 二、构建接口层基础功能对于简单的页面，直接裸写请求地址也没毛病。但是一旦项目变大，页面数量也上去了，直接在页面，或是组件中裸写接口的话，会带来以下问题 代码冗余：很多接口请求都是类似的代码，有许多相同的逻辑 不同的库和场景下的接口写法不同（ajax、jsonp、小程序…） 不方便切换测试域名 不方便编写接口注释 没法实现统一拦截器、甚至中间件功能 如何封装这些接口呢？ 2.1.接口地址划分首先我们来分析一下接口地址的组成 https://example-base.com/foo/create https://example-base.com/foo/modify https://example-base.com/foo/delete 对于以上地址，在 tua-api 中一般将其分为3部分 host: &#39;https://example-base.com/&#39; prefix: &#39;foo&#39; pathList: [ &#39;create&#39;, &#39;modify&#39;, &#39;delete&#39; ] 2.2.文件结构apis/ 一般是这样的文件结构： 123456.└── apis ├── prefix-1.js ├── prefix-2.js ├── foo.js // &lt;-- 以上的 api 地址会放在这里 └── index.js index.js 作为接口层的入口，会导入并生成各个 api 然后再导出。 2.3.基础配置内容所以以上的示例接口地址可以这么写 12345678910111213141516// src/apis/foo.jsexport default &#123; // 请求的公用服务器地址。 host: 'http://example-base.com/', // 请求的中间路径，建议与文件同名，以便后期维护。 prefix: 'foo', // 接口地址数组 pathList: [ &#123; path: 'create' &#125;, &#123; path: 'modify' &#125;, &#123; path: 'delete' &#125;, ],&#125; 这时如果想修改服务器地址，只需要修改 host 即可。甚至还能这么玩 123456789101112131415161718// src/apis/foo.js// 某个获取页面地址参数的函数const getUrlParams = () =&gt; &#123;...&#125;export default &#123; // 根据 NODE_ENV 采用不同的服务器 host: process.env.NODE_ENV === 'test' ? 'http://example-test.com/' : 'http://example-base.com/', // 根据页面参数采用不同的服务器，即页面地址带 ?test=1 则走测试地址 host: getUrlParams().test ? 'http://example-test.com/' : 'http://example-base.com/', // ...&#125; 2.4.配置导出下面来看一下 apis/index.js 该怎么写： 1234567import TuaApi from 'tua-api'// 初始化const tuaApi = new TuaApi(&#123; ... &#125;)// 导出export const fooApi = tuaApi.getApi(require('./foo').default) 这样我们就把接口地址封装了起来，业务侧不需要关心接口的逻辑，而后期接口的修改和升级时只需要修改这里的配置即可。 2.5.接口参数与接口类型示例的接口地址太理想化了，如果有参数如何传递？ 假设以上接口添加 id、from 和 foo 参数。并且增加以下逻辑： foo 参数默认填 bar from 参数默认填 index-page delete 接口使用 jsonp 的方式，from 参数默认填 delete-page modify 接口使用 post 的方式，from 参数不需要填 哎~，别急着死，暂且看看怎么用 tua-api 来抽象这些逻辑？ 123456789101112131415161718192021222324252627282930313233343536373839404142// src/apis/foo.jsexport default &#123; // ... // 公共参数，将会合并到后面的各个接口参数中 commonParams: &#123; foo: 'bar', from: 'index-page', &#125;, pathList: [ &#123; path: 'create', params: &#123; // 类似 Vue 中 props 的类型检查 id: &#123; required: true &#125;, &#125;, &#125;, &#123; path: 'modify', // 使用 post 的方式 type: 'post', params: &#123; // 写成 isRequired 也行 id: &#123; isRequired: true &#125;, // 接口不合并公共参数，即不传 from 参数 commonParams: null, &#125;, &#125;, &#123; path: 'delete', // 使用 jsonp 的方式（不填则默认使用 axios） reqType: 'jsonp', params: &#123; id: &#123; required: true &#125;, // 这里填写的 from 会覆盖 commonParams 中的同名属性 from: 'delete-page', &#125;, &#125;, ],&#125; 现在来看看业务侧代码有什么变化。 12345678910111213import &#123; fooApi &#125; from '@/apis/'// 直接调用将会报错，因为没有传递 id 参数await fooApi.create()// 请求参数使用传入的 from：id=1&amp;foo=bar&amp;from=foo-pageawait fooApi.create(&#123; id: 1, from: 'foo-page' &#125;)// 请求参数将只有 id：id=1await fooApi.modify(&#123; id: 1 &#125;)// 请求参数将使用自身的 from：id=1&amp;foo=bar&amp;from=delete-pageawait fooApi.delete(&#123; id: 1 &#125;) 2.6.接口重命名假设现在后台又添加了以下两个新接口，咱们该怎么写配置呢？ remove/all add-array 首先，把后台同学砍死…2333 这什么鬼接口地址，直接填的话会业务侧就会写成这样。 12fooApi['remove/all']fooApi['add-array'] 这代码简直无法直视…让我们用 name 属性，将接口重命名一下。 123456789101112// src/apis/foo.jsexport default &#123; // ... pathList: [ // ... &#123; path: 'remove/all', name: 'removeAll' &#125;, &#123; path: 'add-array', name: 'addArray' &#125;, ],&#125; 更多配置请点击这里查看 三、高级功能一个接口层仅仅只能发 api 请求是远远不够的，在日常使用中往往还有以下需求 发起请求时展示 loading，收到响应后隐藏 出错时展示错误信息，例如弹一个 toast 接口上报：包括性能和错误 添加特技：如接口参数加密、校验 3.1.小程序端的 loading 展示小程序端由于原生自带 UI 组件，所以框架内置了该功能。主要包括以下参数 isShowLoading showLoadingFn hideLoadingFn 顾名思义，就是开关和具体的显示、隐藏的方法，详情参阅这里 3.2.基础钩子函数最简单的钩子函数就是 beforeFn/afterFn 这俩函数了。 beforeFn 是在请求发起前执行的函数（例如小程序可以通过返回 header 传递 cookie），因为是通过 beforeFn().then(...) 调用，所以注意要返回 Promise。 afterFn 是在收到响应后执行的函数，可以不用返回 Promise。 注意接收的参数是一个【数组】 [ res.data, ctx ] 所以默认值是 const afterFn = ([x]) =&gt; x，即返回接口数据到业务侧 第一个参数是接口返回的数据对象 { code, data, msg } 第二个参数是请求相关参数的对象，例如有请求的 host、type、params、fullPath、reqTime、startTime、endTime 等等 3.3.middleware 中间件钩子函数有时不太够用，并且代码一长不太好维护。所以 tua-api 还引入了中间件功能，用法上和 koa 的中间件很像（其实底层直接用了 koa-compose）。 123export default &#123; middleware: [ fn1, fn2, fn3 ],&#125; 首先说下中间件执行顺序，koa 中间件的执行顺序和 redux 的正好相反，例如以上写法会以以下顺序执行： 请求参数 -&gt; fn1 -&gt; fn2 -&gt; fn3 -&gt; 响应数据 -&gt; fn3 -&gt; fn2 -&gt; fn1 简单说下中间件的写法，分为两种 普通函数：注意一定要 return next() 否则 Promise 链就断了！ async 函数：注意一定要 await next()！ 1234567891011121314151617181920212223242526// 普通函数，注意一定要 return next()function (ctx, next) &#123; ctx.req // 请求的各种配置 ctx.res // 响应，但这时还未发起请求，所以是 undefined！ ctx.startTime // 发起请求的时间 // 传递控制权给下一个中间件 return next().then(() =&gt; &#123; // 注意这里才有响应！ ctx.res // 响应对象 ctx.res.data // 响应的数据 ctx.reqTime // 请求花费的时间 ctx.endTime // 收到响应的时间 &#125;)&#125;// async/awaitasync function (ctx, next) &#123; ctx.req // 请求的各种配置 // 传递控制权给下一个中间件 await next() // 注意这里才有响应响应！ ctx.res // 响应对象&#125; 其他参数参阅这里 四、小结这篇安利文，先是从前端发请求的历史出发。一步步介绍了如何构建以及使用 api 中间层，来统一管理接口地址，最后还介绍了下中间件等高级功能。话说回来，这么好用的 tua-api 各位开发者老爷们不来了解一下么？ 参考文献 Jquery ajax, Axios, Fetch区别之我见 传统 Ajax 已死，Fetch 永生 fetch 没有你想象的那么美 fetch 使用的常见问题及解决方法","tags":[{"name":"tua","slug":"tua","permalink":"https://buptsteve.github.io/blog/tags/tua/"},{"name":"api","slug":"api","permalink":"https://buptsteve.github.io/blog/tags/api/"}]},{"title":"「14」JavaScript 函数式编程（三）","date":"2018-08-10T07:30:00.000Z","path":"2018/08/10/014.fp-in-js-3/","text":"slide 地址 四、Talk is cheap！Show me the … MONEY! 以下内容主要参考自 Professor Frisby Introduces Composable Functional JavaScript 4.1.容器（Box）假设有个函数，可以接收一个来自用户输入的数字字符串。我们需要对其预处理一下，去除多余空格，将其转换为数字并加一，最后返回该值对应的字母。代码大概长这样… 1234const nextCharForNumStr = (str) =&gt; String.fromCharCode(parseInt(str.trim()) + 1)nextCharForNumStr(' 64 ') // \"A\" 因缺思厅，这代码嵌套的也太紧凑了，看多了“老阔疼”，赶紧重构一把… 12345678const nextCharForNumStr = (str) =&gt; &#123; const trimmed = str.trim() const number = parseInt(trimmed) const nextNumber = number + 1 return String.fromCharCode(nextNumber)&#125;nextCharForNumStr(' 64 ') // 'A' 很显然，经过之前内容的熏（xi）陶（nao），一眼就可以看出这个修订版代码很不 Pointfree… 为了这些只用一次的中间变量还要去想或者去查翻译，也是容易“老阔疼”，再改再改~ 1234567const nextCharForNumStr = (str) =&gt; [str] .map(s =&gt; s.trim()) .map(s =&gt; parseInt(s)) .map(i =&gt; i + 1) .map(i =&gt; String.fromCharCode(i))nextCharForNumStr(' 64 ') // ['A'] 这次借助数组的 map 方法，我们将必须的4个步骤拆分成了4个小函数。 这样一来再也不用去想中间变量的名称到底叫什么，而且每一步做的事情十分的清晰，一眼就可以看出这段代码在干嘛。 我们将原本的字符串变量 str 放在数组中变成了 [str]，这里就像放在一个容器里一样。 代码是不是感觉好 door~~ 了？ 不过在这里我们可以更进一步，让我们来创建一个新的类型 Box。我们将同样定义 map 方法，让其实现同样的功能。 1234567891011121314const Box = (x) =&gt; (&#123; map: f =&gt; Box(f(x)), // 返回容器为了链式调用 fold: f =&gt; f(x), // 将元素从容器中取出 inspect: () =&gt; `Box($&#123;x&#125;)`, // 看容器里有啥&#125;)const nextCharForNumStr = (str) =&gt; Box(str) .map(s =&gt; s.trim()) .map(i =&gt; parseInt(i)) .map(i =&gt; i + 1) .map(i =&gt; String.fromCharCode(i)) .fold(c =&gt; c.toLowerCase()) // 可以轻易地继续调用新的函数nextCharForNumStr(' 64 ') // a 此外创建一个容器，除了像函数一样直接传递参数以外，还可以使用静态方法 of。 函数式编程一般约定，函子有一个 of 方法，用来生成新的容器。 1Box(1) === Box.of(1) 其实这个 Box 就是一个函子（functor），因为它实现了 map 函数。当然你也可以叫它 Mappable 或者其他名称。 不过为了保持与范畴学定义的名称一致，我们就站在巨人的肩膀上不要再发明新名词啦~（后面小节的各种奇怪名词也是来源于数学名词）。 functor 是实现了 map 函数并遵守一些特定规则的容器类型。 那么这些特定的规则具体是什么咧？ 1. 规则一： 1fx.map(f).map(g) === fx.map(x =&gt; g(f(x))) 这其实就是函数组合… 2. 规则二： 123const id = x =&gt; xfx.map(id) === id(fx) 4.2.Either / Maybe 假设现在有个需求：获取对应颜色的十六进制的 RGB 值，并返回去掉#后的大写值。 123456789101112131415const findColor = (name) =&gt; (&#123; red: '#ff4444', blue: '#3b5998', yellow: '#fff68f',&#125;)[name]const redColor = findColor('red') .slice(1) .toUpperCase() // FF4444const greenColor = findColor('green') .slice(1) .toUpperCase()// Uncaught TypeError:// Cannot read property 'slice' of undefined 以上代码在输入已有颜色的 key 值时运行良好，不过一旦传入其他颜色就会报错。咋办咧？ 暂且不提条件判断和各种奇技淫巧的错误处理。咱们来先看看函数式的解决方案~ 函数式将错误处理抽象成一个 Either 容器，而这个容器由两个子容器 Right 和 Left 组成。 12345678910111213141516171819202122232425262728// Either 由 Right 和 Left 组成const Left = (x) =&gt; (&#123; map: f =&gt; Left(x), // 忽略传入的 f 函数 fold: (f, g) =&gt; f(x), // 使用左边的函数 inspect: () =&gt; `Left($&#123;x&#125;)`, // 看容器里有啥&#125;)const Right = (x) =&gt; (&#123; map: f =&gt; Right(f(x)), // 返回容器为了链式调用 fold: (f, g) =&gt; g(x), // 使用右边的函数 inspect: () =&gt; `Right($&#123;x&#125;)`, // 看容器里有啥&#125;)// 来测试看看~const right = Right(4) .map(x =&gt; x * 7 + 1) .map(x =&gt; x / 2)right.inspect() // Right(14.5)right.fold(e =&gt; 'error', x =&gt; x) // 14.5const left = Left(4) .map(x =&gt; x * 7 + 1) .map(x =&gt; x / 2)left.inspect() // Left(4)left.fold(e =&gt; 'error', x =&gt; x) // error 可以看出 Right 和 Left 相似于 Box： 最大的不同就是 fold 函数，这里需要传两个回调函数，左边的给 Left 使用，右边的给 Right 使用。 其次就是 Left 的 map 函数忽略了传入的函数（因为出错了嘛，当然不能继续执行啦）。 现在让我们回到之前的问题来~ 12345678910111213141516const fromNullable = (x) =&gt; x == null ? Left(null) : Right(x)const findColor = (name) =&gt; fromNullable((&#123; red: '#ff4444', blue: '#3b5998', yellow: '#fff68f',&#125;)[name])findColor('green') .map(c =&gt; c.slice(1)) .fold( e =&gt; 'no color', c =&gt; c.toUpperCase() ) // no color 从以上代码不知道各位读者老爷们有没有看出使用 Either 的好处，那就是可以放心地对于这种类型的数据进行任何操作，而不是在每个函数里面小心翼翼地进行参数检查。 4.3.Chain / FlatMap / bind / &gt;&gt;=假设现在有个 json 文件里面保存了端口，我们要读取这个文件获取端口，要是出错了返回默认值 3000。 1234567891011121314151617// config.json&#123; \"port\": 8888 &#125;// chain.jsconst fs = require('fs')const getPort = () =&gt; &#123; try &#123; const str = fs.readFileSync('config.json') const &#123; port &#125; = JSON.parse(str) return port &#125; catch(e) &#123; return 3000 &#125;&#125;const result = getPort() so easy~，下面让我们来用 Either 来重构下看看效果。 123456789101112131415161718const fs = require('fs')const Left = (x) =&gt; (&#123; ... &#125;)const Right = (x) =&gt; (&#123; ... &#125;)const tryCatch = (f) =&gt; &#123; try &#123; return Right(f()) &#125; catch (e) &#123; return Left(e) &#125;&#125;const getPort = () =&gt; tryCatch( () =&gt; fs.readFileSync('config.json') ) .map(c =&gt; JSON.parse(c)) .fold(e =&gt; 3000, c =&gt; c.port) 啊，常规操作，看起来不错哟~ 不错你个蛇头…！ 以上代码有个 bug，当 json 文件写的有问题时，在 JSON.parse 时会出错，所以这步也要用 tryCatch 包起来。 但是，问题来了… 返回值这时候可能是 Right(Right(&#39;&#39;)) 或者 Right(Left(e))（想想为什么不是 Left(Right(&#39;&#39;)) 或者 Left(Left(e))）。 也就是说我们现在得到的是两层容器，就像俄罗斯套娃一样… 要取出容器中的容器中的值，我们就需要 fold 两次…！（若是再多几层…） 因缺思厅，所以聪明机智的函数式又想出一个新方法 chain~，其实很简单，就是我知道这里要返回容器了，那就不要再用容器包了呗。 12345678910111213141516171819202122...const Left = (x) =&gt; (&#123; ... chain: f =&gt; Left(x) // 和 map 一样，直接返回 Left&#125;)const Right = (x) =&gt; (&#123; ... chain: f =&gt; f(x), // 直接返回，不使用容器再包一层了&#125;)const tryCatch = (f) =&gt; &#123; ... &#125;const getPort = () =&gt; tryCatch( () =&gt; fs.readFileSync('config.json') ) .chain(c =&gt; tryCatch(JSON.parse(c))) // 使用 chain 和 tryCatch .fold( e =&gt; 3000, c =&gt; c.port ) 其实这里的 Left 和 Right 就是单子（Monad），因为它实现了 chain 函数。 monad 是实现了 chain 函数并遵守一些特定规则的容器类型。 在继续介绍这些特定规则前，我们先定义一个 join 函数： 12// 这里的 m 指的是一种 Monad 实例const join = m =&gt; m.chain(x =&gt; x) 规则一： 1join(m.map(join)) === join(join(m))) 规则二： 12// 这里的 M 指的是一种 Monad 类型join(M.of(m)) === join(m.map(M.of)) 这条规则说明了 map 可被 chain 和 of 所定义。 1m.map(f) === m.chain(x =&gt; M.of(f(x))) 也就是说 Monad 一定是 Functor Monad 十分强大，之后我们将利用它处理各种副作用。但别对其感到困惑，chain 的主要作用不过将两种不同的类型连接（join）在一起罢了。 4.4.半群（Semigroup） 定义一：对于非空集合 S，若在 S 上定义了二元运算 ○，使得对于任意的 a, b ∈ S,有 a ○ b ∈ S，则称 {S, ○} 为广群。 定义二：若 {S, ○} 为广群，且运算 ○ 还满足结合律，即：任意 a, b, c ∈ S，有 (a ○ b) ○ c = a ○ (b ○ c)，则称 {S, ○} 为半群。 举例来说，JavaScript 中有 concat 方法的对象都是半群。 12345// 字符串和 concat 是半群'1'.concat('2').concat('3') === '1'.concat('2'.concat('3'))// 数组和 concat 是半群[1].concat([2]).concat([3]) === [1].concat([2].concat([3])) 虽然理论上对于 &lt;Number, +&gt; 来说它符合半群的定义： 数字相加返回的仍然是数字（广群） 加法满足结合律（半群） 但是数字并没有 concat 方法 没事儿，让我们来实现这个由 &lt;Number, +&gt; 组成的半群 Sum。 123456789const Sum = (x) =&gt; (&#123; x, concat: (&#123; x: y &#125;) =&gt; Sum(x + y), // 采用解构获取值 inspect: () =&gt; `Sum($&#123;x&#125;)`,&#125;)Sum(1) .concat(Sum(2)) .inspect() // Sum(3) 除此之外，&lt;Boolean, &amp;&amp;&gt; 也满足半群的定义~ 123456789const All = (x) =&gt; (&#123; x, concat: (&#123; x: y &#125;) =&gt; All(x &amp;&amp; y), // 采用解构获取值 inspect: () =&gt; `All($&#123;x&#125;)`,&#125;)All(true) .concat(All(false)) .inspect() // All(true) 最后，让我们对于字符串创建一个新的半群 First，顾名思义，它会忽略除了第一个参数以外的内容。 123456789const First = (x) =&gt; (&#123; x, concat: () =&gt; First(x), // 忽略后续的值 inspect: () =&gt; `First($&#123;x&#125;)`,&#125;)First('blah') .concat(First('yoyoyo')) .inspect() // First('blah') 咿呀哟？是不是感觉这个半群和其他半群好像有点儿不太一样，不过具体是啥又说不上来…？ 这个问题留给下个小节。在此先说下这玩意儿有啥用。 123456789101112const data1 = &#123; name: 'steve', isPaid: true, points: 10, friends: ['jame'],&#125;const data2 = &#123; name: 'steve', isPaid: false, points: 2, friends: ['young'],&#125; 假设有两个数据，需要将其合并，那么利用半群，我们可以对 name 应用 First，对于 isPaid 应用 All，对于 points 应用 Sum，最后的 friends 已经是半群了… 123456789101112131415161718192021222324252627282930313233const Sum = (x) =&gt; (&#123; ... &#125;)const All = (x) =&gt; (&#123; ... &#125;)const First = (x) =&gt; (&#123; ... &#125;)const data1 = &#123; name: First('steve'), isPaid: All(true), points: Sum(10), friends: ['jame'],&#125;const data2 = &#123; name: First('steve'), isPaid: All(false), points: Sum(2), friends: ['young'],&#125;const concatObj = (obj1, obj2) =&gt; Object.entries(obj1) .map(([ key, val ]) =&gt; (&#123; // concat 两个对象的值 [key]: val.concat(obj2[key]), &#125;)) .reduce((acc, cur) =&gt; (&#123; ...acc, ...cur &#125;))concatObj(data1, data2)/* &#123; name: First('steve'), isPaid: All(false), points: Sum(12), friends: ['jame', 'young'], &#125;*/ 4.5.幺半群（Monoid） 幺半群是一个存在单位元（幺元）的半群。 半群我们都懂，不过啥是单位元？ 单位元：对于半群 &lt;S, ○&gt;，存在 e ∈ S，使得任意 a ∈ S 有 a ○ e = e ○ a 举例来说，对于数字加法这个半群来说，0就是它的单位元，所以 &lt;Number, +, 0&gt; 就构成一个幺半群。同理： 对于 &lt;Number, *&gt; 来说单位元就是 1 对于 &lt;Boolean, &amp;&amp;&gt; 来说单位元就是 true 对于 &lt;Boolean, ||&gt; 来说单位元就是 false 对于 &lt;Number, Min&gt; 来说单位元就是 Infinity 对于 &lt;Number, Max&gt; 来说单位元就是 -Infinity 那么 &lt;String, First&gt; 是幺半群么？ 显然我们并不能找到这样一个单位元 e 满足 First(e).concat(First(&#39;steve&#39;)) === First(&#39;steve&#39;).concat(First(e)) 这就是上一节留的小悬念，为何会感觉 First 与 Sum 和 All 不太一样的原因。 格叽格叽，这两者有啥具体的差别么？ 其实看到幺半群的第一反应应该是默认值或初始值，例如 reduce 函数的第二个参数就是传入一个初始值或者说是默认值。 1234567891011121314151617181920212223242526272829// sumconst Sum = (x) =&gt; (&#123; ... empty: () =&gt; Sum(0), // 单位元&#125;)const sum = xs =&gt; xs.reduce((acc, cur) =&gt; acc + cur, 0)sum([1, 2, 3]) // 6sum([]) // 0，而不是报错！// allconst All = (x) =&gt; (&#123; ... empty: () =&gt; All(true), // 单位元&#125;)const all = xs =&gt; xs.reduce((acc, cur) =&gt; acc &amp;&amp; cur, true)all([true, false, true]) // falseall([]) // true，而不是报错！// firstconst First = (x) =&gt; (&#123; ... &#125;)const first = xs =&gt; xs.reduce(acc, cur) =&gt; acc)first(['steve', 'jame', 'young']) // stevefirst([]) // boom!!! 从以上代码可以看出幺半群比半群要安全得多， 4.6.foldMap1.套路在上一节中幺半群的使用代码中，如果传入的都是幺半群实例而不是原始类型的话，你会发现其实都是一个套路… 12345678const Monoid = (x) =&gt; (&#123; ... &#125;)const monoid = xs =&gt; xs.reduce( (acc, cur) =&gt; acc.concat(cur), // 使用 concat 结合 Monoid.empty() // 传入幺元)monoid([Monoid(a), Monoid(b), Monoid(c)]) // 传入幺半群实例 所以对于思维高度抽象的函数式来说，这样的代码肯定是需要继续重构精简的~ 2.List、Map在讲解如何重构之前，先介绍两个炒鸡常用的不可变数据结构：List、Map。 顾名思义，正好对应原生的 Array 和 Object。 3.利用 List、Map 重构因为 immutable 库中的 List 和 Map 并没有 empty 属性和 fold 方法，所以我们首先扩展 List 和 Map~ 123456789101112131415import &#123; List, Map &#125; from 'immutable'const derived = &#123; fold (empty) &#123; return this.reduce((acc, cur) =&gt; acc.concat(cur), empty) &#125;,&#125;List.prototype.empty = List()List.prototype.fold = derived.foldMap.prototype.empty = Map(&#123;&#125;)Map.prototype.fold = derived.fold// from https://github.com/DrBoolean/immutable-ext 这样一来上一节的代码就可以精简成这样： 1234567891011List.of(1, 2, 3) .map(Sum) .fold(Sum.empty()) // Sum(6)List().fold(Sum.empty()) // Sum(0)Map(&#123; steve: 1, young: 3 &#125;) .map(Sum) .fold(Sum.empty()) // Sum(4)Map().fold(Sum.empty()) // Sum(0) 4.利用 foldMap 重构注意到 map 和 fold 这两步操作，从逻辑上来说是一个操作，所以我们可以新增 foldMap 方法来结合两者。 123456789101112131415161718192021222324252627282930import &#123; List, Map &#125; from 'immutable'const derived = &#123; fold (empty) &#123; return this.foldMap(x =&gt; x, empty) &#125;, foldMap (f, empty) &#123; return empty != null // 幺半群中将 f 的调用放在 reduce 中，提高效率 ? this.reduce( (acc, cur, idx) =&gt; acc.concat(f(cur, idx)), empty ) : this // 在 map 中调用 f 是因为考虑到空的情况 .map(f) .reduce((acc, cur) =&gt; acc.concat(cur)) &#125;,&#125;List.prototype.empty = List()List.prototype.fold = derived.foldList.prototype.foldMap = derived.foldMapMap.prototype.empty = Map(&#123;&#125;)Map.prototype.fold = derived.foldMap.prototype.foldMap = derived.foldMap// from https://github.com/DrBoolean/immutable-ext 所以最终版长这样： 123456789List.of(1, 2, 3) .foldMap(Sum, Sum.empty()) // Sum(6)List() .foldMap(Sum, Sum.empty()) // Sum(0)Map(&#123; a: 1, b: 3 &#125;) .foldMap(Sum, Sum.empty()) // Sum(4)Map() .foldMap(Sum, Sum.empty()) // Sum(0) 4.7.LazyBox下面我们要来实现一个新容器 LazyBox。 顾名思义，这个容器很懒… 虽然你可以不停地用 map 给它分配任务，但是只要你不调用 fold 方法催它执行（就像 deadline 一样），它就死活不执行… 12345678910111213const LazyBox = (g) =&gt; (&#123; map: f =&gt; LazyBox(() =&gt; f(g())), fold: f =&gt; f(g()),&#125;)const result = LazyBox(() =&gt; ' 64 ') .map(s =&gt; s.trim()) .map(i =&gt; parseInt(i)) .map(i =&gt; i + 1) .map(i =&gt; String.fromCharCode(i)) // 没有 fold 死活不执行result.fold(c =&gt; c.toLowerCase()) // a 4.8.Task1.基本介绍有了上一节中 LazyBox 的基础之后，接下来我们来创建一个新的类型 Task。 首先 Task 的构造函数可以接收一个函数以便延迟计算，当然也可以用 of 方法来创建实例，很自然的也有 map、chain、concat、empty 等方法。 与众不同的是它有个 fork 方法（类似于 LazyBox 中的 fold 方法，在 fork 执行前其他函数并不会执行），以及一个 rejected 方法，类似于 Left，忽略后续的操作。 123456789101112131415161718192021222324import Task from 'data.task'const showErr = e =&gt; console.log(`err: $&#123;e&#125;`)const showSuc = x =&gt; console.log(`suc: $&#123;x&#125;`)Task .of(1) .fork(showErr, showSuc) // suc: 1Task .of(1) .map(x =&gt; x + 1) .fork(showErr, showSuc) // suc: 2// 类似 LeftTask .rejected(1) .map(x =&gt; x + 1) .fork(showErr, showSuc) // err: 1Task .of(1) .chain(x =&gt; new Task.of(x + 1)) .fork(showErr, showSuc) // suc: 2 2.使用示例接下来让我们做一个发射飞弹的程序~ 123456789101112131415const lauchMissiles = () =&gt; ( // 和 promise 很像，不过 promise 会立即执行 // 而且参数的位置也相反 new Task((rej, res) =&gt; &#123; console.log('lauchMissiles') res('missile') &#125;))// 继续对之前的任务添加后续操作（duang~给飞弹加特技！）const app = lauchMissiles() .map(x =&gt; x + '!')// 这时才执行（发射飞弹）app.fork(showErr, showSuc) 3.原理意义上面的代码乍一看好像没啥用，只不过是把待执行的代码用函数包起来了嘛，这还能吹上天？ 还记得前面章节说到的副作用么？虽然说使用纯函数是没有副作用的，但是日常项目中有各种必须处理的副作用。 所以我们将有副作用的代码给包起来之后，这些新函数就都变成了纯函数，这样我们的整个应用的代码都是纯的~，并且在代码真正执行前（fork 前）还可以不断地 compose 别的函数，为我们的应用不断添加各种功能，这样一来整个应用的代码流程都会十分的简洁漂亮。 4.异步嵌套示例以下代码做了 3 件事： 读取 config1.json 中的数据 将内容中的 8 替换成 6 将新内容写到 config2.json 中 123456789101112131415import fs from 'fs'const app = () =&gt; ( fs.readFile('config1.json', 'utf-8', (err, contents) =&gt; &#123; if (err) throw err const newContents = content.replace(/8/g, '6') fs.writeFile('config2.json', newContents, (err, _) =&gt; &#123; if (err) throw err console.log('success!') &#125;) &#125;)) 让我们用 Task 来改写一下~ 123456789101112131415161718192021222324252627282930import fs from 'fs'import Task from 'data.task'const cfg1 = 'config1.json'const cfg2 = 'config2.json'const readFile = (file, enc) =&gt; ( new Task((rej, res) =&gt; fs.readFile(file, enc, (err, str) =&gt; err ? rej(err) : res(str) ) ))const writeFile = (file, str) =&gt; ( new Task((rej, res) =&gt; fs.writeFile(file, str, (err, suc) =&gt; err ? rej(err) : res(suc) ) ))const app = readFile(cfg1, 'utf-8') .map(str =&gt; str.replace(/8/g, '6')) .chain(str =&gt; writeFile(cfg2, str))app.fork( e =&gt; console.log(`err: $&#123;e&#125;`), x =&gt; console.log(`suc: $&#123;x&#125;`)) 代码一目了然，按照线性的先后顺序完成了任务，并且在其中还可以随意地插入或修改需求~ 4.9.Applicative Functor1.问题引入Applicative Functor 提供了让不同的函子（functor）互相应用的能力。 为啥我们需要函子的互相应用？什么是互相应用？ 先来看个简单例子： 12345const add = x =&gt; y =&gt; x + yadd(Box.of(2))(Box.of(3)) // NaNBox(2).map(add).inspect() // Box(y =&gt; 2 + y) 现在我们有了一个容器，它的内部值为局部调用（partially applied）后的函数。接着我们想让它应用到 Box(3) 上，最后得到 Box(5) 的预期结果。 说到从容器中取值，那肯定第一个想到 chain 方法，让我们来试一下： 123Box(2) .chain(x =&gt; Box(3).map(add(x))) .inspect() // Box(5) 成功实现~，BUT，这种实现方法有个问题，那就是单子（Monad）的执行顺序问题。 我们这样实现的话，就必须等 Box(2) 执行完毕后，才能对 Box(3) 进行求值。假如这是两个异步任务，那么完全无法并行执行。 别慌，吃口药~ 2.基本介绍下面介绍下主角：ap~： 12345678910const Box = (x) =&gt; (&#123; // 这里 box 是另一个 Box 的实例，x 是函数 ap: box =&gt; box.map(x), ...&#125;)Box(add) // Box(y =&gt; 2 + y) ，咦？在哪儿见过？ .ap(Box(2)) .ap(Box(3)) // Box(5) 运算规则 1234F(x).map(f) === F(f).ap(F(x))// 这就是为什么Box(2).map(add) === Box(add).ap(Box(2)) 3.Lift 家族由于日常编写代码的时候直接用 ap 的话模板代码太多，所以一般通过使用 Lift 家族系列函数来简化。 12345678910111213// F 该从哪儿来？const fakeLiftA2 = f =&gt; fx =&gt; fy =&gt; F(f).ap(fx).ap(fy)// 应用运算规则转换一下~const liftA2 = f =&gt; fx =&gt; fy =&gt; fx.map(f).ap(fy)liftA2(add, Box(2), Box(4)) // Box(6)// 同理const liftA3 = f =&gt; fx =&gt; fy =&gt; fz =&gt; fx.map(f).ap(fy).ap(fz)const liftA4 = ......const liftAN = ... 4.Lift 应用 例1 12345678// 假装是个 jQuery 接口~const $ = selector =&gt; Either.of(&#123; selector, height: 10 &#125;)const getScreenSize = screen =&gt; head =&gt; foot =&gt; screen - (head.height + foot.height)liftA2(getScreenSize(800))($('header'))($('footer')) // Right(780) 例2 12345// List 的笛卡尔乘积List.of(x =&gt; y =&gt; z =&gt; [x, y, z].join('-')) .ap(List.of('tshirt', 'sweater')) .ap(List.of('white', 'black')) .ap(List.of('small', 'medium', 'large')) 例3 1234567891011121314151617181920const Db = (&#123; find: (id, cb) =&gt; new Task((rej, res) =&gt; setTimeout(() =&gt; res(&#123; id, title: `$&#123;id&#125;`&#125;), 100) )&#125;)const reportHeader = (p1, p2) =&gt; `Report: $&#123;p1.title&#125; compared to $&#123;p2.title&#125;`Task.of(p1 =&gt; p2 =&gt; reportHeader(p1, p2)) .ap(Db.find(20)) .ap(Db.find(8)) .fork(console.error, console.log) // Report: 20 compared to 8liftA2 (p1 =&gt; p2 =&gt; reportHeader(p1, p2)) (Db.find(20)) (Db.find(8)) .fork(console.error, console.log) // Report: 20 compared to 8 4.10.Traversable1.问题引入1234567891011import fs from 'fs'// 详见 4.8.const readFile = (file, enc) =&gt; ( new Task((rej, res) =&gt; ...))const files = ['a.js', 'b.js']// [Task, Task]，我们得到了一个 Task 的数组files.map(file =&gt; readFile(file, 'utf-8')) 然而我们想得到的是一个包含数组的 Task([file1, file2])，这样就可以调用它的 fork 方法，查看执行结果。 为了解决这个问题，函数式编程一般用一个叫做 traverse 的方法来实现。 123files .traverse(Task.of, file =&gt; readFile(file, 'utf-8')) .fork(console.error, console.log) traverse 方法第一个参数是创建函子的函数，第二个参数是要应用在函子上的函数。 2.实现其实以上代码有 bug…，因为数组 Array 是没有 traverse 方法的。没事儿，让我们来实现一下~ 1234567891011Array.prototype.empty = []// traversableArray.prototype.traverse = function (point, fn) &#123; return this.reduce( (acc, cur) =&gt; acc .map(z =&gt; y =&gt; z.concat(y)) .ap(fn(cur)), point(this.empty) )&#125; 看着有点儿晕？ 不急，首先看代码主体是一个 reduce，这个很熟了，就是从左到右遍历元素，其中的第二个参数传递的就是幺半群（monoid）的单位元（empty）。 再看第一个参数，主要就是通过 applicative functor 调用 ap 方法，再将其执行结果使用 concat 方法合并到数组中。 所以最后返回的就是 Task([foo, bar])，因此我们可以调用 fork 方法执行它。 4.11.自然变换（Natural Transformations）1.基本概念自然变换就是一个函数，接受一个函子（functor），返回另一个函子。看看代码熟悉下~ 1const boxToEither = b =&gt; b.fold(Right) 这个 boxToEither 函数就是一个自然变换（nt），它将函子 Box 转换成了另一个函子 Either。 那么我们用 Left 行不行呢？ 答案是不行！ 因为自然变换不仅是将一个函子转换成另一个函子，它还满足以下规则： 1nt(x).map(f) == nt(x.map(f)) 举例来说就是： 1234567const res1 = boxToEither(Box(100)) .map(x =&gt; x * 2)const res2 = boxToEither( Box(100).map(x =&gt; x * 2))res1 === res2 // Right(200) 即先对函子 a 做改变再将其转换为函子 b，是等价于先将函子 a 转换为函子 b 再做改变。 显然，Left 并不满足这个规则。所以任何满足这个规则的函数都是自然变换。 2.应用场景1.例1：得到一个数组小于等于 100 的最后一个数的两倍的值 12345678const arr = [2, 400, 5, 1000]const first = xs =&gt; fromNullable(xs[0])const double = x =&gt; x * 2const getLargeNums = xs =&gt; xs.filter(x =&gt; x &gt; 100)first( getLargeNums(arr).map(double)) 根据自然变换，它显然和 first(getLargeNums(arr)).map(double) 是等价的。但是后者显然性能好得多。 再来看一个更复杂一点儿的例子： 2.例2：找到 id 为 3 的用户的最好的朋友的 id 123456789101112131415161718// 假 apiconst fakeApi = (id) =&gt; (&#123; id, name: 'user1', bestFriendId: id + 1,&#125;)// 假 Dbconst Db = &#123; find: (id) =&gt; new Task( (rej, res) =&gt; ( res(id &gt; 2 ? Right(fakeApi(id)) : Left('not found') ) ) )&#125; 1234567891011121314151617181920// Task(Either(user))const zero = Db.find(3)// 第一版// Task(Either(Task(Either(user)))) ???const one = zero .map(either =&gt; either .map(user =&gt; Db .find(user.bestFriendId) ) ) .fork( console.error, either =&gt; either // Either(Task(Either(user))) .map(t =&gt; t.fork( // Task(Either(user)) console.error, either =&gt; either .map(console.log), // Either(user) )) ) 这是什么鬼？？？ 肯定不能这么干… 123456789101112131415161718// Task(Either(user))const zero = Db.find(3)// 第二版const two = zero .chain(either =&gt; either .fold(Task.rejected, Task.of) // Task(user) .chain(user =&gt; Db .find(user.bestFriendId) // Task(Either(user)) ) .chain(either =&gt; either .fold(Task.rejected, Task.of) // Task(user) ) ) .fork( console.error, console.log, ) 第二版的问题是多余的嵌套代码。 123456789101112131415161718// Task(Either(user))const zero = Db.find(3)// 第三版const three = zero .chain(either =&gt; either .fold(Task.rejected, Task.of) // Task(user) ) .chain(user =&gt; Db .find(user.bestFriendId) // Task(Either(user)) ) .chain(either =&gt; either .fold(Task.rejected, Task.of) // Task(user) ) .fork( console.error, console.log, ) 第三版的问题是多余的重复逻辑。 1234567891011121314151617181920212223242526272829303132// Task(Either(user))const zero = Db.find(3)// 这其实就是自然变换// 将 Either 变换成 Taskconst eitherToTask = (e) =&gt; ( e.fold(Task.rejected, Task.of))// 第四版const four = zero .chain(eitherToTask) // Task(user) .chain(user =&gt; Db .find(user.bestFriendId) // Task(Either(user)) ) .chain(eitherToTask) // Task(user) .fork( console.error, console.log, )// 出错版const error = Db.find(2) // Task(Either(user)) // Task.rejected('not found') .chain(eitherToTask) // 这里永远不会被调用，被跳过了 .chain(() =&gt; console.log('hey man')) ... .fork( console.error, // not found console.log, ) 4.12.同构（Isomorphism） 同构是在数学对象之间定义的一类映射,它能揭示出在这些对象的属性或者操作之间存在的关系。 简单来说就是两种不同类型的对象经过变形，保持结构并且不丢失数据。 具体怎么做到的呢？ 其实同构就是一对儿函数：to 和 from，遵守以下规则： 12to(from(x)) === xfrom(to(y)) === y 这其实说明了这两个类型都能够无损地保存同样的信息。 1. 例如 String 和 [Char] 就是同构的。1234567891011// String ~ [Char]const Iso = (to, from) =&gt; (&#123; to, from &#125;)const chars = Iso( s =&gt; s.split(''), c =&gt; c.join(''))const str = 'hello world'chars.from(chars.to(str)) === str 这能有啥用呢？ 123456789const truncate = (str) =&gt; ( chars.from( // 我们先用 to 方法将其转成数组 // 这样就能使用数组的各类方法 chars.to(str).slice(0, 3) ).concat('...'))truncate(str) // hel... 2. 再来看看最多有一个参数的数组 [a] 和 Either 的同构关系123456789101112131415161718192021// [a] ~ Either null aconst singleton = Iso( e =&gt; e.fold(() =&gt; [], x =&gt; [x]), ([ x ]) =&gt; x ? Right(x) : Left())const filterEither = (e, pred) =&gt; singleton .from( singleton .to(e) .filter(pred) )const getUCH = (str) =&gt; filterEither( Right(str), x =&gt; x.match(/h/ig)).map(x =&gt; x.toUpperCase())getUCH('hello') // Right(HELLO)getUCH('ello') // Left(undefined) 参考资料 JS函数式编程指南 Pointfree 编程风格指南 Hey Underscore, You’re Doing It Wrong! Functional Concepts with JavaScript: Part I Professor Frisby Introduces Composable Functional JavaScript 函数式编程入门教程 What are Functional Programming,Monad, Monoid, Applicative, Functor ?? 以上 to be continued…","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://buptsteve.github.io/blog/tags/JavaScript/"},{"name":"FP","slug":"FP","permalink":"https://buptsteve.github.io/blog/tags/FP/"},{"name":"函数式","slug":"函数式","permalink":"https://buptsteve.github.io/blog/tags/函数式/"}]},{"title":"「13」微信小程序之如何使用自定义组件封装原生 image 组件","date":"2018-06-17T10:45:00.000Z","path":"2018/06/17/013.how-to-encapsulate-image-in-mina/","text":"零、问题的由来一般在前端展示图片时都会碰到这两个常见的需求： 图片未加载完成时先展示占位图，等到图片加载完毕后再展示实际的图片。 假如图片链接有问题（比如 404），依然展示占位图。甚至你还可以增加点击图片再次加载的功能。（例如知乎） 然鹅，小程序原生组件 image 并没有提供这些常用功能… 注：这里加了 2s 的延迟 一、常规操作在小程序没还没推出自定义组件功能时，只能通过改变 Page 中的 data 来展示兜底的占位图，所以当时的处理方式十分蛋疼… 1.1.相同默认图由于需要知道这个图片的数据路径，所以不得不在每个 image 上加上类似 data-img-path 的东西。 123456789101112&lt;view wx:for=\"&#123;&#123; obj.arr &#125;&#125;\" wx:key=\"imgSrc\" wx:for-item=\"item\" wx:for-index=\"itemIdx\"&gt; &lt;image src=\"&#123;&#123; item.imgSrc &#125;&#125;\" binderror=\"onImageError\" data-img-path=\"obj.arr[&#123;&#123; itemIdx &#125;&#125;].imgSrc\" /&gt;&lt;/view&gt; 12345678910111213141516171819const DEFAULT_IMG = '/assets/your_default_img'Page(&#123; data: &#123; obj: &#123; arr: [ &#123; imgSrc: 'your_img1' &#125;, &#123; imgSrc: 'your_img2' &#125;, ], &#125;, &#125;, onImageError (&#123; target: &#123; dataset: &#123; imgPath &#125; &#125;, &#125;) &#123; this.setData(&#123; [imgPath]: DEFAULT_IMG, &#125;) &#125;,&#125;) 1.2.不同默认图如果默认图片不同呢？例如球员、球队和 feed 的默认图片一般都是不同的。 那么一般只好再增加一个属性例如 data-img-type 来标识默认图的类型。 12345678910&lt;!-- 球队图 --&gt;&lt;image ... data-img-type=\"team\"/&gt;&lt;!-- 球员图 --&gt;&lt;image ... data-img-type=\"player\"/&gt; 1234567891011121314151617181920212223const DEFAULT_IMG_MAP = &#123; feed: '/assets/default_feed', team: '/assets/default_team', player: '/assets/default_player',&#125;Page(&#123; data: &#123; obj: &#123; arr: [ &#123; imgSrc: 'your_img1' &#125;, &#123; imgSrc: 'your_img2' &#125;, ], &#125;, &#125;, onImageError (&#123; target: &#123; dataset: &#123; imgPath, imgType &#125; &#125;, &#125;) &#123; this.setData(&#123; [imgPath]: DEFAULT_IMG_MAP[imgType], &#125;) &#125;,&#125;) 1.3.图片在模板中页面层级浅倒还好，如果跨模板了，那么模板就可能要用一个类似于 pathPrefix 的属性来传递模板数据的路径前缀。 123456789101112131415161718192021&lt;!-- 球员排行模板 pathPrefix: String playerList: Array ...--&gt;&lt;template name=\"srPlayerRank\"&gt; &lt;view wx:for=\"&#123;&#123; playerList &#125;&#125;\" wx:key=\"imgSrc\" wx:for-item=\"item\" wx:for-index=\"itemIdx\" &gt; &lt;image src=\"&#123;&#123; item.imgSrc &#125;&#125;\" binderror=\"onImageError\" data-img-type=\"player\" data-img-path=\"&#123;&#123; pathPrefix &#125;&#125;.playerList[&#123;&#123; itemIdx &#125;&#125;].imgSrc\" /&gt; &lt;/view&gt;&lt;/template&gt; 最后在失败回调里调用 setData({ [path]: DEFAULT_IMG }) 重新设置图片地址。 就问你蛋不蛋疼？这一坨 data-img-path=&quot;.playerList[].imgSrc&quot; 代码真让人无发可脱… 二、自定义组件有了自定义组件后，用领袖【窃·格瓦拉】的话来说的话就是：“感觉好 door 了~” 2.1.原生自定义组件原生写法一般要写4个文件：.json/.wxml/.js/.wxss TuaImage.json 123&#123; \"component\": true&#125; TuaImage.wxml 12345678910111213141516171819&lt;!-- 加载中的图片 --&gt;&lt;image hidden=\"&#123;&#123; !isLoading &#125;&#125;\" src=\"&#123;&#123; errSrc &#125;&#125;\" style=\"width: &#123;&#123; width &#125;&#125;; height: &#123;&#123; height &#125;&#125;; &#123;&#123; styleStr &#125;&#125;\" mode=\"&#123;&#123; imgMode &#125;&#125;\"/&gt;&lt;!-- 实际加载的图片 --&gt;&lt;image hidden=\"&#123;&#123; isLoading &#125;&#125;\" src=\"&#123;&#123; imgSrc || src &#125;&#125;\" mode=\"&#123;&#123; imgMode &#125;&#125;\" style=\"width: &#123;&#123; width &#125;&#125;; height: &#123;&#123; height &#125;&#125;; &#123;&#123; styleStr &#125;&#125;\" bindload=\"_onImageLoad\" binderror=\"_onImageError\" lazy-load=\"&#123;&#123; true &#125;&#125;\"/&gt; TuaImage.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const DEFAULT_IMG = '/assets/your_default_img'Component(&#123; properties: &#123; // 图片地址 src: String, // 图片加载中，以及加载失败后的默认地址 errSrc: &#123; type: String, // 默认是球队图标 value: DEFAULT_IMG, &#125;, width: &#123; type: String, value: '48rpx', &#125;, height: &#123; type: String, value: '48rpx', &#125;, // 样式字符串 styleStr: &#123; type: String, value: '', &#125;, // 图片裁剪、缩放的模式（详见文档） imgMode: &#123; type: String, value: 'scaleToFill', &#125;, &#125;, data: &#123; imgSrc: '', isLoading: true, &#125;, methods: &#123; // 加载图片出错 _onImageError (e) &#123; this.setData(&#123; imgSrc: this.data.errSrc, &#125;) this.triggerEvent('onImageError', e) &#125;, // 加载图片完毕 _onImageLoad (e) &#123; this.setData(&#123; isLoading: false &#125;) this.triggerEvent('onImageLoad', e) &#125;, &#125;,&#125;) 布吉岛大家使用原生写法时有木有一些感觉不方便的地方： 4个文件：.json/.wxml/.js/.wxss，这样老需要切来切去的降低效率 properties 是什么鬼？大家（React/Vue）一般不都用 props 么？ style=&quot;width: ; height: ; &quot; 样式字符串怎么辣么长… 2.2.TuaImage.vue所以以下是一个使用单文件组件封装原生 image 组件的例子。 使用单文件组件将配置、模板、脚本、样式写在一个文件中，方便维护。 使用计算属性 computed 将样式字符串写在 js 中。 使用 this.imgSrc = this.errSrc 而不是 this.setData 来改变 data。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;config&gt;&#123; \"component\": true&#125;&lt;/config&gt;&lt;template lang=\"wxml\"&gt; &lt;!-- 加载中的图片 --&gt; &lt;image hidden=\"&#123;&#123; !isLoading &#125;&#125;\" src=\"&#123;&#123; errSrc &#125;&#125;\" style=\"&#123;&#123; imgStyleStr &#125;&#125;\" mode=\"&#123;&#123; imgMode &#125;&#125;\" /&gt; &lt;!-- 实际加载的图片 --&gt; &lt;image hidden=\"&#123;&#123; isLoading &#125;&#125;\" src=\"&#123;&#123; imgSrc || src &#125;&#125;\" mode=\"&#123;&#123; imgMode &#125;&#125;\" style=\"&#123;&#123; imgStyleStr &#125;&#125;\" bindload=\"_onImageLoad\" binderror=\"_onImageError\" lazy-load=\"&#123;&#123; true &#125;&#125;\" /&gt;&lt;/template&gt;&lt;script&gt;/** * 图片组件，能够传递备用图片以防图片失效 * https://developers.weixin.qq.com/miniprogram/dev/component/image.html */// 也可以设置为网络图片如： https://foo/bar.pngconst DEFAULT_IMG = '/assets/your_default_img'export default &#123; props: &#123; // 图片地址 src: String, // 图片加载中，以及加载失败后的默认地址 errSrc: &#123; type: String, // 默认是球队图标 default: DEFAULT_IMG, &#125;, width: &#123; type: String, default: '48rpx', &#125;, height: &#123; type: String, default: '48rpx', &#125;, // 样式字符串 styleStr: &#123; type: String, default: '', &#125;, // 图片裁剪、缩放的模式（详见文档） imgMode: &#123; type: String, default: 'scaleToFill', &#125;, &#125;, data () &#123; return &#123; imgSrc: '', isLoading: true, &#125; &#125;, computed: &#123; // 样式字符串 imgStyleStr () &#123; return `width: $&#123;this.width&#125;; height: $&#123;this.height&#125;; $&#123;this.styleStr&#125;` &#125;, &#125;, methods: &#123; // 加载图片出错 _onImageError (e) &#123; this.imgSrc = this.errSrc this.$emit('onImageError', e) &#125;, // 加载图片完毕 _onImageLoad (e) &#123; this.isLoading = false this.$emit('onImageLoad', e) &#125;, &#125;,&#125;&lt;/script&gt;&lt;style lang=\"scss\"&gt;&lt;/style&gt; 采用框架是 tua-mp： github 源码地址 相关文章： 终极蛇皮上帝视角之微信小程序之告别 setData 终极蛇皮上帝视角之微信小程序之告别“刀耕火种”","tags":[{"name":"tua-mp","slug":"tua-mp","permalink":"https://buptsteve.github.io/blog/tags/tua-mp/"},{"name":"小程序","slug":"小程序","permalink":"https://buptsteve.github.io/blog/tags/小程序/"}]},{"title":"「12」终极蛇皮上帝视角之微信小程序之告别“刀耕火种”","date":"2018-06-03T09:45:00.000Z","path":"2018/06/03/012.say-goodbye-to-mina-native/","text":"开门见山地说，小程序在日常开发中使用原生框架来开发还是挺不方便的，比如： 不支持 npm 包 不支持各种 CSS 预编译器 不支持配置 Babel 来转换一些 JavaScript 新特性 这样一来和日常开发前端页面的体验相比来说，简直就像在刀耕火种。 那么为了解决这些问题，我们能不能将前端开发中常用的 webpack 移植到小程序开发中呢？ 当然可以！ 0.源码地址 在 webpack-simple 中文件结构和小程序相似。 而在 webpack-vue 中还增加了 vue-loader，因此你甚至还能利用 .vue 文件编写单文件组件。 注：已封装到 https://tuateam.github.io/tua-mp/tua-mp-service/ 中… 1.文件结构既然用 webpack 来编译源代码，那么很自然的我们的文件结构首先要分为 src/ 和 dist/，开发者工具的目标应该是 dist/ 目录。 注：开发者工具打开的应该是根目录，这样可以保存各种设置，可以在 project.config.json 中配置 &quot;miniprogramRoot&quot;: &quot;./dist/&quot;, 1.1.src/ 中文件结构大概长这样：1234567891011121314151617181920212223242526272829303132333435.├── app│ ├── app.js│ ├── app.json│ └── app.scss├── assets│ └── vue-logo.png├── comps│ └── todo│ ├── todo.js│ ├── todo.json│ ├── todo.less│ └── todo.wxml├── pages│ └── index│ ├── index.js│ ├── index.json│ ├── index.less│ └── index.wxml├── scripts│ ├── const│ │ ├── README.md│ │ └── index.js│ └── utils│ ├── README.md│ ├── event.js│ ├── format.js│ ├── index.js│ └── log.js├── styles│ ├── global.styl│ ├── todomvc-app-css.css│ └── todomvc-common-base.css└── templates └── info.wxml app/: 应用入口 assets/: 资源文件，比如图片 comps/: 组件 pages/: 页面 scripts: 公用代码 scripts/const: 常量（已配置别名 @const） scripts/utils: 辅助函数（已配置别名 @utils） styles/: 公用样式 templates/: 模板 1.2.dist/ 中文件结构大概长这样：123456789101112131415161718192021222324252627282930.├── app.js├── app.js.map├── app.json├── app.wxss├── assets│ └── vue-logo.png├── chunks│ ├── runtime.js│ ├── runtime.js.map│ ├── scripts.js│ ├── scripts.js.map│ ├── vendors.js│ └── vendors.js.map├── comps│ └── todo│ ├── todo.js│ ├── todo.js.map│ ├── todo.json│ ├── todo.wxml│ └── todo.wxss├── pages│ └── index│ ├── index.js│ ├── index.js.map│ ├── index.json│ ├── index.wxml│ └── index.wxss└── templates └── info.wxml chunks/: 公共依赖 runtime: 是 webapck 在运行时连接各个模块的代码 vendors: 是提取的 node_modules 下的依赖 scripts: 是提取的 src/scripts/ 下的依赖 1.3.整个项目文件结构大概长这样：12345678.├── README.md├── dist/├── package.json├── project.config.json├── src/├── webpack.config.babel.js└── yarn.lock src/: 源码 dist/: 打包后代码 2.webpack 基础配置2.1.entry/output小程序场景下的配置应该是多入口，主要分为 app、pages、comps 这三类。 app: 将 src/app/ 下的文件编译成 dist/ 根目录下的 app.js/app.json/app.wxss pages: src/pages/ -&gt; dist/pages/ comps: src/comps/ -&gt; dist/comps/ 在输出 output 部分有个坑：因为小程序使用的是 global，所以必须添加配置 output.globalObject 为 global。 不然… 123456789101112131415thirdScriptError VM937:1 sdk uncaught third Error Cannot read property 'webpackJsonp' of undefined TypeError: Cannot read property 'webpackJsonp' of undefined at http://127.0.0.1:40247/appservice/chunks/runtime.js:34:51 at http://127.0.0.1:40247/appservice/chunks/runtime.js:38:2 at require (http://127.0.0.1:40247/appservice/__dev__/WAService.js:19:7859) at http://127.0.0.1:40247/appservice/__dev__/WAService.js:19:7573 at http://127.0.0.1:40247/appservice/app.js:3:1 at require (http://127.0.0.1:40247/appservice/__dev__/WAService.js:19:7859) at http://127.0.0.1:40247/appservice/appservice?t=1527755092895:1020:9// runtimevar a = window.webpackJsonp = window.webpackJsonp || [] 详情可参阅这个 pr ps 在 mpvue 中似乎是通过修改 target 实现的… http://mpvue.com/build/mpvue-webpack-target/ 2.2.CommonChunk在 webpack 4 中有一个 breaking change，即使用 SplitChunksPlugin 替换了之前很常用的 CommonsChunkPlugin 主要提取了三部分的公共代码： runtime: 是 webapck 在运行时连接各个模块的代码 vendors: 是提取的 node_modules 下的依赖 scripts: 是提取的 src/scripts/ 下的依赖 现在又碰到个新的问题：如何引入这些 chunks？ 在前端项目中一般我们通过 HtmlWebpackPlugin 插件在 html 文件中添加 &lt;script&gt; 标签引入，然鹅小程序中并没有 html 文件… 计将安出？ 总不能每次都手动去 dist/app.js 中 require 这些文件吧？ 这时候就要介绍另一款插件了~：BannerPlugin。 这个插件本来是用在文件头部添加 banner 的，但是也支持插入代码，因此利用这款插件我们就可以将这些公共依赖在 app.js 中统一引入一次即可。 TODO: 现版本的小程序提供了分包加载能力，因此这里还有优化空间 2.3.CopyWebpackPlugin顾名思义，这款插件的用处就是拷贝，利用这款插件我们就可以实现： 复制 *.json 复制 *.wxml 复制 *.wxss 复制 assets/ 复制 templates/ 在使用时有一个知识点可以减少代码量：即 context 选项，这样就不用写 n 个 src/了… 123new CopyWebpackPlugin(copyCfgArr, &#123; context: resolve('src'),&#125;), 2.4.预处理器和 CSS 的处理这部分其实都是常规操作和一般 web 开发没啥区别，配置好对应的 loader 即可。 需要注意的点就是一定要使用 ExtractTextWebpackPlugin 插件来生成 .wxss 文件。 1new ExtractTextPlugin('[name].wxss') 注：已换成 mini-css-extract-plugin 3.webpack + vue-loader这部分谈谈如何利用 vue-loader 实现在小程序中引用单文件组件（.vue）。 先看看 src/ 下的文件结构： 12345678910111213141516171819202122232425262728293031323334353637.├── app│ ├── App.vue│ ├── app.js│ └── app.json├── assets│ └── vue-logo.png├── comps│ ├── Filter│ │ ├── Filter.vue│ │ └── index.js│ └── Todo│ ├── Todo.vue│ └── index.js├── pages│ ├── index│ │ ├── Index.vue│ │ └── index.js│ └── todos│ ├── Todos.vue│ └── index.js├── scripts│ ├── const│ │ ├── README.md│ │ └── index.js│ └── utils│ ├── README.md│ ├── event.js│ ├── format.js│ ├── index.js│ └── log.js├── styles│ ├── global.styl│ ├── todomvc-app-css.css│ └── todomvc-common-base.css└── templates └── info.wxml 其实已经和一般的 web 项目很相似了~ 3.1.vue-loader v15?随着 webpack 升级到了 v4，官方与之配合的 vue-loader 也升级到了 v15。 现在 Vue Loader 15 使用了一个不一样的策略来推导语言块使用的 loader。 在 v15 中，&lt;style lang=&quot;less&quot;&gt; 会完成把它当作一个真实的 *.less 文件来加载。因此，为了这样处理它，你需要在你的主 webpack 配置中显式地提供一条规则。 简单来说就是咱们之前配置过的各个预处理器规则会被 vue-loader 自动使用。 因此我们只需要简单地添加一条规则即可读取 .vue 文件： 12345678910111213&#123; test: /\\.vue$/, exclude: /node_modules/, loader: 'vue-loader', options: &#123; compiler: &#123; // mock vue-template-compiler compile: () =&gt; (&#123; staticRenderFns: [], &#125;) &#125;, &#125;,&#125;, options.compiler 是啥？ 注意：随着 vue-loader 的升级，这部分的 mock 有变化… 123456789options: &#123; // mock vue-template-compiler compile: () =&gt; (&#123; staticRenderFns: [], &#125;), parseComponent: require('vue-template-compiler') .parseComponent, &#125;,&#125;, 3.2.options.compileroptions.compiler 覆写用来编译单文件组件中 &lt;template&gt; 块的默认编译器。 在实际使用单文件组件时，我们通过 &lt;template lang=&quot;wxml&quot;&gt; 来包裹原本的 .wxml 文件中的内容。 因为最终要编译成 .wxml 文件才能被开发者工具识别，所以我们还编写了一条规则通过 file-loader 生成最终的 .wxml 文件： 1234567891011&#123; // 处理 &lt;template lang=\"wxml\"&gt;&#123;...&#125;&lt;/template&gt; // 生成 .wxml 文件 test: /\\.wxml$/, use: &#123; loader: 'file-loader', options: &#123; name: getNameByFilePathAndExt('.wxml'), &#125;, &#125;,&#125;, 但是因为 vue-loader 默认会编译 template 中的内容将其生成一个个 render 函数。但其实在小程序场景中我们并不需要这一步骤。我们只想安安静静地将这些代码通过 file-loader 生成 .wxml 文件… 幸好 vue-loader 还提供了 options.compiler 这个参数用来传递自己的编译器。所以这里其实是 mock 了一下 vue-template-compiler。 3.3.Custom Blocks 最后还有个问题没有解决：如何处理 .json 文件？ 在其他的小程序框架中是这样处理的： 在 wepy 中将其作为组件的 config 属性 12345678export default class Index extends wepy.page &#123; //页面配置 config = &#123; \"navigationBarTitleText\": \"test\" &#125;; // ...&#125; 在 mpvue 中是写在 main.js 的输出部分 123456789101112131415161718192021// main.jsexport default &#123; // 这个字段走 app.json config: &#123; // 页面前带有 ^ 符号的，会被编译成首页，其他页面可以选填，我们会自动把 webpack entry 里面的入口页面加进去 pages: ['pages/logs/main', '^pages/index/main'], window: &#123; backgroundTextStyle: 'light', navigationBarBackgroundColor: '#fff', navigationBarTitleText: 'WeChat', navigationBarTextStyle: 'black' &#125; &#125;&#125;// src/pages/logs/main.jsexport default &#123; config: &#123; navigationBarTitleText: '查看启动日志' &#125;&#125; 在 tua-mp 中目前采用的是自定义块的方式来实现的，即在 .vue 文件中新增了一个 &lt;config&gt; 块来编写配置。 123456789&lt;config&gt;&#123; \"navigationBarTitleText\": \"查看启动日志\"&#125;&lt;/config&gt;&lt;template lang=\"wxml\"&gt; ...&lt;/template&gt; 但是并没有将 app.json 的内容放到 App.vue 中，因为有时需要读取这里的页面配置。如果写到 &lt;config&gt; 中的话，就无法读取了… 例如为了实现从分享后的页面后退返回首页这个功能，在辅助函数中就需要读取页面和 tabBar 配置，生成分享链接（实际分享地址是首页，然后从首页再导航到被分享的页面）。 因此最优解是页面配置写在 &lt;config&gt; 中，应用配置写在 app.js 的输出中。 TODO: 实现 mpvue 的方式处理 app.json 具体的配置如下： 1234567891011&#123; // 处理 &lt;config&gt;&#123;...&#125;&lt;/config&gt; 代码块 // 生成 .json 文件 resourceQuery: /blockType=config/, use: &#123; loader: 'file-loader', options: &#123; name: getNameByFilePathAndExt('.json'), &#125;, &#125;,&#125;, 4.总结综上，咱们在 webpack v4 和 vue-loader v15 的帮助下，让小程序拥有了以下能力： 加载 npm 包 提取 CommonChunk 减少打包体积 babel 编译 JavaScript 代码 支持 less/sass/stylus 等预处理器 单文件组件 不过话又说回来了… 原生的小程序…又不是不能用~ 注：这句话是黄章说的，Teacher Luo 没说过这话哟~ 以上 to be continued…","tags":[{"name":"tua-mp","slug":"tua-mp","permalink":"https://buptsteve.github.io/blog/tags/tua-mp/"},{"name":"小程序","slug":"小程序","permalink":"https://buptsteve.github.io/blog/tags/小程序/"}]},{"title":"「11」终极蛇皮上帝视角之微信小程序之告别 setData","date":"2018-05-20T16:00:00.000Z","path":"2018/05/21/011.say-goodbye-to-mina-setData/","text":"众所周知 Vue 是借助 ES5 的 Object.defineProperty 方法设置 getter、setter 达到数据驱动界面，当然其中还有模板编译等等其他过程。 而小程序官方的 api 是在 Page 中调用 this.setData 方法来改变数据，从而改变界面。 那么假如我们将两者结合一下，将 this.setData 封装起来，岂不是可以像开发 Vue 应用一样地使用 this.foo = &#39;hello&#39; 来开发小程序了？ 更进一步地，可以实现 h5 和小程序 js 部分代码的同构 更进一步地，增加模板编译和解析就可以连 wxml/html 部分也同构 更进一步地，兼容 RN/Weex/快应用 更进一步地，世界大同，天下为公，前端工程师全部失业…23333 0.源码地址 github 地址 1.绑定简单属性第一步我们先定一个小目标：挣他一个亿！！！ 对于简单非嵌套属性（非对象，数组），直接对其赋值就能改变界面。 123&lt;!-- index.wxml --&gt;&lt;view&gt;msg: &#123;&#123; msg &#125;&#125;&lt;/view&gt;&lt;button bindtap=\"tapMsg\"&gt;change msg&lt;/button&gt; 12345678910111213141516// index.jsTuaPage(&#123; data () &#123; return &#123; msg: 'hello world', &#125; &#125;, methods: &#123; tapMsg () &#123; this.msg = this.reverseStr(this.msg) &#125;, reverseStr (str) &#123; return str.split('').reverse().join('') &#125;, &#125;,&#125;) 这一步很简单啦，直接对于 data 中的每个属性都绑定下 getter、setter，在 setter 中调用下 this.setData 就好啦。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * 将 source 上的属性代理到 target 上 * @param &#123;Object&#125; source 被代理对象 * @param &#123;Object&#125; target 被代理目标 */const proxyData = (source, target) =&gt; &#123; Object.keys(source).forEach((key) =&gt; &#123; Object.defineProperty( target, key, Object.getOwnPropertyDescriptor(source, key) ) &#125;)&#125;/** * 遍历观察 vm.data 中的所有属性，并将其直接挂到 vm 上 * @param &#123;Page|Component&#125; vm Page 或 Component 实例 */const bindData = (vm) =&gt; &#123; const defineReactive = (obj, key, val) =&gt; &#123; Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get () &#123; return val &#125;, set (newVal) &#123; if (newVal === val) return val = newVal vm.setData($data) &#125;, &#125;) &#125; /** * 观察对象 * @param &#123;any&#125; obj 待观察对象 * @return &#123;any&#125; 已被观察的对象 */ const observe = (obj) =&gt; &#123; const observedObj = Object.create(null) Object.keys(obj).forEach((key) =&gt; &#123; // 过滤 __wxWebviewId__ 等内部属性 if (/^__.*__$/.test(key)) return defineReactive( observedObj, key, obj[key] ) &#125;) return observedObj &#125; const $data = observe(vm.data) vm.$data = $data proxyData($data, vm)&#125;/** * 适配 Vue 风格代码，使其支持在小程序中运行（告别不方便的 setData） * @param &#123;Object&#125; args Page 参数 */export const TuaPage = (args = &#123;&#125;) =&gt; &#123; const &#123; data: rawData = &#123;&#125;, methods = &#123;&#125;, ...rest &#125; = args const data = typeof rawData === 'function' ? rawData() : rawData Page(&#123; ...rest, ...methods, data, onLoad (...options) &#123; bindData(this) rest.onLoad &amp;&amp; rest.onLoad.apply(this, options) &#125;, &#125;)&#125; 2.绑定嵌套对象 那么如果数据是嵌套的对象咋办咧？ 其实也很简单，咱们递归观察一下就好。 123&lt;!-- index.wxml --&gt;&lt;view&gt;a.b: &#123;&#123; a.b &#125;&#125;&lt;/view&gt;&lt;button bindtap=\"tapAB\"&gt;change a.b&lt;/button&gt; 12345678910111213141516// index.jsTuaPage(&#123; data () &#123; return &#123; a: &#123; b: 'this is b' &#125;, &#125; &#125;, methods: &#123; tapAB () &#123; this.a.b = this.reverseStr(this.a.b) &#125;, reverseStr (str) &#123; return str.split('').reverse().join('') &#125;, &#125;,&#125;) observe -&gt; observeDeep：在 observeDeep 中判断是对象就递归观察下去。 123456789101112131415161718192021222324252627282930// .../** * 递归观察对象 * @param &#123;any&#125; obj 待观察对象 * @return &#123;any&#125; 已被观察的对象 */const observeDeep = (obj) =&gt; &#123; if (typeof obj === 'object') &#123; const observedObj = Object.create(null) Object.keys(obj).forEach((key) =&gt; &#123; if (/^__.*__$/.test(key)) return defineReactive( observedObj, key, // -&gt; 注意在这里递归 observeDeep(obj[key]), ) &#125;) return observedObj &#125; // 简单属性直接返回 return obj&#125;// ... 3.劫持数组方法大家都知道，Vue 劫持了一些数组方法。咱们也来依葫芦画瓢地实现一下~ 1234567891011121314151617181920212223242526272829/** * 劫持数组的方法 * @param &#123;Array&#125; arr 原始数组 * @return &#123;Array&#125; observedArray 被劫持方法后的数组 */const observeArray = (arr) =&gt; &#123; const observedArray = arr.map(observeDeep) ;[ 'pop', 'push', 'sort', 'shift', 'splice', 'unshift', 'reverse', ].forEach((method) =&gt; &#123; const original = observedArray[method] observedArray[method] = function (...args) &#123; const result = original.apply(this, args) vm.setData($data) return result &#125; &#125;) return observedArray&#125; 其实，Vue 还做了个优化，如果当前环境有 __proto__ 属性，那么就把以上方法直接加到数组的原型链上，而不是对每个数组数据的方法进行修改。 4.实现 computed 功能computed 功能日常还蛮常用的，通过已有的 data 元数据，派生出一些方便的新数据。 要实现的话，因为 computed 中的数据都定义成函数，所以其实直接将其设置为 getter 就行啦。 12345678910111213141516171819202122232425/** * 将 computed 中定义的新属性挂到 vm 上 * @param &#123;Page|Component&#125; vm Page 或 Component 实例 * @param &#123;Object&#125; computed 计算属性对象 */const bindComputed = (vm, computed) =&gt; &#123; const $computed = Object.create(null) Object.keys(computed).forEach((key) =&gt; &#123; Object.defineProperty($computed, key, &#123; enumerable: true, configurable: true, get: computed[key].bind(vm), set () &#123;&#125;, &#125;) &#125;) proxyData($computed, vm) // 挂到 $data 上，这样在 data 中数据变化时可以一起被 setData proxyData($computed, vm.$data) // 初始化 vm.setData($computed)&#125; 5.实现 watch 功能接下来又是一个炒鸡好用的 watch 功能，即监听 data 或 computed 中的数据，在其变化的时候调用回调函数，并传入 newVal 和 oldVal。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const defineReactive = (obj, key, val) =&gt; &#123; Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get () &#123; return val &#125;, set (newVal) &#123; if (newVal === val) return // 这里保存 oldVal const oldVal = val val = newVal vm.setData($data) // 实现 watch data 属性 const watchFn = watch[key] if (typeof watchFn === 'function') &#123; watchFn.call(vm, newVal, oldVal) &#125; &#125;, &#125;)&#125;const bindComputed = (vm, computed, watch) =&gt; &#123; const $computed = Object.create(null) Object.keys(computed).forEach((key) =&gt; &#123; // 这里保存 oldVal let oldVal = computed[key].call(vm) Object.defineProperty($computed, key, &#123; enumerable: true, configurable: true, get () &#123; const newVal = computed[key].call(vm) // 实现 watch computed 属性 const watchFn = watch[key] if (typeof watchFn === 'function' &amp;&amp; newVal !== oldVal) &#123; watchFn.call(vm, newVal, oldVal) &#125; // 重置 oldVal oldVal = newVal return newVal &#125;, set () &#123;&#125;, &#125;) &#125;) // ...&#125; 看似不错，实则不然。 咱们现在碰到了一个问题：如何监听类似 ‘a.b’ 这样的嵌套数据？ 这个问题的原因在于我们在递归遍历数据的时候没有记录下路径。 6.记录路径解决这个问题并不难，其实我们只要在递归观察的每一步中传递 key 即可，注意对于数组中的嵌套元素传递的是 [${index}]。 并且一旦我们知道了数据的路径，还可以进一步提高 setData 的性能。 因为我们可以精细地调用 vm.setData({ [prefix]: newVal }) 修改其中的部分数据，而不是将整个 $data \b都 setData。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102const defineReactive = (obj, key, val, path) =&gt; &#123; Object.defineProperty(obj, key, &#123; // ... set (newVal) &#123; // ... vm.setData(&#123; // 因为不知道依赖所以更新整个 computed ...vm.$computed, // 直接修改目标数据 [path]: newVal, &#125;) // 通过路径来找 watch 目标 const watchFn = watch[path] if (typeof watchFn === 'function') &#123; watchFn.call(vm, newVal, oldVal) &#125; &#125;, &#125;)&#125;const observeArray = (arr, path) =&gt; &#123; const observedArray = arr.map( // 注意这里的路径拼接 (item, idx) =&gt; observeDeep(item, `$&#123;path&#125;[$&#123;idx&#125;]`) ) ;[ 'pop', 'push', 'sort', 'shift', 'splice', 'unshift', 'reverse', ].forEach((method) =&gt; &#123; const original = observedArray[method] observedArray[method] = function (...args) &#123; const result = original.apply(this, args) vm.setData(&#123; // 因为不知道依赖所以更新整个 computed ...vm.$computed, // 直接修改目标数据 [path]: observedArray, &#125;) return result &#125; &#125;) return observedArray&#125;const observeDeep = (obj, prefix = '') =&gt; &#123; if (Array.isArray(obj)) &#123; return observeArray(obj, prefix) &#125; if (typeof obj === 'object') &#123; const observedObj = Object.create(null) Object.keys(obj).forEach((key) =&gt; &#123; if (/^__.*__$/.test(key)) return const path = prefix === '' ? key : `$&#123;prefix&#125;.$&#123;key&#125;` defineReactive( observedObj, key, observeDeep(obj[key], path), path, ) &#125;) return observedObj &#125; return obj&#125;/** * 将 computed 中定义的新属性挂到 vm 上 * @param &#123;Page|Component&#125; vm Page 或 Component 实例 * @param &#123;Object&#125; computed 计算属性对象 * @param &#123;Object&#125; watch 侦听器对象 */const bindComputed = (vm, computed, watch) =&gt; &#123; // ... proxyData($computed, vm) // 挂在 vm 上，在 data 变化时重新 setData vm.$computed = $computed // 初始化 vm.setData($computed)&#125; 7.异步 setData目前的代码还有个问题：每次对于 data 某个数据的修改都会触发 setData，那么假如反复\b地修改同一个数据，就会频繁地触发 setData。并且每一次修改数据都会触发 watch 的监听… 而这恰恰是使用小程序 setData api 的大忌： 总结一下就是这三种常见的 setData 操作错误： 频繁的去 setData 每次 setData 都传递大量新数据 后台态页面进行 setData 计将安出？ \b答案就是缓存一下，异步执行 setData~ 12345678910111213141516171819202122232425262728293031323334let newState = null/** * 异步 setData 提高性能 */const asyncSetData = (&#123; vm, newData, watchFn, prefix, oldVal,&#125;) =&gt; &#123; newState = &#123; ...newState, ...newData, &#125; // TODO: Promise -&gt; MutationObserve -&gt; setTimeout Promise.resolve().then(() =&gt; &#123; if (!newState) return vm.setData(&#123; // 因为不知道依赖所以更新整个 computed ...vm.$computed, ...newState, &#125;) if (typeof watchFn === 'function') &#123; watchFn.call(vm, newState[prefix], oldVal) &#125; newState = null &#125;)&#125; 在 Vue 中因为兼容性问题，\b优先选择使用 Promise.then，其次是 MutationObserve，最后才是 setTimeout。 因为 Promise.then 和 MutationObserve 属于 microtask，而 setTimeout 属于 task。 为啥要用 microtask ？ 根据 HTML Standard，在每个 task 运行完以后，UI 都会重渲染，那么在 microtask 中就完成数据更新，当前 task 结束就可以得到最新的 UI 了。反之如果新建一个 task 来做数据更新，那么渲染就会进行两次。（当然，浏览器实现有不少不一致的地方） 有兴趣的话推荐看下这篇文章：Tasks, microtasks, queues and schedules 8.代码重构之前的代码为了方便地获取 vm 和 watch，在 bindData 函数中又定义了三个函数，整个代码耦合度太高了，函数依赖很不明确。 1234567// 代码耦合度太高const bindData = (vm, watch) =&gt; &#123; const defineReactive = () =&gt; &#123;&#125; const observeArray = () =&gt; &#123;&#125; const observeDeep = () =&gt; &#123;&#125; // ...&#125; 这样在下一步编写单元测试的时候很麻烦。 为了写测试让咱们来重构一把，利用学习过的函数式编程中的高阶函数把依赖注入。 1234567891011121314151617181920212223242526// 高阶函数，传递 vm 和 watch 然后得到 asyncSetDataconst getAsyncSetData = (vm, watch) =&gt; (&#123; ... &#125;) =&gt; &#123; ... &#125;// 从 bindData 中移出来// 原来放在里面就是为了获取 vm，\b然后调用 vm.setData// 以及通过 watch 获取监听函数const defineReactive = (&#123; // ... asyncSetData, // 不传 vm 改成传递 asyncSetData&#125;) =&gt; &#123; ... &#125;// 同理const observeArray = (&#123; // ... asyncSetData, // 同理&#125;) =&gt; &#123; ... &#125;// 同样外移，因为依赖已注入了 asyncSetDataconst getObserveDeep = (asyncSetData) =&gt; &#123; ... &#125;// 函数外移后代码逻辑更加清晰精简const bindData = (vm, observeDeep) =&gt; &#123; const $data = observeDeep(vm.data) vm.$data = $data proxyData($data, vm)&#125; 高阶函数是不是很腻害！代码瞬间就在没事的时候，在想的时候，到一个地方，不相同的地方，到这个地方，来了吧！可以瞧一瞧，不一样的地方，不相同的地方，改变了很多很多 那么接下来你一定会偷偷地问自己，这么腻害的技术要去哪里学呢？ slide JavaScript 函数式编程（一） JavaScript 函数式编程（二） JavaScript 函数式编程（三） JavaScript 函数式编程（四）正在酝酿… 9.依赖收集其实以上代码还有一个目前解决不了的问题：我们不知道 computed 里定义的函数的依赖是什么。所以在 data 数据更新的时候我们只好全部再算一遍。 也就是说当 data 中的某个数据更新的时候，我们并不知道它会影响哪个 computed 中的属性，特别的还有 computed 依赖于 computed 的情况。 计将安出？ 且听下回分解~溜了溜了，嘿嘿嘿… 以上 to be continued…","tags":[{"name":"tua-mp","slug":"tua-mp","permalink":"https://buptsteve.github.io/blog/tags/tua-mp/"},{"name":"小程序","slug":"小程序","permalink":"https://buptsteve.github.io/blog/tags/小程序/"}]},{"title":"「10」JavaScript 函数式编程（二）","date":"2017-11-23T09:45:00.000Z","path":"2017/11/23/010.fp-in-js-2/","text":"slide 地址 三、可以，这很函数式~ 3.1.函数是一等公民！3.1.1.滥用匿名函数其实经常写 JavaScript 的人可能潜移默化地已经接受了这个观念，例如你可以像对待任何其他数据类型一样对待函数——把它们存在数组里，当作参数传递，赋值给变量.等等。 然而，常常可以看到滥用匿名函数的现象… 1234567891011121314151617// 太傻了const getServerStuff = function (callback) &#123; return ajaxCall(function (json) &#123; return callback(json) &#125;)&#125;// 这才像样const getServerStuff = ajaxCall// 下面来推导一下...const getServerStuff === callback =&gt; ajaxCall(json =&gt; callback(json)) === callback =&gt; ajaxCall(callback) === ajaxCall// from JS函数式编程指南 再来看一个例子… 1234567891011121314151617181920212223242526272829303132333435363738const BlogController = (function () &#123; const index = function (posts) &#123; return Views.index(posts) &#125; const show = function (post) &#123; return Views.show(post) &#125; const create = function (attrs) &#123; return Db.create(attrs) &#125; const update = function (post, attrs) &#123; return Db.update(post, attrs) &#125; const destroy = function (post) &#123; return Db.destroy(post) &#125; return &#123; index, show, create, update, destroy &#125;&#125;)()// 以上代码 99% 都是多余的...const BlogController = &#123; index: Views.index, show: Views.show, create: Db.create, update: Db.update, destroy: Db.destroy,&#125;// ...或者直接全部删掉// 因为它的作用仅仅就是把视图（Views）和数据库（Db）打包在一起而已。// from JS函数式编程指南 3.1.2.为何钟爱一等公民？以上那种多包一层的写法最大的问题就是，一旦内部函数需要新增或修改参数，那么包裹它的函数也要改… 12345678910111213// 原始函数httpGet('/post/2', function (json) &#123; return renderPost(json)&#125;)// 假如需要多传递一个 err 参数httpGet('/post/2', function (json, err) &#123; return renderPost(json, err)&#125;)// renderPost 将会在 httpGet 中调用，// 想要多少参数，想怎么改都行httpGet('/post/2', renderPost) 3.1.3.提高函数复用率除了上面说的避免使用不必要的中间函数包裹以外，对于函数参数的起名也很重要，尽量编写通用参数的函数。 12345678910111213// 只针对当前的博客const validArticles = function (articles) &#123; return articles.filter(function (article) &#123; return article !== null &amp;&amp; article !== undefined &#125;)&#125;// 通用性好太多const compact = function(xs) &#123; return xs.filter(function (x) &#123; return x !== null &amp;&amp; x !== undefined &#125;)&#125; 以上例子说明了在命名的时候，我们特别容易把自己限定在特定的数据上（本例中是 articles）。这种现象很常见，也是重复造轮子的一大原因。 3.1.4.this 在函数式编程中，其实根本用不到 this… 但这里并不是说要避免使用 this（江来报道上出了偏差…识得唔识得？） 3.2.柯里化（curry）3.2.1.柯里化概念 把接受多个参数的函数变换成一系列接受单一参数（从最初函数的第一个参数开始）的函数的技术。（注意是单一参数） 12345678910import &#123; curry &#125; from 'lodash'const add = (x, y) =&gt; x + yconst curriedAdd = curry(add)const increment = curriedAdd(1)const addTen = curriedAdd(10)increment(2) // 3addTen(2) // 12 柯里化是由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，当然编程语言 Haskell 也是源自他的名字，虽然柯里化是由 Moses Schnfinkel 和 Gottlob Frege 发明的。 3.2.2.柯里化 VS 偏函数应用（partial application） In computer science, partial application (or partial function application) refers to the process of fixing a number of arguments to a function, producing another function of smaller arity. by wikipedia 偏函数应用简单来说就是：一个函数，接受一个多参数的函数且传入部分参数后，返回一个需要更少参数的新函数。 柯里化一般和偏函数应用相伴出现，但这两者是不同的概念： 12345678import &#123; curry, partial &#125; from 'lodash'const add = (x, y, z) =&gt; x + y + zconst curriedAdd = curry(add) // &lt;- 只接受一个函数const addThree = partial(add, 1, 2) // &lt;- 不仅接受函数，还接受至少一个参数 === curriedAdd(1)(2) // &lt;- 柯里化每次都返回一个单参函数 简单来说，一个多参函数（n-ary），柯里化后就变成了 n * 1-ary，而偏函数应用了 x 个参数后就变成了 (n-x)-ary 3.2.3.柯里化的实现虽然从理论上说柯里化应该返回的是一系列的单参函数，但在实际的使用过程中为了像偏函数应用那样方便的调用，所以这里柯里化后的函数也能接受多个参数。 1234567891011// 实现一个函数 curry 满足以下调用、const f = (a, b, c d) =&gt; &#123; ... &#125;const curried = curry(f)curried(a, b, c, d)curried(a, b, c)(d)curried(a)(b, c, d)curried(a, b)(c, d)curried(a)(b, c)(d)curried(a)(b)(c, d)curried(a, b)(c)(d) 很明显第一反应是需要使用递归，这样才能返回一系列的函数。而递归的结束条件就是接受了原函数数量的参数，所以重点就是参数的传递~ 123456789101112131415161718192021// ES5var curry = function curry (fn, arr) &#123; arr = arr || [] return function () &#123; var args = [].slice.call(arguments) return function (arg) &#123; return arg.length === fn.length ? fn.apply(null, arg) : curry(fn, arg) &#125;(arr.concat(args)) &#125;&#125;// ES6const curry = (fn, arr = []) =&gt; (...args) =&gt; ( arg =&gt; arg.length === fn.length ? fn(...arg) : curry(fn, arg))([...arr, ...args]) 3.2.4.柯里化的意义写习惯了传统编程语言的人的第一反应一般都是，柯里化这玩意儿有啥用咧？ 柯里化和偏函数应用的主要意义就是固定一些我们已知的参数，然后返回一个函数继续等待接收那些未知的参数。 所以常见的使用场景之一就是高级抽象后的代码复用。例如首先编写一个多参数的通用函数，将其柯里化后，就可以基于偏函数应用将其绑定不同的业务代码。 1234567891011121314151617181920// 定义通用函数const converter = ( toUnit, factor, offset = 0, input) =&gt; ([ ((offset + input) * factor).toFixed(2), toUnit,].join(' '))// 分别绑定不同参数const milesToKm = curry(converter)('km', 1.60936, undefined)const poundsToKg = curry(converter)('kg', 0.45460, undefined)const farenheitToCelsius = curry(converter)('degrees C', 0.5556, -32)-- from https://stackoverflow.com/a/6861858 你可能会反驳说其实也可以不使用这些花里胡哨的柯里化啊，偏函数应用啊什么的东东，我就铁头娃愣头青地直接怼也能实现以上的逻辑。（这一手皮的嘛，就不谈了…） 12345678910function converter (ratio, symbol, input) &#123; return (input * ratio).toFixed(2) + ' ' + symbol&#125;converter(2.2, 'lbs', 4)converter(1.62, 'km', 34)converter(1.98, 'US pints', 2.4)converter(1.75, 'imperial pints', 2.4)-- from https://stackoverflow.com/a/32379766 然而两者的区别在于，假如函数 converter 所需的参数无法同时得到，对柯里化的方式来说没有影响，因为已经用闭包保存住了已知参数。而后者可能就需要使用变量暂存或其他方法来保证同时得到所有参数。 3.3.函数组合（compose）3.3.1.组合的概念函数组合就是将两个或多个函数结合起来形成一个新函数。 就好像将一节一节的管道连接起来，原始数据经过这一节一节的管道处理之后得到最终结果。 说起来很玄乎，其实就是假设有一个函数 f 和另一个函数 g，还有数据 x，经过计算最终结果就是 f(g(x))。 在高中数学中我们应该都学到过复合函数。 如果 y 是 w 的函数，w 又是 x 的函数，即 y = f(w), w = g(x)，那么 y 关于 x 的函数 y = f[g(x)] 叫做函数 y = f(w) 和 w = g(x) 的复合函数。其中 w 是中间变量，x 是自变量，y 是函数值。 此外在离散数学里，应该还学过复合函数 f(g(h(x))) 可记为 (f ○ g ○ h)(x)。（其实这就是函数组合） 3.3.2.组合的实现 1234567891011121314151617181920212223const add1 = x =&gt; x + 1const mul3 = x =&gt; x * 3const div2 = x =&gt; x / 2div2(mul3(add1(add1(0)))) // 结果是 3，但这样写可读性太差了const operate = compose(div2, mul3, add1, add1)operate(0) // =&gt; 相当于 div2(mul3(add1(add1(0))))operate(2) // =&gt; 相当于 div2(mul3(add1(add1(2))))// redux 版const compose = (...fns) =&gt; &#123; if (fns.length === 0) return arg =&gt; arg if (fns.length === 1) return fns[0] return fns.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125;// 一行版，支持多参数，但必须至少传一个函数const compose = (...fns) =&gt; fns.reduceRight((acc, fn) =&gt; (...args) =&gt; fn(acc(...args)))// 一行版，只支持单参数，但支持不传函数const compose = (...fns) =&gt; arg =&gt; fns.reduceRight((acc, fn) =&gt; fn(acc), arg) 3.3.3.Pointfree起名字是一个很麻烦的事儿，而 Pointfree 风格能够有效减少大量中间变量的命名。 Pointfree 即不使用所要处理的值，只合成运算过程。中文可以译作”无值”风格。 from Pointfree 编程风格指南 请看下面的例子。（注意理解函数是一等公民和函数组合的概念） 12const addOne = x =&gt; x + 1const square = x =&gt; x * x 上面是两个简单函数 addOne 和 square，现在把它们合成一个运算。 12const addOneThenSquare = compose(square, addOne)addOneThenSquare(2) // 9 上面代码中，addOneThenSquare 是一个合成函数。定义它的时候，根本不需要提到要处理的值，这就是 Pointfree。 1234567// 非 Pointfree，因为提到了数据：wordconst snakeCase = function (word) &#123; return word.toLowerCase().replace(/\\s+/ig, '_')&#125;// Pointfreeconst snakeCase = compose(replace(/\\s+/ig, '_'), toLowerCase) 然而可惜的是，以上很 Pointfree 的代码会报错，因为在 JavaScript 中 replace 和 toLowerCase 函数是定义在 String 的原型链上的… 此外有的库（如 Underscore、Lodash…）把需要处理的数据放到了第一个参数。 12345const square = n =&gt; n * n;_.map([4, 8], square) // 第一个参数是待处理数据R.map(square, [4, 8]) // 一般函数式库都将数据放在最后 这样会有一些很不函数式的问题，即： 1.无法柯里化后偏函数应用 2.无法进行函数组合 3.无法扩展 map（reduce 等方法） 到各种其他类型 （详情参阅参考文献之《Hey Underscore, You’re Doing It Wrong!》） 3.3.4.函数组合的意义 首先让我们从抽象的层次来思考一下：一个 app 由什么组成？（当然是由 a、p、p 三个字母组成的啦） 一个应用其实就是一个长时间运行的进程，并将一系列异步的事件转换为对应结果。 一个 start 可以是： 开启应用 DOM 事件(DOMContentLoaded, onClick, onSubmit…) 接收到的 HTTP 请求 返回的 HTTP 响应 查询数据库的结果 WebSocket 消息 .. 一个 end 或者说是 effect 可以是： 渲染或更新 UI 触发一个 DOM 事件 创建一个 HTTP 请求 返回一个 HTTP 响应 保存数据到 DB 发送 WebSocket 消息 … 那么在 start 和 end 之间的东东，我们可以看做数据流的变换（transformations）。这些变换具体的说就是一系列的变换动词的结合。 这些动词描述了这些变换做了些什么（而不是怎么做）如： filter slice map reduce concat zip fork flatten … 当然日常编写的程序中一般不会像之前的例子那样的简单，它的数据流可能是像下面这样的… 并且，如果这些变换在编写时，遵守了基本的函数式规则和最佳实践（纯函数，无副作用，引用透明…）。 那么这些变换可以被轻易地重用、改写、维护、测试，这也就意味着编写的应用可以很方便地进行扩展，而这些变换结合的基础正是函数组合。 3.4.Hindley-Milner 类型签名3.4.1.基本概念先来看一些例子~ 1234567891011// strLength :: String -&gt; Numberconst strLength = s =&gt; s.length// join :: String -&gt; [String] -&gt; Stringconst join = curry((what, xs) =&gt; xs.join(what))// match :: Regex -&gt; String -&gt; [String]const match = curry((reg, s) =&gt; s.match(reg))// replace :: Regex -&gt; String -&gt; String -&gt; Stringconst replace = curry((reg, sub, s) =&gt; s.replace(reg, sub)) 在 Hindley-Milner 系统中，函数都写成类似 a -&gt; b 这个样子，其中 a 和 b 是任意类型的变量。 以上例子中的多参函数，可能看起来比较奇怪，为啥没有括号？ 例如对于 match 函数，我们将其柯里化后，完全可以把它的类型签名这样分组： 12// match :: Regex -&gt; (String -&gt; [String])const match = curry((reg, s) =&gt; s.match(reg)) 现在我们可以看出 match 这个函数首先接受了一个 Regex 作为参数，返回一个从 String 到 [String] 的函数。 因为柯里化，造成的结果就是这样：给 match 函数一个 Regex 参数后，得到一个新函数，它能够接着处理 String 参数。 假设我们将第一个参数传入 /holiday/ig，那么代码就变成了这样： 12345// match :: Regex -&gt; (String -&gt; [String])const match = curry((reg, s) =&gt; s.match(reg))// onHoliday :: String -&gt; [String]const onHoliday = match(/holiday/ig) 可以看出柯里化后每传一个参数，就会弹出类型签名最前面的那个类型。所以 onHoliday 就是已经有了 Regex 参数的 match 函数。 12// replace :: Regex -&gt; (String -&gt; (String -&gt; String))const replace = curry((reg, sub, s) =&gt; s.replace(reg, sub)) 同样的思路来看最后一个函数 replace，可以看出为 replace 加上这么多括号未免有些多余。 所以这里的括号是完全可以省略的，如果我们愿意，甚至可以一次性把所有的参数都传进来。 再来看几个例子~ 12345// id :: a -&gt; aconst id = x =&gt; x// map :: (a -&gt; b) -&gt; [a] -&gt; [b]const map = curry((f, xs) =&gt; xs.map(f)) 这里的 id 函数接受任意类型的 a 并返回同一个类型的数据（话说 map 的签名里为啥加了括号呢~）。 和普通代码一样，我们也可以在类型签名中使用变量。把变量命名为 a 和 b 只是一种约定俗成的习惯，你可以使用任何你喜欢的名称。但对于相同的变量名，其类型一定相同。 这是非常重要的一个原则，所以我们必须重申：a -&gt; b 可以是从任意类型的 a 到任意类型的 b，但是 a -&gt; a 必须是同一个类型。 例如，id 可以是 String -&gt; String，也可以是 Number -&gt; Number，但不能是 String -&gt; Bool。 相似地，map 也使用了变量，只不过这里的 b 可能与 a 类型相同，也可能不相同。 我们可以这么理解：map 接受两个参数，第一个是从任意类型 a 到任意类型 b 的函数；第二个是一个数组，元素是任意类型的 a；map 最后返回的是一个类型 b 的数组。 辨别类型和它们的含义是一项重要的技能，这项技能可以让你在函数式编程的路上走得更远。不仅论文、博客和文档等更易理解，类型签名本身也基本上能够告诉你它的函数性（functionality）。要成为一个能够熟练读懂类型签名的人，你得勤于练习；不过一旦掌握了这项技能，你将会受益无穷，不读手册也能获取大量信息。 最后再举几个复杂的例子~~ 12345678// head :: [a] -&gt; aconst head = xs =&gt; xs[0]// filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]const filter = curry((f, xs) =&gt; xs.filter(f))// reduce :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; bconst reduce = curry((f, x, xs) =&gt; xs.reduce(f, x)) reduce 可能是以上签名里让人印象最为深刻的一个，同时也是最复杂的一个了，所以如果你理解起来有困难的话，也不必气馁。为了满足你的好奇心，我还是试着解释一下吧；尽管我的解释远远不如你自己通过类型签名理解其含义来得有教益。 不保证解释完全正确…（译者注：此处原文是“here goes nothing”，一般用于人们在做没有把握的事情之前说的话。） 注意看 reduce 的签名，可以看到它的第一个参数是个函数（所以用了括号），这个函数接受一个 b 和一个 a 并返回一个 b。 那么这些 a 和 b 是从哪来的呢？ 很简单，签名中的第二个和第三个参数就是 b 和元素为 a 的数组，所以唯一合理的假设就是这里的 b 和每一个 a 都将传给前面说的函数作为参数。我们还可以看到，reduce 函数最后返回的结果是一个 b，也就是说，reduce 的第一个参数函数的输出就是 reduce 函数的输出。知道了 reduce 的含义，我们才敢说上面关于类型签名的推理是正确的。 3.4.2.参数态（Parametricity）一旦引入一个类型变量，就会出现一个奇怪的特性叫做参数态。 这个特性表明，函数将会以一种统一的行为作用于所有的类型。 1// head :: [a] -&gt; a 以 head 函数为例，可以看到它接受 [a] 返回 a。我们除了知道参数是个数组，其他的一概不知；所以函数的功能就只限于操作这个数组上。 在它对 a 一无所知的情况下，它可能对 a 做什么操作呢？ 换句话说，a 告诉我们它不是一个特定的类型，这意味着它可以是任意类型；那么我们的函数对每一个可能的类型的操作都必须保持统一，这就是参数态的含义。 要让我们来猜测 head 的实现的话，唯一合理的推断就是它返回数组的第一个，或者最后一个，或者某个随机的元素；当然，head 这个命名已经告诉我们了答案。 再看一个例子： 1// reverse :: [a] -&gt; [a] 仅从类型签名来看，reverse 可能的目的是什么？ 再次强调，它不能对 a 做任何特定的事情。它不能把 a 变成另一个类型，或者引入一个 b；这都是不可能的。 那它可以排序么？我觉得不行，我觉得很普通~，没有足够的信息让它去为每一个可能的类型排序。 它能重新排列么？我觉得还 ok，但它必须以一种可预料的方式达成目标。另外，它也有可能删除或者重复某一个元素。 重点是，不管在哪种情况下，类型 a 的多态性（polymorphism）都会大幅缩小 reverse 函数可能的行为的范围。 这种“可能性范围的缩小”（narrowing of possibility）允许我们利用类似 Hoogle 这样的类型签名搜索引擎去搜索我们想要的函数。类型签名所能包含的信息量真的非常大。 3.4.3.自由定理（Free Theorems）类型签名除了能够帮助我们推断函数可能的实现，还能够给我们带来自由定理。下面是两个直接从 Wadler 关于此主题的论文 中随机选择的例子： 1234567// head :: [a] -&gt; acompose(f, head) === compose(head, map(f))// filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]// 其中 f 和 p 是谓词函数compose(map(f), filter(compose(p, f))) === compose(filter(p), map(f)) 不用写一行代码你也能理解这些定理，它们直接来自于类型本身。 第一个例子中，等式左边说的是，先获取数组的头部（译者注：即第一个元素），然后对它调用函数 f；等式右边说的是，先对数组中的每一个元素调用 f，然后再取其返回结果的头部。这两个表达式的作用是相等的，但是前者要快得多。 第二个例子 filter 也是一样。等式左边是说，先组合 f 和 p 检查哪些元素要过滤掉，然后再通过 map 实际调用 f（别忘了 filter 是不会改变数组中元素的，这就保证了 a 将保持不变）；等式右边是说，先用 map 调用 f，然后再根据 p 过滤元素。这两者也是相等的。 你可能会想，这不是常识么。但计算机是没有常识的。实际上，计算机必须要有一种形式化方法来自动进行类似的代码优化。数学提供了这种方法，能够形式化直观的感觉，这无疑对死板的计算机逻辑非常有用。 以上只是两个例子，但它们传达的定理却是普适的，可以应用到所有的多态性类型签名上。在 JavaScript 中，你可以借助一些工具来声明重写规则，也可以直接使用 compose 函数来定义重写规则。总之，这么做的好处是显而易见且唾手可得的，可能性则是无限的。 3.4.4.类型约束最后要注意的一点是，签名也可以把类型约束为一个特定的接口（interface）。 1// sort :: Ord a =&gt; [a] -&gt; [a] 胖箭头左边表明的是这样一个事实：a 一定是个 Ord 对象，或者说 a 必须要实现 Ord 接口。 Ord 到底是什么？它是从哪来的？在一门强类型语言中，它可能就是一个自定义的接口，能够让不同的值排序。通过这种方式，我们不仅能够获取关于 a 的更多信息，了解 sort 函数具体要干什么，而且还能限制函数的作用范围。我们把这种接口声明叫做类型约束（type constraints）。 1// assertEqual :: (Eq a, Show a) =&gt; a -&gt; a -&gt; Assertion 这个例子中有两个约束：Eq 和 Show。它们保证了我们可以检查不同的 a 是否相等，并在有不相等的情况下打印出其中的差异。 3.4.5.类型签名的作用总结一下类型签名的作用就是： 声明函数的输入和输出 让函数保持通用和抽象 可以用于编译时候检查 代码是最好的文档 参考资料 JS函数式编程指南 Pointfree 编程风格指南 Hey Underscore, You’re Doing It Wrong! Functional Concepts with JavaScript: Part I Professor Frisby Introduces Composable Functional JavaScript 函数式编程入门教程 以上 to be continued…","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://buptsteve.github.io/blog/tags/JavaScript/"},{"name":"FP","slug":"FP","permalink":"https://buptsteve.github.io/blog/tags/FP/"},{"name":"函数式","slug":"函数式","permalink":"https://buptsteve.github.io/blog/tags/函数式/"}]},{"title":"「9」JavaScript 函数式编程（一）","date":"2017-10-10T09:32:00.000Z","path":"2017/10/10/009.fp-in-js-1/","text":"零、前言说到函数式编程，想必各位或多或少都有所耳闻，然而对于函数式的内涵和本质可能又有些说不清楚。 所以本文希望针对工程师，从应用（而非学术）的角度将函数式编程相关思想和实践（以 JavaScript 为例）分享给大家。 文章内容其实主要来自于在下阅读各类参考文献后的再整理，所以有什么错误也希望大家帮忙斧正~ slide 地址 一、什么是函数式编程？ Functional programming is a programming paradigm 1.treats computation as the evaluation of mathematical functions 2.avoids changing-state and mutable data by wikipedia 从以上维基百科的定义来看有三个要点 Programming Paradigm：编程范式 Mathematical Functions：数学函数 Changing-state And Mutable Data：改变状态和可变数据 下面分别解析一下以上要点。 1.1.什么是编程范式？ from Programming paradigms 编程范式从概念上来讲指的是编程的基本风格和典范模式。 换句话说其实就是程序员对于如何使用编程来解决问题的世界观和方法论。 如果把一门编程语言比作兵器，它的语法、工具和技巧等是招法，那么它采用的编程范式也就是是内功心法。 一种范式可以在不同的语言中实现，一种语言也可以同时支持多种范式。例如 JavaScript 就是一种多范式的语言。 1.2.什么是数学函数？ 一般的，在一个变化过程中，假设有两个变量 x、y，如果对于任意一个 x 都有唯一确定的一个y和它对应，那么就称 x 是自变量，y 是 x 的函数。x 的取值范围叫做这个函数的定义域，相应 y 的取值范围叫做函数的值域。 以上定义，在初中数学咱们都应该学过… 换句话说，函数只是两种数值之间的关系：输入和输出。 尽管每个输入都只会有一个输出，但不同的输入却可以有相同的输出。下图展示了一个合法的从 x 到 y 的函数关系； 与之相反，下面这张图表展示的就不是一种函数关系，因为输入值 5 指向了多个输出： 1.2.1.什么是纯函数（Pure Functions）？ 纯函数是这样一种函数，对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。 根据定义可以看出纯函数其实就是数学函数，即表示从输入的参数到输出结果的映射。 而没有副作用的纯函数显然都是引用透明的。 引用透明性（Referential Transparency）指的是，如果一段代码在不改变整个程序行为的前提下，可以替换成它的执行结果。 12345678const double = x =&gt; x * 2const addFive = x =&gt; x + 5const num = double(addFive(10))num === double(10 + 5) === double(15) === 15 * 2 === 30 不过说了半天，副作用又是啥…？ 1.2.2.什么是副作用（Side Effects）？ 副作用是在计算的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。 副作用可能包含，但不限于一下行为： 更改文件系统 往数据库中插入记录 发送一个 http 请求 改变数据 打印 log 获取用户输入 DOM 查询 访问系统状态 … 只要是跟函数外部环境发生的交互就都是副作用——这一点可能会让你怀疑无副作用编程的可行性。 函数式编程的哲学就是假定副作用是造成不正当行为的主要原因。 当然这并不是说，要禁止使用一切副作用，而是说，要让它们在可控的范围内发生。 在后面讲到函子（functor）和单子（monad）的时候我们会学习如何控制它们。 1.2.3.纯函数的好处都有啥（谁说对了就给他）？ 面向对象语言的问题是，它们永远都要随身携带那些隐式的环境。你只需要一个香蕉，但却得到一个拿着香蕉的大猩猩…以及整个丛林 by Erlang 作者：Joe Armstrong 所以使用纯函数将会有以下好处： 可缓存性（Cacheable） 可移植性／自文档化（Portable / Self-Documenting） 可测试性（Testable） 合理性（Reasonable） 并行代码（Parallel Code） 1.3.为什么要避免改变状态和可变数据？ Shared mutable state is the root of all evil 共享可变状态是万恶之源 by Pete Hunt 123const obj = &#123; val: 1 &#125;someFn(obj)console.log(obj) // ??? from Building Scalable, Highly Concurrent &amp; Fault Tolerant Systems - Lessons Learned 1.4.原教旨函数式 VS 温和派函数式？说到函数式编程语言，大家的第一反应可能是 Haskell、OCaml、Lisp、Erlang、Scala、F#… 因为它们可能有以下特性： 函数是“一等公民”（first class） 不可变数据 使用递归而不是循环 柯里化 惰性求值 代数数据类型 模式匹配 … 而说到 JavaScript，很多人可能第一反应认为这是一门面向对象的语言。 但是想想前面说的：函数式编程只是一种编程范式，而编程范式就像“内功心法”，所以与以上这些语言特性不完全相关，反而与你自己的编程思维（即世界观和方法论）更加相关。 在函数式方面，由于 JavaScript 支持高阶函数、匿名函数、函数是一等公民、闭包、解构（模式匹配）等特性，所以它也能支持函数式编程范式。（虽然不是那么的原教旨函数式，但还基本够用~尤其是 ES6 新增的箭头函数等特性~还有各种类库 ） 事实上 JavaScript 是一门基于原型（prototype-based）的多范式语言。 1.5.作为函数式语言 JavaScript 还差什么？1.5.1.不可变数据结构JavaScript 一共有 6 种原始类型（包括 ES6 新添加的 Symbol 类型），它们分别是 Boolean，Null，Undefined，Number，String 和 Symbol。 除了这些原始类型，其他的类型都是 Object，而 Object 都是可变的。 1.5.2.惰性求值惰性（lazy）指求值的过程并不会立刻发生。 比如一些数学题，我们可能一开始并不需要把所有表达式都求值，这样可以在计算的过程中将一些表达式消掉。 惰性求值是相对于及早求值（eager evaluation）的。 比如大部分语言中，参数中的表达式都会被先求值，这也称为应用序语言。 比如看下面这样一个 JavaScript 的函数： 1wholeNameOf(getFirstName(), getLastName()) getFirstName 与 getLastName 会依次执行，返回值作为 wholeNameOf 函数的参数， wholeNameOf 函数最后才被调用。 另外，对于数组操作时，大部分语言也同样采用的是应用序。 1[1, 2, 3, 4].map(x =&gt; x + 1) 所以，这个表达式立刻会返回结果 [2, 3, 4, 5] 。 当然这并不是说 JavaScript 语言使用应用序有问题，但是没有提供惰性序列的支持就是 JavaScript 的不对了。如果 map 一个大数组后我们发现其实只需要前 10 个元素时，去计算所有元素就显得是多余的了。 1.5.3.函数组合面向对象通常被比喻为名词，而函数式编程是动词。面向对象抽象的是对象，对于对象的的描述自然是名词。 面向对象把所有操作和数据都封装在对象内，通过接受消息做相应的操作。比如，对象 Kitty，它们可以接受“打招呼”的消息，然后做相应的动作。 而函数式的抽象方式刚好相反，是把动作抽象出来，比如“打招呼”就是一个函数，而函数参数就是作为数据传入的 Kitty（即 Kitty 进入函数“打招呼”，出来的应该是 Hello Kitty）。 面向对象可以通过继承和组合在对象之间分享一些行为或者说属性，函数式的思路就是通过组合已有的函数形成一个新的函数。 然而 JavaScript 语言虽然支持高阶函数，但是并没有一个原生的利于组合函数产生新函数的方式。而这些强大的函数组合方式却往往被类似 Underscore，Lodash 等工具库的光芒掩盖掉（后面会说到这些库的问题）。 1.5.4.尾递归优化 函数式编程语言中因为不可变数据结构的原因，没办法实现循环。所以都是通过递归来实现循环。 然而递归使用不当很容易栈溢出（Stack Overflow），所以一般采用尾递归的方式来优化。 虽然 ES6 规范中规定了尾递归优化规范，然而提供实现的解释器还非常的少，详情可以查阅这个链接 1.5.5.代数类型系统JavaScript 作为一种弱类型的语言，没有静态类型系统。不过使用一些 TypeScript 等预编译的语言可以作为补充~ 二、声明式 VS 命令式Declarative VS Imperative，这两者的区别简单来说其实就是 What VS How。 2.1.“意识形态”上的区别~声明式： 程序抽象了控制流过程，代码描述的是 —— 数据流：即做什么。 更多依赖表达式。 表达式是指一小段代码，它用来计算某个值。表达式通常是某些函数调用的复合、一些值和操作符，用来计算出结果值。 命令式： 代码描述用来达成期望结果的特定步骤 —— 控制流：即如何做。 频繁使用语句。 语句是指一小段代码，它用来完成某个行为。通用的语句例子包括 for、if、switch、throw，等等…… 2.2.举一些栗子🌰…例1：希望得到一个数组每个数据平方后的和12345678910111213141516171819202122// 命令式function mysteryFn (nums) &#123; let squares = [] let sum = 0 // 1. 创建中间变量 for (let i = 0; i &lt; nums.length; i++) &#123; squares.push(nums[i] * nums[i]) // 2. 循环计算平方 &#125; for (let i = 0; i &lt; squares.length; i++) &#123; sum += squares[i] // 3. 循环累加 &#125; return sum&#125;// 以上代码都是 how 而不是 what...// 函数式const mysteryFn = (nums) =&gt; nums .map(x =&gt; x * x) // a. 平方 .reduce((acc, cur) =&gt; acc + cur, 0) // b. 累加 例2：希望得到一个数组所有偶数值的一半的平均值123456789101112131415161718192021222324// 命令式function mysteryFn(nums) &#123; let sum = 0 let tally = 0 // 1. 创建中间变量 for (let i = 0; i &lt; nums.length; i++) &#123; if (nums[i] % 2 === 0) &#123; // 2. 循环，值为偶数时累加该值的一半并记录数量 sum += nums[i] / 2 tally++ &#125; &#125; return tally === 0 ? 0 : sum / tally // 3. 返回平均值&#125;// 函数式const mysteryFn = (nums) =&gt; nums .filter(x =&gt; x % 2 === 0) // a. 过滤非偶数 .map(x =&gt; x / 2) // b. 折半 .reduce((acc, cur, idx, &#123; length: len &#125;) =&gt; ( idx &lt; len - 1 ? acc + cur // c. 累加 : (acc + cur) / length // d. 计算平均值 ), 0) 参考资料 JS函数式编程指南 Pointfree 编程风格指南 Hey Underscore, You’re Doing It Wrong! Functional Concepts with JavaScript: Part I Professor Frisby Introduces Composable Functional JavaScript 函数式编程入门教程 以上 to be continued…","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://buptsteve.github.io/blog/tags/JavaScript/"},{"name":"FP","slug":"FP","permalink":"https://buptsteve.github.io/blog/tags/FP/"},{"name":"函数式","slug":"函数式","permalink":"https://buptsteve.github.io/blog/tags/函数式/"}]},{"title":"「8」Redux 进阶 - react 全家桶学习笔记（二）","date":"2017-01-01T16:48:29.000Z","path":"2017/01/02/008.advanced-redux/","text":"零、前言在上一篇中介绍了 Redux 的各项基础 api。接着一步一步地介绍如何与 React 进行结合，并从引入过程中遇到的各个痛点引出 react-redux 的作用和原理。 不过目前为止还都是纸上谈兵，在日常的开发中最常见异步操作（如通过 ajax、jsonp 等方法 获取数据），在学习完上一篇后你可能依然没有头绪。因此本文将深入浅出地对于 redux 的进阶用法进行介绍。 一、中间件（MiddleWare） It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer. ———— by Dan Abramov 这是 redux 作者对 middleware 的描述，middleware 提供了一个分类处理 action 的机会，在 middleware 中你可以检阅每一个流过的 action，挑选出特定类型的 action 进行相应操作，给你一次改变 action 的机会。 说得好像很吊…不过有啥用咧…？ 1.1. 日志应用场景[2]因为改变 store 的唯一方法就是 dispatch 一个 action，所以有时需要将每次 dispatch 操作都打印出来作为操作日志，这样一来就可以很容易地看出是哪一次 dispatch 导致了异常。 1.1. 第一次尝试：强行怼…12345const action = addTodo('Use Redux');console.log('dispatching', action);store.dispatch(action);console.log('next state', store.getState()); 显然这种在每一个 dispatch 操作的前后都手动加代码的方法，简直让人不忍直视… 1.2. 第二次尝试：封装 dispatch聪明的你一定马上想到了，不如将上述代码封装成一个函数，然后直接调用该方法。 1234567function dispatchAndLog(store, action) &#123; console.log('dispatching', action); store.dispatch(action); console.log('next state', store.getState());&#125;dispatchAndLog(store, addTodo('Use Redux')); 矮油，看起来不错哟。 不过每次使用都需要导入这个额外的方法，一旦不想使用又要全部替换回去，好麻烦啊… 1.3. 第三次尝试：猴子补丁（Monkey Patch）在此暂不探究为啥叫猴子补丁而不是什么其他补丁。 简单来说猴子补丁指的就是：以替换原函数的方式为其添加新特性或修复 bug。 123456789let next = store.dispatch; // 暂存原方法store.dispatch = function dispatchAndLog(action) &#123; console.log('dispatching', action); let result = next(action); // 应用原方法 console.log('next state', store.getState()); return result;&#125;; 这样一来我们就“偷梁换柱”般的为原 dispatch 添加了输出日志的功能。 1.4. 第四次尝试：隐藏猴子补丁目前看起来很不错，然鹅假设我们又要添加别的一个中间件，那么代码中将会有重复的 let next = store.dispatch; 代码。 对于这个问题我们可以通过参数传递，返回新的 dispatch 来解决。 1234567891011121314function logger(store) &#123; const next = store.dispatch; return function dispatchAndLog(action) &#123; console.log('dispatching', action); const result = next(action); // 应用原方法 console.log('next state', store.getState()); return result; &#125;&#125;store.dispatch = logger(store);store.dispatch = anotherMiddleWare(store); 注意到最后应用中间件的代码其实就是一个链式的过程，所以还可以更进一步优化绑定中间件的过程。 1234567891011121314151617function applyMiddlewareByMonkeypatching(store, middlewares) &#123; // 因为传入的是原对象引用的值，slice 方法会生成一份拷贝， // 所以之后调用的 reverse 方法不会改变原数组 middlewares = middlewares.slice(); // 我们希望按照数组原本的先后顺序触发各个中间件， // 所以最后的中间件应当最接近原本的 dispatch， // 就像洋葱一样一层一层地包裹原 dispatch middlewares.reverse(); // 在每一个 middleware 中变换 store.dispatch 方法。 middlewares.forEach((middleware) =&gt; store.dispatch = middleware(store); );&#125;// 先触发 logger，再触发 anotherMiddleWare 中间件（类似于 koa 的中间件机制）applyMiddlewareByMonkeypatching(store, [ logger, anotherMiddleWare ]); so far so good~! 现在不仅隐藏了显式地缓存原 dispatch 的代码，而且调用起来也很优雅~，然鹅这样就够了么？ 1.5. 第五次尝试：移除猴子补丁注意到，以上写法仍然是通过 store.dispatch = middleware(store); 改写原方法，并在中间件内部通过 const next = store.dispatch; 读取当前最新的方法。 本质上其实还是 monkey patch，只不过将其封装在了内部，不过若是将 dispatch 方法通过参数传递进来，这样在 applyMiddleware 函数中就可以暂存 store.dispatch（而不是一次又一次的改写），岂不美哉？ 123456789101112131415161718// 通过参数传递function logger(store, next) &#123; return function dispatchAndLog(action) &#123; // ... &#125;&#125;function applyMiddleware(store, middlewares) &#123; // ... // 暂存原方法 let dispatch = store.dispatch; // middleware 中通过闭包获取 dispatch，并且更新 dispatch middlewares.forEach((middleware) =&gt; dispatch = middleware(store, dispatch); );&#125; 接着应用函数式编程的 curry 化（一种使用匿名单参数函数来实现多参数函数的方法。），还可以再进一步优化。（其实是为了使用 compose 将中间件函数先组合再绑定） 1234567891011121314151617181920212223242526272829303132function logger(store) &#123; return function(next) &#123; return function(action) &#123; console.log('dispatching', action); const result = next(action); // 应用原方法 console.log('next state', store.getState()); return result; &#125; &#125;&#125;// -- 使用 es6 的箭头函数可以让代码更加优雅更函数式... --const logger = (store) =&gt; (next) =&gt; (action) =&gt; &#123; console.log('dispatching', action); const result = next(action); // 应用原方法 console.log('next state', store.getState()); return result;&#125;;function applyMiddleware(store, middlewares) &#123; // ... let dispatch = store.dispatch; middlewares.forEach((middleware) =&gt; dispatch = middleware(store)(dispatch); // 注意调用了两次 ); // ...&#125; 以上方法离 Redux 中最终的 applyMiddleware 实现已经很接近了， 1.6. 第六次尝试：组合（compose，函数式方法）在 Redux 的最终实现中，并没有采用我们之前的 slice + reverse 的方法来倒着绑定中间件。而是采用了 map + compose + reduce 的方法。 先来说这个 compose 函数，在数学中以下等式十分的自然。 f(g(x)) = (f o g)(x)f(g(h(x))) = (f o g o h)(x) 用代码来表示这一过程就是这样。 123456// 传入参数为函数数组function compose(...funcs) &#123; // 返回一个闭包， // 将右边的函数作为内层函数执行，并将执行结果作为外层函数再次执行 return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)));&#125; 不了解 reduce 函数的人可能对于以上代码会感到有些费解，举个栗子来说，有函数数组 [f, g, h]传入 compose 函数执行。 首次 reduce 执行的结果是返回一个函数 (...args) =&gt; f(g(...args)) 接着该函数作为下一次 reduce 函数执行时的参数 a，而参数 b 是 h 再次执行时 h(...args) 作为参数传入 a，即最后返回的还是一个函数 (...args) =&gt; f(g(h(...args))) 因此最终版 applyMiddleware 实现中并非依次执行绑定，而是采用函数式的思维，将作用于 dispatch 的函数首先进行组合，再进行绑定。（所以要中间件要 curry 化） 12345678910111213141516171819202122232425262728293031// 传入中间件函数的数组function applyMiddleware(...middlewares) &#123; // 返回一个函数的原因在 createStore 部分再进行介绍 return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123; const store = createStore(reducer, preloadedState, enhancer) let dispatch = store.dispatch let chain = [] // 保存绑定了 middlewareAPI 后的函数数组 const middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action) &#125; chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) // 使用 compose 函数按照从右向左的顺序绑定（执行顺序是从左往右） dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125;// store -&gt; &#123; getState &#125; 从传递整个 store 改为传递部分 apiconst logger = (&#123; getState &#125;) =&gt; (next) =&gt; (action) =&gt; &#123; console.log('dispatching', action); const result = next(action); // 应用原方法 console.log('next state', getState()); return result;&#125;; 综上如下图所示整个中间件的执行顺序是类似于洋葱一样首先按照从外到内的顺序执行 dispatch 之前的中间件代码，在 dispatch（洋葱的心）执行后又反过来，按照从内到左外的顺序执行 dispatch 之后的中间件代码。 桥都麻袋！ 你真的都理解了么？ 在之前的实现中直接传递 store，为啥在最终实现中传递的是 middlewareAPI？ middlewareAPI 里的 dispatch 是为啥一个匿名函数而不直接传递 dispatch？ 如下列代码所示，如果在中间件里不用 next 而是调用 store.dispatch 会怎样呢？ 12345678const logger = (store) =&gt; (next) =&gt; (action) =&gt; &#123; console.log('dispatching', action); // 调用原始 dispatch，而不是上一个中间件传进来的 const result = store.dispatch(action); // &lt;- 这里 console.log('next state', store.getState()); return result;&#125;; 1.7. middleware 中调用 store.dispatch[6] 正常情况下，如图左，当我们 dispatch 一个 action 时，middleware 通过 next(action) 一层一层处理和传递 action 直到 redux 原生的 dispatch。如果某个 middleware 使用 store.dispatch(action) 来分发 action，就发生了右图的情况，相当于从外层重新来一遍，假如这个 middleware 一直简单粗暴地调用 store.dispatch(action)，就会形成无限循环了。（其实就相当于猴子补丁没补上，不停地调用原来的函数） 因此最终版里不是直接传递 store，而是传递 getState 和 dispatch，传递 getState 的原因是可以通过 getState 获取当前状态。并且还将 dispatch 用一个匿名函数包裹 dispatch: (action) =&gt; dispatch(action)，这样不但可以防止 dispatch 被中间件修改，而且只要 dispatch 更新了，middlewareAPI 中的 dispatch 也会随之发生变化。 1.8. createStore 进阶在上一篇中我们使用 createStore 方法只用到了它前两个参数，即 reducer 和 preloadedState，然鹅其实它还拥有第三个参数 enhancer。 enhancer 参数可以实现中间件、时间旅行、持久化等功能，Redux 仅提供了 applyMiddleware 用于应用中间件（就是 1.6. 中的那个）。 在日常使用中，要应用中间件可以这么写。 1234567891011121314151617181920212223242526import &#123; createStore, combineReducers, applyMiddleware,&#125; from 'redux';// 组合 reducerconst rootReducer = combineReducers(&#123; todos: todosReducer, filter: filterReducer,&#125;);// 中间件数组const middlewares = [logger, anotherMiddleWare];const store = createStore( rootReducer, initialState, applyMiddleware(...middlewares),);// 如果不需要 initialState 的话也可以忽略const store = createStore( rootReducer, applyMiddleware(...middlewares),); 在上文 applyMiddleware 的实现中留了个悬念，就是为什么返回的是一个函数，因为 enhancer 被定义为一个高阶函数，接收 createStore 函数作为参数。 12345678910111213141516171819202122232425262728293031/** * 创建一个 redux store 用于保存状态树， * 唯一改变 store 中数据的方法就是对其调用 dispatch * * 在你的应用中应该只有一个 store，想要针对不同的部分状态响应 action， * 你应该使用 combineReducers 将多个 reducer 合并。 * * @param &#123;函数&#125; reducer 不多解释了 * @param &#123;对象&#125; preloadedState 主要用于前后端同构时的数据同步 * @param &#123;函数&#125; enhancer 很牛逼，可以实现中间件、时间旅行，持久化等 * ※ Redux 仅提供 applyMiddleware 这个 Store Enhancer ※ * @return &#123;Store&#125; */export default function createStore(reducer, preloadedState, enhancer) &#123; if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125; if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; // enhancer 是一个高阶函数，接收 createStore 函数作为参数 return enhancer(createStore)(reducer, preloadedState) &#125; // ... // 后续内容推荐看看参考资料部分的【Redux 莞式教程】&#125; 总的来说 Redux 有五个 API，分别是： createStore(reducer, [initialState], enhancer) combineReducers(reducers) applyMiddleware(…middlewares) bindActionCreators(actionCreators, dispatch) compose(…functions) createStore 生成的 store 有四个 API，分别是： getState() dispatch(action) subscribe(listener) replaceReducer(nextReducer) 以上 API 我们还没介绍的应该就剩 bindActionCreators 了。这个 API 其实就是个语法糖起了方便地给 action creator 绑定 dispatch 的作用。 12345678910111213141516171819202122232425// 一般写法function mapDispatchToProps(dispatch) &#123; return &#123; onPlusClick: () =&gt; dispatch(increment()), onMinusClick: () =&gt; dispatch(decrement()), &#125;;&#125;// 使用 bindActionCreatorsimport &#123; bindActionCreators &#125; from 'redux';function mapDispatchToProps(dispatch) &#123; return bindActionCreators(&#123; onPlusClick: increment, onMinusClick: decrement, // 还可以绑定更多函数... &#125;, dispatch);&#125;// 甚至如果定义的函数输入都相同的话还能更加简洁export default connect( mapStateToProps, // 直接传一个对象，connect 自动帮你绑定 dispatch &#123; onPlusClick: increment, onMinusClick: decrement &#125;,)(App); 二、异步操作下面让我们告别干净的同步世界，进入“肮脏”的异步世界~。 在函数式编程中，异步操作、修改全局变量等与函数外部环境发生的交互叫做副作用（Side Effect）通常认为这些操作是邪恶（evil）肮脏（dirty）的，并且也是导致 bug 的源头。因为与之相对的是纯函数（pure function），即对于同样的输入总是返回同样的输出的函数，使用这样的函数很容易做组合、测试等操作，很容易验证和保证其正确性。（它们就像数学公式一般准确） 2.1. 通知应用场景[3]现在有这么一个显示通知的应用场景，在通知显示后5秒钟隐藏该通知。 首先当然是编写 action 显示：SHOW_NOTIFICATION 隐藏：HIDE_NOTIFICATION 2.1.1. 最直观的写法最直观的写法就是首先显示通知，然后使用 setTimeout 在5秒后隐藏通知。 1234store.dispatch(&#123; type: 'SHOW_NOTIFICATION', text: 'You logged in.' &#125;);setTimeout(() =&gt; &#123; store.dispatch(&#123; type: 'HIDE_NOTIFICATION' &#125;);&#125;, 5000); 然鹅，一般在组件中尤其是展示组件中没法也没必要获取 store，因此一般将其包装成 action creator。 123456789101112131415// actions.jsexport function showNotification(text) &#123; return &#123; type: 'SHOW_NOTIFICATION', text &#125;;&#125;export function hideNotification() &#123; return &#123; type: 'HIDE_NOTIFICATION' &#125;;&#125;// component.jsimport &#123; showNotification, hideNotification &#125; from '../actions';this.props.dispatch(showNotification('You just logged in.'));setTimeout(() =&gt; &#123; this.props.dispatch(hideNotification());&#125;, 5000); 或者更进一步地先使用 connect 方法包装。 1234this.props.showNotification('You just logged in.');setTimeout(() =&gt; &#123; this.props.hideNotification();&#125;, 5000); 到目前为止，我们没有用任何 middleware 或者别的概念。 2.1.2. 异步 action creator上一种直观写法有一些问题 每当我们需要显示一个通知就需要手动先显示，然后再手动地让其消失。其实我们更希望通知到时间后自动地消失。 通知目前没有自己的 id，所以有些场景下存在竞争条件（race condition），即假如在第一个通知结束前触发第二个通知，当第一个通知结束时，第二个通知也会被提前关闭。 所以为了解决以上问题，我们可以为通知加上 id，并将显示和消失的代码包起来。 1234567891011121314151617181920212223242526// actions.jsconst showNotification = (text, id) =&gt; (&#123; type: 'SHOW_NOTIFICATION', id, text,&#125;);const hideNotification = (id) =&gt; (&#123; type: 'HIDE_NOTIFICATION', id,&#125;);let nextNotificationId = 0;export function showNotificationWithTimeout(dispatch, text) &#123; const id = nextNotificationId++; dispatch(showNotification(id, text)); setTimeout(() =&gt; &#123; dispatch(hideNotification(id)); &#125;, 5000);&#125;// component.jsshowNotificationWithTimeout(this.props.dispatch, 'You just logged in.');// otherComponent.jsshowNotificationWithTimeout(this.props.dispatch, 'You just logged out.'); 为啥 showNotificationWithTimeout 函数要接收 dispatch 作为第一个参数呢？虽然通常一个组件都拥有触发 dispatch 的权限，但是现在我们想让一个外部函数（showNotificationWithTimeout）来触发 dispatch，所以需要将 dispatch 作为参数传入。 2.1.3. 单例 store可能你会说如果有一个从其他模块中导出的单例 store，那么是不是同样也可以不传递 dispatch 以上代码也可以这样写。 1234567891011121314151617181920212223// store.jsexport default createStore(reducer);// actions.jsimport store from './store';// ...let nextNotificationId = 0;export function showNotificationWithTimeout(text) &#123; const id = nextNotificationId++; store.dispatch(showNotification(id, text)); setTimeout(() =&gt; &#123; store.dispatch(hideNotification(id)); &#125;, 5000);&#125;// component.jsshowNotificationWithTimeout('You just logged in.');// otherComponent.jsshowNotificationWithTimeout('You just logged out.'); 这样看起来似乎更简单一些，不过墙裂不推荐这样的写法。主要的原因是这样的写法强制让 store 成为一个单例。这样一来要实现服务器端渲染（Server Rendering）将十分困难。因为在服务端，为了让不同的用户得到不同的预先获取的数据，你需要让每一个请求都有自己的 store。 并且单例 store 也将让测试变得困难。当测试 action creator 时你将无法自己模拟一个 store，因为它们都引用了从外部导入的那个特定的 store，所以你甚至无法从外部重置状态。 2.1.4. redux-thunk 中间件首先声明 redux-thunk 这种方案对于小型的应用来说足够日常使用，然鹅对于大型应用来说，你可能会发现一些不方便的地方。（例如对于 action 需要组合、取消、竞争等复杂操作的场景） 首先来明确什么是 thunk… A thunk is a function that wraps an expression to delay its evaluation. 简单来说 thunk 就是封装了表达式的函数，目的是延迟执行该表达式。不过有啥应用场景呢？ 目前为止，在上文中的 2.1.2. 异步 action creator 部分，最后得出的方案有以下明显的缺点 我们必须将 dispatch 作为参数传入。 这样一来任何使用了异步操作的组件都必须用 props 传递 dispatch（不管有多深…）。我们也没法像之前各种同步操作一样使用 connect 函数来绑定回调函数，因为 showNotificationWithTimeout 函数返回的不是一个 action。 此外，在日常使用时，我们还需要区分哪些函数是同步的 action creator，那些是异步的 action creator。（异步的需要传 dispatch…） 同步的情况: store.dispatch(actionCreator(payload)) 异步的情况: asyncActionCreator(store.dispatch, payload) 计将安出？ 其实问题的本质在于 Redux “有眼不识 function”，目前为止 dispatch 函数接收的参数只能是 action creator 返回的普通的 action。所以如果我们让 dispatch 对于 function 网开一面，走走后门潜规则一下不就行啦~ 实现方式很简单，想想第一节介绍的为 dispatch 添加日志功能的过程。 123456789101112131415// redux-thunk 源码function createThunkMiddleware(extraArgument) &#123; return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123; if (typeof action === 'function') &#123; return action(dispatch, getState, extraArgument); &#125; return next(action); &#125;;&#125;const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk; 以上就是 redux-thunk 的源码，就是这么简单，判断下如果传入的 action 是函数的话，就执行这个函数…（withExtraArgument 是为了添加额外的参数，详情见 redux-thunk 的 README.md） 这样一来如果我们 dispatch 了一个函数，redux-thunk 会传给它一个 dispatch 参数，我们就利用 thunk 解决了组件中不方便获取 dispatch 的问题。 并且由于 redux-thunk 拦截了函数，也可以防止 reducer 接收到函数而出现异常。 添加了 redux-thunk 中间件后代码可以这么写。 123456789101112131415161718192021// actions.js// ...let nextNotificationId = 0;export function showNotificationWithTimeout(text) &#123; // 返回一个函数 return function(dispatch) &#123; const id = nextNotificationId++; dispatch(showNotification(id, text)); setTimeout(() =&gt; &#123; dispatch(hideNotification(id)); &#125;, 5000); &#125;;&#125;// component.js 像同步函数一样的写法this.props.dispatch(showNotificationWithTimeout('You just logged in.'));// 或者 connect 后直接调用this.props.showNotificationWithTimeout('You just logged in.'); 2.2. 接口应用场景目前我们对于简单的延时异步操作的处理已经了然于胸了，现在让我们来考虑一下通过 ajax 或 jsonp 等接口来获取数据的异步场景。 很自然的，我们会发起一个请求，然后等待请求的响应（请求可能成功或是失败）。 即有基本的三种状态和与之对应的 action： 请求开始的 action：isFetching 为真，UI 显示加载界面{ type: &#39;FETCH_POSTS_REQUEST&#39; } 请求成功的 action：isFetching 为假，隐藏加载界面并显示接收到的数据{ type: &#39;FETCH_POSTS_SUCCESS&#39;, response: { ... } } 请求失败的 action：isFetching 为假，隐藏加载界面，可能保存失败信息并在 UI 中显示出来{ type: &#39;FETCH_POSTS_FAILURE&#39;, error: &#39;Oops&#39; } 按照这个思路，举一个简单的栗子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// Constantsconst FETCH_POSTS_REQUEST = 'FETCH_POSTS_REQUEST';const FETCH_POSTS_SUCCESS = 'FETCH_POSTS_SUCCESS';const FETCH_POSTS_FAILURE = 'FETCH_POSTS_FAILURE';// Actionsconst requestPosts = (id) =&gt; (&#123; type: FETCH_POSTS_REQUEST, payload: id,&#125;);const receivePosts = (res) =&gt; (&#123; type: FETCH_POSTS_SUCCESS, payload: res,&#125;);const catchPosts = (err) =&gt; (&#123; type: FETCH_POSTS_FAILURE, payload: err,&#125;);const fetchPosts = (id) =&gt; (dispatch, getState) =&gt; &#123; dispatch(requestPosts(id)); return api.getData(id) .then(res =&gt; dispatch(receivePosts(res))) .catch(error =&gt; dispatch(catchPosts(error)));&#125;;// reducerconst reducer = (oldState, action) =&gt; &#123; switch (action.type) &#123; case FETCH_POSTS_REQUEST: return requestState; case FETCH_POSTS_SUCCESS: return successState; case FETCH_POSTS_FAILURE: return errorState; default: return oldState; &#125;&#125;; 尽管这已经是最简单的调用接口场景，我们甚至还没写一行业务逻辑代码，但讲道理的话代码还是比较繁琐的。 而且其实代码是有一定的“套路”的，比如其实整个代码都是针对请求、成功、失败三部分来处理的，这让我们自然联想到 Promise，同样也是分为 pending、fulfilled、rejected 三种状态。 那么这两者可以结合起来让模版代码精简一下么？ 2.2.1. redux-promise 中间件[8]首先开门见山地使用 redux-promise 中间件来改写之前的代码看看效果。 12345678910111213141516171819202122232425// Constantsconst FETCH_POSTS_REQUEST = 'FETCH_POSTS_REQUEST';// Actionsconst fetchPosts = (id) =&gt; (&#123; type: FETCH_POSTS_REQUEST, payload: api.getData(id), // payload 为 Promise 对象&#125;);// reducerconst reducer = (oldState, action) =&gt; &#123; switch (action.type) &#123; case FETCH_POSTS_REQUEST: // requestState 被“吃掉”了 // 而成功、失败的状态通过 status 来判断 if (action.status === 'success') &#123; return successState; &#125; else &#123; return errorState; &#125; default: return oldState; &#125;&#125;; 可以看出 redux-promise 中间件比较激进、比较原教旨。 不但将发起请求的初始状态被拦截了（原因见下文源码），而且使用 action.status 而不是 action.type 来区分两个 action 这一做法也值得商榷（个人倾向使用 action.type 来判断）。 1234567891011121314151617181920212223242526272829// redux-promise 源码import &#123; isFSA &#125; from 'flux-standard-action';function isPromise(val) &#123; return val &amp;&amp; typeof val.then === 'function';&#125;export default function promiseMiddleware(&#123; dispatch &#125;) &#123; return next =&gt; action =&gt; &#123; if (!isFSA(action)) &#123; return isPromise(action) ? action.then(dispatch) : next(action); &#125; return isPromise(action.payload) // 直接调用 Promise.then（所以发不出请求开始的 action） ? action.payload.then( // 自动 dispatch result =&gt; dispatch(&#123; ...action, payload: result &#125;), // 自动 dispatch error =&gt; &#123; dispatch(&#123; ...action, payload: error, error: true &#125;); return Promise.reject(error); &#125; ) : next(action); &#125;;&#125; 以上是 redux-promise 的源码，十分简单。主要逻辑是判断如果是 Promise 就执行 then 方法。此外还根据是不是 FSA 决定调用的是 action 本身还是 action.payload 并且对于 FSA 会自动 dispatch 成功和失败的 FSA。 2.2.2. redux-promise-middleware 中间件尽管 redux-promise 中间件节省了大量代码，然鹅它的缺点除了拦截请求开始的 action，以及使用 action.status 来判断成功失败状态以外，还有就是由此引申出的一个无法实现的场景————乐观更新（Optimistic Update）。 乐观更新比较直观的栗子就是在微信、QQ等通讯软件中，发送的消息立即在对话窗口中展示，如果发送失败了，在消息旁边展示提示即可。由于在这种交互方式中“乐观”地相信操作会成功，因此称作乐观更新。 因为乐观更新发生在用户发起操作时，所以要实现它，意味着必须有表示用户初始动作的 action。 因此为了解决这些问题，相对于比较原教旨的 redux-promise 来说，更加温和派一点的 redux-promise-middleware 中间件应运而生。先看看代码怎么说。 12345678910111213141516171819202122232425262728// Constantsconst FETCH_POSTS = 'FETCH_POSTS'; // 前缀// Actionsconst fetchPosts = (id) =&gt; (&#123; type: FETCH_POSTS, // 传递的是前缀，中间件会自动生成中间状态 payload: &#123; promise: api.getData(id), data: id, &#125;,&#125;);// reducerconst reducer = (oldState, action) =&gt; &#123; switch (action.type) &#123; case `$&#123;FETCH_POSTS&#125;_PENDING`: return requestState; // 可通过 action.payload.data 获取 id case `$&#123;FETCH_POSTS&#125;_FULFILLED`: return successState; case `$&#123;FETCH_POSTS&#125;_REJECTED`: return errorState; default: return oldState; &#125;&#125;; 如果不需要乐观更新，fetchPosts 函数可以更加简洁。12345// 此时初始 actionGET_DATA_PENDING 仍然会触发，但是 payload 为空。const fetchPosts = (id) =&gt; (&#123; type: FETCH_POSTS, // 传递的是前缀 payload: api.getData(id), // 等价于 payload: &#123; promise: api.getData(id) &#125;,&#125;); 相对于 redux-promise 简单粗暴地直接过滤初始 action，从 reducer 可以看出，redux-promise-middleware 会首先自动触发一个 FETCH_POSTS_PENDING 的 action，以此保留乐观更新的能力。 并且，在状态的区分上，回归了通过 action.type 来判断状态的“正途”，其中 _PENDING、_FULFILLED、_REJECTED 后缀借用了 Promise 规范 (当然它们是可配置的) 。 后缀可以配置全局或局部生效，例如全局配置可以这么写。12345applyMiddleware( promiseMiddleware(&#123; promiseTypeSuffixes: ['LOADING', 'SUCCESS', 'ERROR'] &#125;)) 源码地址点我，类似 redux-promise 也是在中间件中拦截了 payload 中有 Promise 的 action，并主动 dispatch 三种状态的 action，注释也很详细在此就不赘述了。 注意：redux-promise、redux-promise-middleware 与 redux-thunk 之间并不是互相替代的关系，而更像一种补充优化。 2.3. redux-loop 中间件简单小结一下，Redux 的数据流如下所示： UI =&gt; action =&gt; action creator =&gt; reducer =&gt; store =&gt; react =&gt; v-dom =&gt; UI redux-thunk 的思路是保持 action 和 reducer 简单纯粹，然鹅副作用操作（在前端主要体现在异步操作上）的复杂度是不可避免的，因此它将其放在了 action creator 步骤，通过 thunk 函数手动控制每一次的 dispatch。 redux-promise 和 redux-promise-middleware 只是在其基础上做一些辅助性的增强，处理异步的逻辑本质上是相同的，即将维护复杂异步操作的责任推到了用户的身上。 这种实现方式固然很好理解，而且理论上可以应付所有异步场景，但是由此带来的问题就是模版代码太多，一旦流程复杂那么异步代码就会到处都是，很容易导致出现 bug。 因此有一些其他的中间件，例如 redux-loop 就将异步处理逻辑放在 reducer 中。（Redux 的思想借鉴了 Elm，注意并不是“饿了么”，而 Elm 就是将异步处理放在 update（reducer） 层中）。 Synchronous state transitions caused by returning a new state from the reducer in response to an action are just one of all possible effects an action can have on application state.这种通过响应一个 action，在 reducer 中返回一个新 state，从而引起同步状态转换的方式，只是在应用状态中一个 action 能拥有的所有可能影响的一种。（可能没翻好~欢迎勘误~） redux-loop 认为许多其他的处理异步的中间件，尤其是通过 action creator 方式实现的中间件，错误地让用户认为异步操作从根本上与同步操作并不相同。这样一来无形中鼓励了中间件以许多特殊的方式来处理异步状态。 与之相反，redux-loop 专注于让 reducer 变得足够强大以便处理同步和异步操作。在具体实现上 reducer 不仅能够根据特定的 action 决定当前的转换状态，而且还能决定接着发生的操作。 应用中所有行为都可以在一个地方（reducer）中被追踪，并且这些行为可以轻易地分割和组合。（redux 作者 Dan 开了个至今依然 open 的 issue：Reducer Composition with Effects in JavaScript，讨论关于对 reducer 进行分割组合的问题。） redux-loop 模仿 Elm 的模式，引入了 Effect 的概念，在 reducer 中对于异步等操作使用 Effect 来处理。如下官方示例所示： 123456789101112131415161718192021222324import &#123; Effects, loop &#125; from 'redux-loop';function fetchData(id) &#123; return fetch(`endpoint/$&#123;id&#125;`) .then((r) =&gt; r.json()) .then((data) =&gt; (&#123; type: 'FETCH_SUCCESS', payload: data &#125;)) .catch((error) =&gt; (&#123; type: 'FETCH_FAILURE', payload: error.message &#125;));&#125;function reducer(state, action) &#123; switch(action.type) &#123; case 'FETCH_START': return loop( // &lt;- 并没有直接返回 state，实际上了返回数组 [state, effect] &#123; ...state, loading: true &#125;, Effects.promise(fetchData, action.payload.id) ); case 'FETCH_SUCCESS': return &#123; ...state, loading: false, data: action.payload &#125;; case 'FETCH_FAILURE': return &#123; ...state, loading: false, errorMessage: action.payload &#125;; &#125;&#125; 虽然这个想法很 Elm 很函数式，不过由于修改了 reducer 的返回类型，这样一来会导致许多已有的 Api 和第三方库无法使用，甚至连 redux 库中的 combineReducers 方法都需要使用 redux-loop 提供的定制版本。因此这也是 redux-loop 最终无法转正的原因： “If a solution doesn’t work with vanilla combineReducers(), it won’t get into Redux core.” 三、复杂异步操作3.1. 更复杂的通知场景[9]让我们的思路重新回到通知的场景，之前的代码实现了： 展示一个通知并在数秒后消失 可以同时展示多个通知。 现在假设可亲可爱的产品又提出了新需求： 同时不展示多于3个的通知 如果已有3个通知正在展示，此时的新通知请求将排队延迟展示。 “这个实现不了…”（全文完） 这个当然可以实现，只不过如果只用之前的 redux-thunk 实现起来会很麻烦。例如可以在 store 中增加两个数组分别表示当前展示列表和等待队列，然后在 reducer 中手动控制各个状态时这俩数组的变化。 3.2. redux-saga 中间件首先来看看使用了 redux-saga 后代码会变成怎样~（代码来自生产环境的某 app） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768function* toastSaga() &#123; const MaxToasts = 3; const ToastDisplayTime = 4000; let pendingToasts = []; // 等待队列 let activeToasts = []; // 展示列表 function* displayToast(toast) &#123; if ( activeToasts &gt;= MaxToasts ) &#123; throw new Error(\"can't display more than \" + MaxToasts + \" at the same time\"); &#125; activeToasts = [...activeToasts, toast]; // 新增通知到展示列表 yield put(events.toastDisplayed(toast)); // 展示通知 yield call(delay, ToastDisplayTime); // 通知的展示时间 yield put(events.toastHidden(toast)); // 隐藏通知 activeToasts = _.without(activeToasts,toast); // 从展示列表中删除 &#125; function* toastRequestsWatcher() &#123; while (true) &#123; const event = yield take(Names.TOAST_DISPLAY_REQUESTED); // 监听通知展示请求 const newToast = event.data.toastData; pendingToasts = [...pendingToasts, newToast]; // 将新通知放入等待队列 &#125; &#125; function* toastScheduler() &#123; while (true) &#123; if (activeToasts.length &lt; MaxToasts &amp;&amp; pendingToasts.length &gt; 0) &#123; const [firstToast,...remainingToasts] = pendingToasts; pendingToasts = remainingToasts; yield fork(displayToast, firstToast); // 取出队头的通知进行展示 // 增加一点延迟，这样一来两个并发的通知请求不会同时展示 yield call(delay, 300); &#125; else &#123; yield call(delay, 50); &#125; &#125; &#125; yield [ call(toastRequestsWatcher), call(toastScheduler) ]&#125;// reducerconst reducer = (state = &#123;toasts: []&#125;, event) =&gt; &#123; switch (event.name) &#123; case Names.TOAST_DISPLAYED: return &#123; ...state, toasts: [...state.toasts, event.data.toastData] &#125;; case Names.TOAST_HIDDEN: return &#123; ...state, toasts: _.without(state.toasts, event.data.toastData) &#125;; default: return state; &#125;&#125;; 先不要在意代码的细节，简单分析一下上述代码的逻辑： store 上只有一个 toasts 节点，且 reducer 十分干净 排队等具体的业务逻辑都放到了 toastSaga 函数中 displayToast 函数负责单个通知的展示和消失逻辑 toastRequestsWatcher 函数负责监听请求，将其加入等待队列 toastScheduler 函数负责将等待队列中的元素加入展示列表 基于这样逻辑分离的写法，还可以继续满足更加复杂的需求： 如果在等待队列中有太多通知，动态减少通知的展示时间 根据窗口大小的变化，改变最多展示的通知数量 … redux-saga V.S. redux-thunk[11]redux-saga 的优点： 易于测试，因为 redux-saga 中所有操作都 yield 简单对象，所以测试只要判断返回的对象是否正确即可，而测试 thunk 通常需要你在测试中引入一个 mockStore redux-saga 提供了一些方便的辅助方法。（takeLatest、cancel、race 等） 在 saga 函数中处理业务逻辑和异步操作，这样一来通常代码更加清晰，更容易增加和更改功能 使用 ES6 的 generator，以同步的方式写异步代码 redux-saga 的缺点： generator 的语法（”又是 * 又是 yield 的，很难理解诶~”） 学习曲线陡峭，有许多概念需要学习（”fork、join 这不是进程的概念么？这些 yield 是以什么顺序执行的？”） API 的稳定性，例如新增了 channel 特性，并且社区也不是很大。 通知场景各种中间件写法的完整代码可以看这里 3.3. 理解 Saga Pattern[14]3.3.1. Saga 是什么Sagas 的概念来源于这篇论文，该论文从数据库的角度谈了 Saga Pattern。 Saga 就是能够满足特定条件的长事务（Long Lived Transaction） 暂且不提这个特定条件是什么，首先一般学过数据库的都知道事务（Transaction）是啥~ 如果不知道的话可以用转账来理解，A 转给 B 100 块钱的操作需要保证完成 A 先减 100 块钱然后 B 加 100 块钱这两个操作，这样才能保证转账前后 A 和 B 的存款总额不变。如果在给 B 加 100 块钱的过程中发生了异常，那么就要返回转账前的状态，即给 A 再加上之前减的 100 块钱(不然钱就不翼而飞了)，这样的一次转账（要么转成功，要么失败返回转账前的状态）就是一个事务。 3.3.2. 长事务的问题 长事务顾名思义就是一个长时间的事务。 一般来说是通过给正在进行事务操作的对象加锁，来保证事务并发时不会出错。 例如 A 和 B 都给 C 转 100 块钱。 如果不加锁，极端情况下 A 先转给 C 100 块，而 B 读取到了 C 转账前的数值，这时 B 的转账会覆盖 A 的转账，C 只加了 100 块钱，另 100 块不翼而飞了。 如果加了锁，这时 B 的转账会等待 A 的转账完成后再进行。所以 C 能正确地收到 200 块钱。 以押尾光太郎的指弹演奏会售票举例，在一个售票的时间段后，最终举办方需要确定售票数量，这就是一个长事务。 然鹅，对于长事务来说总不能一直锁住对应数据吧？ 为了解决这个问题，假设一个长事务：T， 可以被拆分成许多相互独立的子事务（subtransaction）：t_1 ~ t_n。 以上述押尾桑的表演为例，每个 t 就是一笔售票记录。 假如每次购票都一次成功，且没有退票的话，整个流程就如下图一般被正常地执行。 那假如有某次购票失败了怎么办？ 3.3.3. Saga 的特殊条件 A LLT is a saga if it can be written as a sequence of transactions that can be interleaved with other transactions.Saga 就是能够被写成事务的序列，并且能够在执行过程中被其他事务插入执行的长事务。 Saga 通过引入补偿事务（Compensating Transaction）的概念，解决事务失败的问题。 即任何一个 saga 中的子事务 t_i，都有一个补偿事务 c_i 负责将其撤销（undo）。 注意是撤销该子事务，而不是回到子事务发生前的时间点。 根据以上逻辑，可以推出很简单的公式： Saga 如果全部执行成功那么子事务序列看起来像这样：t_1, t_2, t_3, ..., t_n Saga 如果执行全部失败那么子事务序列看起来像这样：t_1, t_2, t_3, ..., t_n, c_n, ..., c_1 注意到图中的 c_4 其实并没有必要，不过因为每次撤销执行都应该是幂等（Idempotent）的，所以也不会出错。 篇幅有限在此就不继续深入介绍… 推荐看看从分布式系统方面讲 Saga Pattern 的视频：GOTO 2015 • Applying the Saga Pattern • Caitie McCaffrey MSDN 的文章：A Saga on Sagas 3.4. 响应式编程（Reactive Programming）[15]redux-saga 中间件基于 Sagas 的理论，通过监听 action，生成对应的各种子 saga（子事务）解决了复杂异步问题。 而接下来要介绍的 redux-observable 中间件背后的理论是响应式编程（Reactive Programming）。 In computing, reactive programming is a programming paradigm oriented around data flows and the propagation of change. 简单来说，响应式编程是针对异步数据流的编程并且认为：万物皆流（Everything is Stream）。 流（Stream）就是随着时间的流逝而发生的一系列事件。 例如点击事件的示意图就是这样。 用字符表示【上上下下左右左右BABA】可以像这样。（注意顺序是从左往右） 123456--上----上-下---下----左---右-B--A-B--A---X-|-&gt;上, 下, 左, 右, B, A 是数据流发射的值X 是数据流发射的错误| 是完成信号---&gt; 是时间线 那么我们要根据一个点击流来计算点击次数的话可以这样。（一般响应式编程库都会提供许多辅助方法如 map、filter、scan 等） 12345 clickStream: ---c----c--c----c------c--&gt; map(c becomes 1) ---1----1--1----1------1--&gt; scan(+)counterStream: ---1----2--3----4------5--&gt; 如上所示，原始的 clickStream 经过 map 后产生了一个新的流（注意原始流不变），再对该流进行 scan(+) 的操作就生成了最终的 counterStream。 再来个栗子~，假设我们需要从点击流中得到关于双击的流（250ms 以内），并且对于大于两次的点击也认为是双击。先想一想应该怎么用传统的命令式、状态式的方式来写，然后再想想用流的思考方式又会是怎么样的~。 这里我们用了以下辅助方法： 节流：throttle(250ms)，将原始流在 250ms 内的所有数据当作一次事件发射 缓冲（不造翻译成啥比较好）：buffer，将 250ms 内收集的数据放入一个数据包裹中，然后发射这些包裹 映射：map，这个不解释 过滤：filter，这个也不解释 更多内容请继续学习 RxJS。 3.5. redux-observable 中间件[16]redux-observable 就是一个使用 RxJS 监听每个 action 并将其变成可观测流（observable stream）的中间件。 其中最核心的概念叫做 epic，就是一个监听流上 action 的函数，这个函数在接收 action 并进行一些操作后可以再返回新的 action。 At the highest level, epics are “actions in, actions out” redux-observable 通过在后台执行 .subscribe(store.dispatch) 实现监听。 Epic 像 Saga 一样也是 Long Lived，即在应用初始化时启动，持续运行到应用关闭。虽然 redux-observable 是一个中间件，但是类似于 redux-saga，可以想象它就像新开的进/线程，监听着 action。 在这个运行流程中，epic 不像 thunk 一样拦截 action，或阻止、改变任何原本 redux 的生命周期的其他东西。这意味着每个 dispatch 的 action 总会经过 reducer 处理，实际上在 epic 监听到 action 前，action 已经被 reducer 处理过了。 所以 epic 的功能就是监听所有的 action，过滤出需要被监听的部分，对其执行一些带副作用的异步操作，然后根据你的需要可以再发射一些新的 action。 举个自动保存的栗子，界面上有一个输入框，每次用户输入了数据后，去抖动后进行自动保存，并在向服务器发送请求的过程中显示正在保存的 UI，最后显示成功或失败的 UI。 使用 redux-observable 中间件编写代码，可以仅用十几行关键代码就实现上述功能。 123456789101112131415161718192021222324252627282930import &#123; Observable &#125; from 'rxjs/Observable';import 'rxjs/add/observable/dom/ajax';import 'rxjs/add/observable/of';import 'rxjs/add/operator/catch';import 'rxjs/add/operator/debounceTime';import 'rxjs/add/operator/map';import 'rxjs/add/operator/mergeMap';import 'rxjs/add/operator/startWith';import &#123; isSaving, savingSuccess, savingError,&#125; from '../actions/autosave-actions.js';const saveField = (action$) =&gt; // 一般在变量后面加 $ 表示是个 stream action$ .ofType('SAVE_FIELD') // 使用 ofType 监听 'SAVE_FIELD' action .debounceTime(500) // 防抖动 // 即 map + mergeAll 因为异步导致 map 后有多个流需要 merge .mergeMap((&#123; payload &#125;) =&gt; Observable.ajax(&#123; // 发起请求 method: 'PATCH', url: payload.url, body: JSON.stringify(payload), &#125;) .map(res =&gt; savingSuccess(res)) // 发出成功的 action .catch(err =&gt; Observable.of(savingError(err))) // 捕捉错误并发出 action .startWith(isSaving()) // 发出请求开始的 action );export default saveField; 篇幅有限在此就不继续深入介绍… 关于 redux-observable 的前世今生推荐看看 Netfix 工程师的这个视频：Netflix JavaScript Talks - RxJS + Redux + React = Amazing! 如果觉得看视频听英语麻烦的话知乎有人翻译了… RxJS + Redux + React = Amazing!（译一） RxJS + Redux + React = Amazing!（译二） 四、总结本文从为 Redux 应用添加日志功能（记录每一次的 dispatch）入手，引出 redux 的中间件（middleware）的概念和实现方法。 接着从最简单的 setTimeout 的异步操作开始，通过对比各种实现方法引出 redux 最基础的异步中间件 redux-thunk。 针对 redux-thunk 使用时模版代码过多的问题，又介绍了用于优化的 redux-promise 和 redux-promise-middleware 两款中间件。 由于本质上以上中间件都是基于 thunk 的机制来解决异步问题，所以不可避免地将维护异步状态的责任推给了开发者，并且也因为难以测试的原因。在复杂的异步场景下使用起来难免力不从心，容易出现 bug。 所以还简单介绍了一下将处理副作用的步骤放到 reducer 中并通过 Effect 进行解决的 redux-loop 中间件。然鹅因为其无法使用官方 combineReducers 的原因而无法被纳入 redux 核心代码中。 此外社区根据 Saga 的概念，利用 ES6 的 generator 实现了 redux-saga 中间件。虽然通过 saga 函数将业务代码分离，并且可以用同步的方式流程清晰地编写异步代码，但是较多的新概念和 generator 的语法可能让部分开发者望而却步。 同样是基于观察者模式，通过监听 action 来处理异步操作的 redux-observable 中间件，背后的思想是响应式编程（Reactive Programming）。类似于 saga，该中间件提出了 epic 的概念来处理副作用。即监听 action 流，一旦监听到目标 action，就处理相关副作用，并且还可以在处理后再发射新的 action，继续进行处理。尽管在处理异步流程时同样十分方便，但对于开发者的要求同样很高，需要开发者学习关于函数式的相关理论。 五、参考资料 Redux 英文原版文档 Redux 中文文档 Dan Abramov - how to dispatch a redux action with a timeout 阮一峰 - Redux 入门教程（二）：中间件与异步操作 Redux 莞式教程 redux middleware 详解 Thunk 函数的含义和用法 Redux异步方案选型 Sebastien Lorber - how to dispatch a redux action with a timeout Sagas 论文 Pros/cons of using redux-saga with ES6 generators vs redux-thunk with ES7 async/await Redux-saga 英文文档 Redux-saga 中文文档 Saga Pattern 在前端的應用 The introduction to Reactive Programming you’ve been missing Epic Middleware in Redux 以上 to be continued…","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://buptsteve.github.io/blog/tags/JavaScript/"},{"name":"Redux","slug":"Redux","permalink":"https://buptsteve.github.io/blog/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://buptsteve.github.io/blog/tags/React/"}]},{"title":"「7」Redux 基础 - react 全家桶学习笔记（一）","date":"2016-10-25T15:00:35.000Z","path":"2016/10/25/007.redux-basis/","text":"零、环境搭建参考资料 英文原版文档 中文文档 墙裂推荐作者出的教学视频 基础篇 墙裂推荐作者出的教学视频 高级篇 首先要明确一点，虽然 redux 是由 flux 演变而来，但我们完全可以并且也应该抛开 react 进行学习，这样可以避免一开始就陷入各种细节之中。 所以推荐使用 jsbin 进行调试学习，或者使用 create-react-app 作为项目脚手架。 一、Redux 是什么？ Redux is a predictable state container for JavaScript apps.Redux 是一个 JavaScript 状态容器，提供可预测化的状态管理。 先不要在意那些细节 总的来说，redux 使用 store 保存并管理页面中的各种状态（state） 当需要改变 state 时，使用 dispatch 调用 action creators 触发 action 接着使用纯函数（pure function）reducer 来处理这些 action，它会根据当前 state 和 action 返回（注意这里不是修改）新的 state view 层可以对于 state 进行订阅（subscribe），这样就可以得到新的 state，从而可以刷新界面（所以十分适合数据驱动的前端框架） 纯函数：简单的说就是对于同样的输入总是返回同样的输出，并且没有副作用的函数。（推荐学习了解下函数式编程） 1.1. 为什么选择 redux？ 随着 JavaScript 单页应用开发日趋复杂，JavaScript 需要管理比任何时候都要多的 state （状态）。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI 状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。 管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。 如果这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调优、服务端渲染、路由跳转前请求数据等等。前端开发者正在经受前所未有的复杂性，难道就这么放弃了吗？当然不是。 这里的复杂性很大程度上来自于：我们总是将两个难以厘清的概念混淆在一起：变化和异步。 我称它们为曼妥思和可乐。如果把二者分开，能做的很好，但混到一起，就变得一团糟。一些库如 React 试图在视图层禁止异步和直接操作 DOM 来解决这个问题。美中不足的是，React 依旧把处理 state 中数据的问题留给了你。Redux就是为了帮你解决这个问题。 跟随 Flux、CQRS 和 Event Sourcing 的脚步，通过限制更新发生的时间和方式，Redux 试图让 state 的变化变得可预测。这些限制条件反映在 Redux 的 三大原则中。 简单总结就是使用 Redux 我们就可以没有蛀牙（大雾） 拥有可预测（predictable）的应用状态，所以应用的行为也是可预测的 因为 reducer 是纯函数，所以方便对于状态迁移进行自动化测试 方便地记录日志，甚至实现时间旅行（time travel） 1.2. 三大原则（哲♂学）1.2.1. 单一数据源（Single source of truth）整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。 来自服务端的 state 可以在无需编写更多代码的情况下被序列化并注入到客户端中 便于调试，在开发时可以将状态保存在本地 Undo/Redo 可以轻松实现，从而实现时间旅行 1.2.2. State 是只读的（State is read-only）惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。 因为所有的修改都被集中化处理，且严格按照一个接一个的顺序执行，（dispatch 同步调用 reduce 函数）因此不用担心 race condition 的出现。 Action 就是普通对象而已，因此它们可以被日志打印、序列化、储存、后期调试或测试时回放出来。 1.2.3. 使用纯函数来执行修改（Changes are made with pure functions）为了描述 action 如何改变 state tree ，你需要编写 reducer。 Reducer 只是纯函数，它接收先前的 state 和 action，并返回新的 state。刚开始你可以只有一个 reducer，随着应用变大，你可以把它拆成多个小的 reducers，分别独立地操作 state tree 的不同部分。 二、Redux 基础2.1. actionAction 就是一个普通的 JavaScript Object。 redux 唯一限制的一点是必须有一个 type 属性用来表示执行哪种操作，值最好用字符串，而不是 Symbols，因为字符串是可被序列化的。 其他属性用来传递此次操作所需传递的数据，redux 对此不作限制，但是在设计时可以参照 Flux 标准 Action。 简单总结 Flux Standard action 就是 一个 action 必须是一个 JavaScript Object，并且有一个 type 属性。 一个 action 可以有 payload/error/meta 属性。 一个 action 不能有其他属性。 2.2. reducerReducer 的工作就是接收旧的 state 和 action，返回新的 state。 (previousState, action) =&gt; newState 之所以称作 reducer 是因为它将被传递给 Array.prototype.reduce(reducer, ?initialValue) 方法。保持 reducer 纯净非常重要。永远不要在 reducer 里做这些操作： 修改传入参数； 执行有副作用的操作，如 API 请求和路由跳转； 调用非纯函数，如 Date.now() 或 Math.random()。 2.3. storeStore 就是用来维持应用所有的 state 树的一个对象。 在 redux 中只有一个 store（区别于 flux 的多个 store），在 store 中保存所有的 state，可以把它当成一个封装了 state 的类。而除了对其 dispatch 一个 action 以外无法改变内部的 state。 在实际操作中我们只需要把根部的 reducer 函数传递给 createStore 就可以得到一个 store。 12345678910111213import &#123; createStore &#125; from 'redux';function reducer(state, action) &#123; switch (action.type) &#123; case 'SOME_ACTION': // 一些操作 return newState; // 返回新状态 default: return state; &#125;&#125;const store = createStore(reducer); redux 中提供了这几个 api 操作 store 2.3.1. getState返回当前的整个 state 树。 2.3.2. dispatch(action)分发 action 给对应的 reducer。 该函数会调用 getState() 和传入的 action 以【同步】的方式调用 store 的 reduce 函数，然后返回新的 state。从而 state 得到了更新，并且变化监听器（change listener）会被触发。（对于异步操作则将其放到了 action creator 这个步骤） 2.3.3. subscribe(listener)为 store 添加一个变化监听器，每当 dispatch 的时候就会执行，你可以在 listener（回调函数）中使用 getState() 来得到当前的 state。 这个 api 设计的挺有意思，它会返回一个函数，而你执行这个函数后就可以取消订阅。 2.3.4. replaceReducer(nextReducer)替换 store 当前用来计算 state 的 reducer。 这是一个高级 API。只有在你需要实现代码分隔，而且需要立即加载一些 reducer 的时候才可能会用到它。在实现 Redux 热加载机制的时候也可能会用到。 2.4. createStore忽略各种类型判断，实现一个最简的 createStore 可以用以下代码。参考资料 123456789101112131415161718192021222324const createStore = (reducer) =&gt; &#123; let state; let listeners = []; const getState = () =&gt; state; const dispatch = (action) =&gt; &#123; state = reducer(state, action); // 调用 reducer listeners.forEach(listener =&gt; listener()); // 调用所有变化监听器 &#125;; const subscribe = (listener) =&gt; &#123; listeners.push(listener); return () =&gt; &#123; // 返回解除监听函数 listeners = listeners.filter(l =&gt; l !== listener); &#125;; &#125; dispatch(&#123;&#125;); // 初始化 return &#123; getState, dispatch, subscribe &#125;;&#125;; 2.5. 计数器例子 纯 JavaScript 不涉及界面（可以在右侧 console 中尝试 store.dispatch） 增加界面 三、与 React 进行结合3.1. 通过 script 标签导入 react实现同样功能的 Counter 3.2. 用 Redux 和 React 实现 TodoApp在添加 react-redux 之前，为了体会下 react-redux 的作用，首先来实现一个比计数器更复杂一点儿的 TodoApp 栗子~ 3.2.1. 分析与设计1. 容器组件 V.S. 展示组件组件一般分为 容器组件（Smart/Container Components） 展示组件（Dumb/Presentational Components） 容器组件 展示组件 Location 最顶层，路由处理 中间和子组件 Aware of Redux 是 否 读取数据 从 Redux 获取 state 从 props 获取数据 修改数据 向 Redux 派发 actions 从 props 调用回调函数 最佳实践一般是由容器组件负责一些数据的获取，进行 dispatch 等操作。而展示组件组件不应该关心逻辑，所有数据都通过 props 传入。 这样才能达到展示组件可以在多处复用，在具体复用时就是通过容器组件将其包装，为其提供所需的各种数据。 2. 应用设计 一个 TodoApp 包含了三个部分： 顶部的 AddTodo 输入部分 中间的 TodoList 展示部分 底部的 Footer 过滤部分 State 应该包含： filter：过滤 todos 的条件 SHOW_ALL SHOW_ACTIVE SHOW_COMPLETED todos：所有的 todo todo：包含 id、text 和 completed 然而传到应用中的 props 只需要： visibleTodos：过滤后的 todos filter：过滤条件 Action 应该有三种： ADD_TODO TOGGLE_TODO SET_VISIBILITY_FILTER 3.2.2. 编码实现1. action 部分123456789101112131415// 暂且使用数字作为 idlet nextTodoId = 0;/*-- action creators --*/const addTodo = (text) =&gt; ( &#123; type: 'ADD_TODO', id: nextTodoId++, text &#125;);const toggleTodo = (id) =&gt; ( &#123; type: 'TOGGLE_TODO', id &#125;);const setVisibilityFilter = (filter) =&gt; ( &#123; type: 'SET_VISIBILITY_FILTER', filter &#125;); 2. reducer 部分12345678910111213141516171819202122232425262728293031323334353637383940// 默认初始状态const initialState = &#123; filter: 'SHOW_ALL', todos: [] &#125;;function rootReducer(state = initialState, action) &#123; switch (action.type) &#123; case 'ADD_TODO': // 对象解构 const &#123; id, text &#125; = action; return &#123; ...state, todos: [ ...state.todos, &#123; id, text, completed: false &#125;, ], &#125;; case 'TOGGLE_TODO': return &#123; ...state, todos: state.todos.map(todo =&gt; &#123; if (todo.id !== action.id) return todo; return &#123; ...todo, completed: !todo.completed, &#125;; &#125;), &#125;; case 'SET_VISIBILITY_FILTER': return &#123; ...state, filter: action.filter, &#125;; default: return state; &#125;&#125; 注意! 不要直接修改原有的 state，而是返回一个新的 state。可以使用 Object.assign() 新建一个新的 state。不能这样使用 Object.assign(state, { visibilityFilter: action.filter })，因为它会改变第一个参数的值。你必须把第一个参数设置为空对象。你也可以开启对 ES7 提案对象展开运算符的支持, 从而使用 { …state, …newState } 达到相同的目的。 在 default 的情况下返回旧的 state，用来兼容遇到未知的 action 这样的错误。 拆分 reducer目前代码看着比较冗长，其实在逻辑上 todos 的处理和 filter 的处理应该分开，所以在 state 没有互相耦合时，可以将其拆分，从而让 reducer 精细地对于对应 state 的子树进行处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 处理单个 todoconst todoReducer = (state, action) =&gt; &#123; switch (action.type) &#123; case 'ADD_TODO': return &#123; id: action.id, text: action.text, completed: false, &#125;; case 'TOGGLE_TODO': if (state.id !== action.id) return state; return &#123; ...state, completed: !state.completed, &#125;; default: return state; &#125;&#125;;// 处理 todosconst todosReducer = (state = [], action) =&gt; &#123; switch (action.type) &#123; case 'ADD_TODO': return [ ...state, todoReducer(undefined, action), ]; case 'TOGGLE_TODO': return state.map(t =&gt; todoReducer(t, action)); default: return state; &#125;;&#125;;// 处理 filterconst filterReducer = (state = 'SHOW_ALL', action) =&gt; &#123; switch (action.type) &#123; case 'SET_VISIBILITY_FILTER': return action.filter; default: return state; &#125;;&#125;;const rootReducer = (state = initialState, action) =&gt; (&#123; todos: todosReducer(state.todos, action), filter: filterReducer(state.filter, action),&#125;); 注意观察最后的 rootReducer 函数，返回的是一个经过各种 reducer 处理过并合并后的新 state。 然鹅，注意这里 todos: todos(state.todos, action), 传入 state.todos，返回的一定也是 todos（因为都是 state 树上的节点）。 所以 redux 提供了很实用的 combineReducers api，用于简化 reducer 的合并。 123456789import &#123; combineReducers &#125; from 'redux';const rootReducer = combineReducers(&#123; todos: todosReducer, filter: filterReducer,&#125;);// initialState 可以作为第二个参数传入const store = createStore(rootReducer, initialState); 并且如果 reducer 与 state 节点同名的话（即 todosReducer -&gt; todos）还能通过 es6 的语法更进一步地简化 123456import &#123; combineReducers &#125; from 'redux';const rootReducer = combineReducers(&#123; todos, filter &#125;);// initialState 可以作为第二个参数传入const store = createStore(rootReducer, initialState); 随着应用的膨胀，我们还可以将拆分后的 reducer 放到不同的文件中, 以保持其独立性并用于专门处理不同的数据域。 3. view 部分1. 只有根组件首先只写一个根组件 &lt;TodoApp /&gt;，store 通过 props 传入 TodoApp，并在生命周期的 componentDidMount 和 componentWillUnmount 时分别订阅与取消订阅。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import React, &#123; Component &#125; from 'react';class TodoApp extends Component &#123; // 订阅 store 的变化 componentDidMount() &#123; const &#123; store &#125; = this.props; this.unsubscribe = store.subscribe( this.forceUpdate.bind(this) ); &#125; // 取消订阅 componentWillUnmount() &#123; this.unsubscribe(); &#125; // 渲染单个 todo _renderTodo(todo) &#123; const &#123; store &#125; = this.props; return ( &lt;li key=&#123;todo.id&#125; onClick=&#123;() =&gt; store.dispatch(toggleTodo(todo.id))&#125; style=&#123;&#123; textDecoration: todo.completed ? 'line-through' : 'none', cursor: todo.completed ? 'default' : 'pointer', &#125;&#125; &gt; &#123;todo.text&#125; &lt;/li&gt; ); &#125; // 根据当前 filter 是否匹配，返回字符串或是 a 链接 _renderFilter(renderFilter, name) &#123; const &#123; store &#125; = this.props; const &#123; filter &#125; = store.getState(); if (renderFilter === filter) return name; return ( &lt;a href='#' onClick=&#123;e =&gt; &#123; e.preventDefault(); store.dispatch(setVisibilityFilter(renderFilter)) &#125;&#125;&gt; &#123;name&#125; &lt;/a&gt; ); &#125; // 根据当前 filter 过滤需要渲染的 todos _getVisibleTodos(todos, filter) &#123; switch (filter) &#123; case 'SHOW_ALL': return todos; case 'SHOW_COMPLETED': return todos.filter(todo =&gt; todo.completed); case 'SHOW_ACTIVE': return todos.filter(todo =&gt; !todo.completed); default: return todos; &#125; &#125; render() &#123; const &#123; store &#125; = this.props; const &#123; todos, filter &#125; = store.getState(); let input; return ( &lt;div&gt; &#123;/* AddTodo */&#125; &lt;input type=\"text\" ref=&#123;node =&gt; input = node&#125; /&gt; &lt;button onClick=&#123;() =&gt; &#123; if (!input.value) return; store.dispatch(addTodo(input.value)); input.value = ''; &#125;&#125;&gt; addTodo &lt;/button&gt; &#123;/* TodoList */&#125; &lt;ul&gt; &#123;this._getVisibleTodos(todos, filter) .map(this._renderTodo.bind(this)) &#125; &lt;/ul&gt; &#123;/* Footer */&#125; &lt;p&gt; Show: &#123;' '&#125; &#123;this._renderFilter('SHOW_ALL', 'all')&#125; &#123;', '&#125; &#123;this._renderFilter('SHOW_COMPLETED', 'completed')&#125; &#123;', '&#125; &#123;this._renderFilter('SHOW_ACTIVE', 'active')&#125; &lt;/p&gt; &lt;/div&gt; ); &#125;&#125; TodoApp 只有根组件 2. 组件拆分将所有界面内容全写在 TodoApp 中实在是太臃肿了，接下来根据之前的分析结果将其分为以下子组件（全是展示组件） AddTodo TodoList Todo Footer FilterLink 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586const AddTodo = (&#123; onAddClick &#125;) =&gt; &#123; let input; return ( &lt;div&gt; &lt;input type=\"text\" ref=&#123;node =&gt; input = node&#125; /&gt; &lt;button onClick=&#123;() =&gt; &#123; onAddClick(input.value); input.value = ''; &#125;&#125;&gt; addTodo &lt;/button&gt; &lt;/div&gt; );&#125;;const Todo = (&#123; text, onClick, completed &#125;) =&gt; ( &lt;li onClick=&#123;onClick&#125; style=&#123;&#123; textDecoration: completed ? 'line-through' : 'none', cursor: completed ? 'default' : 'pointer', &#125;&#125; &gt; &#123;text&#125; &lt;/li&gt;);const TodoList = (&#123; todos, onTodoClick &#125;) =&gt; ( &lt;ul&gt; &#123;todos.map(todo =&gt; &lt;Todo key=&#123;todo.id&#125; &#123;...todo&#125; onClick=&#123;() =&gt; onTodoClick(todo.id)&#125; /&gt; )&#125; &lt;/ul&gt;);const FilterLink = (&#123; filter, onClick, renderFilter, children &#125;) =&gt; &#123; if (renderFilter === filter) return (&lt;span&gt;&#123;children&#125;&lt;/span&gt;); return ( &lt;a href='#' onClick=&#123;e =&gt; &#123; e.preventDefault(); onClick(renderFilter); &#125;&#125;&gt; &#123;children&#125; &lt;/a&gt; );&#125;;const Footer = (&#123; filter, onFilterClick &#125;) =&gt; ( &lt;p&gt; Show: &#123;' '&#125; &lt;FilterLink filter=&#123;filter&#125; renderFilter=\"SHOW_ALL\" onClick=&#123;onFilterClick&#125; &gt; all &lt;/FilterLink&gt; &#123;', '&#125; &lt;FilterLink filter=&#123;filter&#125; renderFilter=\"SHOW_COMPLETED\" onClick=&#123;onFilterClick&#125; &gt; completed &lt;/FilterLink&gt; &#123;', '&#125; &lt;FilterLink filter=&#123;filter&#125; renderFilter=\"SHOW_ACTIVE\" onClick=&#123;onFilterClick&#125; &gt; active &lt;/FilterLink&gt; &lt;/p&gt;); 所以 TodoApp 精简后是这样~ 1234567891011121314151617181920212223242526272829303132class TodoApp extends Component &#123; // ... render() &#123; const &#123; store &#125; = this.props; const &#123; todos, filter &#125; = store.getState(); return ( &lt;div&gt; &lt;AddTodo onAddClick=&#123;text =&gt; &#123; if (!text) return; store.dispatch(addTodo(text)); &#125;&#125; /&gt; &lt;TodoList todos=&#123;this._getVisibleTodos(todos, filter)&#125; onTodoClick=&#123;id =&gt; store.dispatch(toggleTodo(id))&#125; /&gt; &lt;Footer filter=&#123;filter&#125; onFilterClick=&#123;filter =&gt; &#123; store.dispatch(setVisibilityFilter(filter)); &#125;&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 3. 增加容器组件现在我们仍然是以 TodoApp 作为容器组件，其中各个子组件都是展示组件。 但是这样做的话一旦子组件需要某个属性，就需要从根组件层层传递下来，比如 FilterLink 中的 filter 属性。 所以下面我们增加容器组件，让展示组件通过容器组件获得所需属性。 AddTodo(container) VisibleTodoList(container) TodoList Todo Footer FilterLink(container) Link 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182// store.dispatch 又被放回来了，// 因为暂时我们只在 AddTodo 组件中使用 addTodo 这个 action// 以后增加了新的 form 之后可以考虑再将 store.dispatch 移出去const AddTodo = (&#123; store &#125;) =&gt; &#123; let input; return ( &lt;div&gt; &lt;input type=\"text\" ref=&#123;node =&gt; input = node&#125; /&gt; &lt;button onClick=&#123;() =&gt; &#123; if (!input.value) return; store.dispatch(addTodo(input.value)); input.value = ''; &#125;&#125;&gt; addTodo &lt;/button&gt; &lt;/div&gt; );&#125;;const Todo = (&#123; text, onClick, completed &#125;) =&gt; ( &lt;li onClick=&#123;onClick&#125; style=&#123;&#123; textDecoration: completed ? 'line-through' : 'none', cursor: completed ? 'default' : 'pointer', &#125;&#125; &gt; &#123;text&#125; &lt;/li&gt;);const TodoList = (&#123; todos, onTodoClick &#125;) =&gt; ( &lt;ul&gt; &#123;todos.map(todo =&gt; &lt;Todo key=&#123;todo.id&#125; &#123;...todo&#125; onClick=&#123;() =&gt; onTodoClick(todo.id)&#125; /&gt; )&#125; &lt;/ul&gt;);// 容器组件class VisibleTodoList extends Component &#123; // 订阅 store 的变化 componentDidMount() &#123; const &#123; store &#125; = this.props; this.unsubscribe = store.subscribe( this.forceUpdate.bind(this) ); &#125; // 取消订阅 componentWillUnmount() &#123; this.unsubscribe(); &#125; // 根据当前 filter 过滤需要渲染的 todos _getVisibleTodos(todos, filter) &#123; switch (filter) &#123; case 'SHOW_ALL': return todos; case 'SHOW_COMPLETED': return todos.filter(todo =&gt; todo.completed); case 'SHOW_ACTIVE': return todos.filter(todo =&gt; !todo.completed); default: return todos; &#125; &#125; render() &#123; const &#123; store &#125; = this.props; const &#123; todos, filter &#125; = store.getState(); return ( &lt;TodoList todos=&#123;this._getVisibleTodos(todos, filter)&#125; onTodoClick=&#123;id =&gt; &#123; store.dispatch(toggleTodo(id)) &#125;&#125; /&gt; ); &#125;&#125;// 原本的 FilterLink 改成 Link，去掉 filter 和 renderFilter 属性，改为传入 activeconst Link = (&#123; active, onClick, children &#125;) =&gt; &#123; if (active) return (&lt;span&gt;&#123;children&#125;&lt;/span&gt;); return ( &lt;a href='#' onClick=&#123;e =&gt; &#123; e.preventDefault(); onClick(); &#125;&#125;&gt; &#123;children&#125; &lt;/a&gt; );&#125;;// 容器组件class FilterLink extends Component &#123; // 订阅 store 的变化 componentDidMount() &#123; const &#123; store &#125; = this.props; this.unsubscribe = store.subscribe( this.forceUpdate.bind(this) ); &#125; // 取消订阅 componentWillUnmount() &#123; this.unsubscribe(); &#125; render() &#123; const &#123; store, renderFilter, children &#125; = this.props; const &#123; filter &#125; = store.getState(); return ( &lt;Link active=&#123;filter === renderFilter&#125; onClick=&#123;() =&gt; store.dispatch( setVisibilityFilter(renderFilter) )&#125; &gt; &#123;children&#125; &lt;/Link&gt; ); &#125;&#125;// 展示组件const Footer = (&#123; store &#125;) =&gt; ( &lt;p&gt; Show: &#123;' '&#125; &lt;FilterLink store=&#123;store&#125; renderFilter=\"SHOW_ALL\" &gt; all &lt;/FilterLink&gt; &#123;', '&#125; &lt;FilterLink store=&#123;store&#125; renderFilter=\"SHOW_COMPLETED\" &gt; completed &lt;/FilterLink&gt; &#123;', '&#125; &lt;FilterLink store=&#123;store&#125; renderFilter=\"SHOW_ACTIVE\" &gt; active &lt;/FilterLink&gt; &lt;/p&gt;);// 在不使用全局变量 store 的情况下，// 暂时只能通过 props 传递进来，// Don't worry~很快就不会这么麻烦了~const TodoApp = (&#123; store &#125;) =&gt; ( &lt;div&gt; &lt;AddTodo store=&#123;store&#125; /&gt; &lt;VisibleTodoList store=&#123;store&#125; /&gt; &lt;Footer store=&#123;store&#125; /&gt; &lt;/div&gt;); 通过观察重构后的代码可以发现有三点麻烦的地方 根组件需要通过 props 将 store 传给各个子组件 容器组件都要定义 componentDidMount 进行订阅和 componentWillUnmount 取消订阅 应用其实并不需要渲染所有的 todos，所以内部很麻烦地定义了 _getVisibleTodos 函数 4. Provider让我们先来解决第一个麻烦~，利用 React 提供的 context 特性 123456789101112131415class Provider extends Component &#123; // 通过该方法向 children 的 context 注入 store getChildContext() &#123; return &#123; store: this.props.store &#125;; &#125; render() &#123; return this.props.children; &#125;&#125;// 必须要声明传入 context 的 store 的类型Provider.childContextTypes = &#123; store: React.PropTypes.object,&#125;; 自顶向下地看一下如何使用到 TodoApp 中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// 1. 使用 Provider 包裹 TodoApp，并将 store 作为 props 传入ReactDOM.render( &lt;Provider store=&#123;createStore(rootReducer, initialState)&#125;&gt; &lt;TodoApp /&gt; &lt;/Provider&gt;, document.getElementById('container'),);// 2. 根组件 TodoApp: 和 store say goodbye~，// 因为 TodoApp 并不是容器组件~const TodoApp = () =&gt; ( &lt;div&gt; &lt;AddTodo /&gt; &lt;VisibleTodoList /&gt; &lt;Footer /&gt; &lt;/div&gt;);// 3. AddTodo: 由于 props 固定作为第一个传入子组件的参数，// 所以 &#123; store &#125; 要声明在第二位，然鹅需要声明 contextTypes...const AddTodo = (props, &#123; store &#125;) =&gt; &#123; // ...&#125;;// 必须声明AddTodo.contextTypes = &#123; store: React.PropTypes.object,&#125;;// 4. VisibleTodoList: 从 props 改成从 context 中获取 store，// 同样声明 contextTypes...class VisibleTodoList extends Component &#123; // 订阅 store 的变化 componentDidMount() &#123; const &#123; store &#125; = this.context; // props -&gt; context // ... &#125; // ... render() &#123; const &#123; store &#125; = this.context; // props -&gt; context const &#123; todos, filter &#125; = store.getState(); // ... &#125;&#125;// 必须声明VisibleTodoList.contextTypes = &#123; store: React.PropTypes.object,&#125;;// -- TodoList 和 Todo 不变 --// 5. Footer：和 store say goodbye...const Footer = () =&gt; ( &lt;p&gt; Show: &#123;' '&#125; &lt;FilterLink renderFilter=\"SHOW_ALL\"&gt; all &lt;/FilterLink&gt; &#123;', '&#125; &lt;FilterLink renderFilter=\"SHOW_COMPLETED\"&gt; completed &lt;/FilterLink&gt; &#123;', '&#125; &lt;FilterLink renderFilter=\"SHOW_ACTIVE\"&gt; active &lt;/FilterLink&gt; &lt;/p&gt;);// 6. FilterLink: 同 VisibleTodoList（props + contextTypes...）class FilterLink extends Component &#123; // 订阅 store 的变化 componentDidMount() &#123; const &#123; store &#125; = this.context; // props -&gt; context // ... &#125; // ... render() &#123; const &#123; renderFilter, children &#125; = this.props; const &#123; store &#125; = this.context; // props -&gt; context const &#123; filter &#125; = store.getState(); // ... &#125;&#125;// 必须声明FilterLink.contextTypes = &#123; store: React.PropTypes.object,&#125;;// -- Link 不变 -- 现在中间的非容器组件完全不用为了自己的孩子而费劲地传递 store={store}所以以上我们就实现了简化版的由 react-redux 提供的第一个组件 &lt;Provider /&gt;。 然鹅，有木有觉得老写 contextTypes 好烦啊，而且 context 特性并不稳定，所以 context 并不应该直接写在我们的应用代码里。 计将安出？ 5. connect OOP思维：这还不简单？写个函数把容器组件传进去作为父类，然后返回写好了 componentDidMount，componentWillUnmount 和 contextTypes 的子类不就好啦~ 恭喜你~面向对象的思想学的很不错~ 虽然 JavaScript 底层各种东西都是面向对象，然而在前端一旦与界面相关，照搬面向对象的方法实现起来会很麻烦… React 早期用户：这还不简单？写个 mixin 岂不美哉~~？ 作为 react 亲生的 mixin 确实在多组件间共享方法提供了一些便利，然而使用 mixin 的组件需要了解细节，从而避免状态污染，所以一旦 mixin 数量多了之后会越来越难维护。 Unfortunately, we will not launch any mixin support for ES6 classes in React. That would defeat the purpose of only using idiomatic JavaScript concepts. 所以官方也放弃了在 ES6 class 中对 mixin 的支持。 函数式（FP）：高阶组件 High Order Component（下称 hoc）才是终极解决方案~~ hocFactory:: W: React.Component =&gt; E: React.Component 如上所示 hoc 的构造函数接收一个 W（代表 WrappedComponent）返回一个 E（代表 Enhanced Component），而 E 就是这个高阶组件。 假设我们有一个旧组件 Comp，然鹅现在接收参数有些变动。 当然你可以复制粘贴再修改旧组件的代码…（大侠受窝一拜） 也可以这么写，返回一个新组件来包裹旧组件。 123456789class NewComp extends Component &#123; mapProps(props) &#123; return &#123;/* new props */&#125;; &#125; render() &#123; return (&lt;Comp &#123;...this.mapProps(this.props)&#125; /&gt;); &#125;&#125; 然鹅，如果有同样逻辑的更多的组件需要适配呢？？？总不能有几个抄几遍吧… 所以骚年你听说过高阶组件么~？ 12345678910// 先返回一个函数，而那个函数再返回新组件const mapProps = mapFn =&gt; Comp =&gt; &#123; return class extends Component &#123; render() &#123; return (&lt;Comp &#123;...this.mapFn(this.props)&#125; /&gt;); &#125; &#125;;&#125;;const NewComp = mapProps(mapFn)(Comp); // 注意调用了两次 可以看到借助高阶组件我们将 mapFn 和 Comp 解耦合，这样就算需要再嵌套多少修改逻辑都没问题~天黑都不怕~ ok，扯了这么多的淡，终于要说到 connect 了是哒，你木有猜错，react-redux 提供的第二个也是最后一个 api —— connect 返回的就是一个高阶组件。 使用的时候只需要 connect()(WrappedComponent) 返回的 component 自动就完成了在 componentDidMount 中订阅 store，在 componentWillUnmount 中取消订阅和声明 contextTypes。 这样就只剩下最后一个麻烦 3.应用其实并不需要渲染所有的 todos，所以内部很麻烦地定义了 _getVisibleTodos 函数 其实 connect 函数的第一个参数叫做 mapStateToProps，作用就是将 store 中的数据提前处理或过滤后作为 props 传入内部组件，以便内部组件高效地直接调用。这样最后一个麻烦也解决了~ 然鹅，我们问自己这样就够了么？并没有… 还有最后一个细节，以 FilterLink 为例。 12345678910111213141516171819class FilterLink extends Component &#123; // ... render() &#123; const &#123; store, renderFilter, children &#125; = this.props; const &#123; filter &#125; = store.getState(); return ( &lt;Link active=&#123;filter === renderFilter&#125; onClick=&#123;() =&gt; store.dispatch( setVisibilityFilter(renderFilter) )&#125; &gt; &#123;children&#125; &lt;/Link&gt; ); &#125;&#125; 除了从 store 中获取数据（filter），我们还从中获取了 dispatch，以便触发 action。如果将回调函数 onClick 的内容也加到 props 中，那么借助 connect 整个 FilterLink 的逻辑岂不是都被我们抽象完了？ 是哒，connect 的第二个参数叫做 mapDispatchToProps，作用就是将各个调用到 dispatch 的地方都抽象成函数加到 props 中的传给内部组件。这样最后一个麻烦终于真的被解决了~ 12345678910111213141516171819const mapStateToLinkProps = (state, ownProps) =&gt; (&#123; // ownProps 是原组件的 props， // 这里为了和高阶组件的 props 区分 active: ownProps.renderFilter === state.filter,&#125;);const mapDispatchToLinkProps = (dispatch, ownProps) =&gt; (&#123; onClick() &#123; dispatch( setVisibilityFilter(ownProps.renderFilter) ); &#125;,&#125;);// 注意原 FilterLink 整个都被我们删了const FilterLink = connect( mapStateToLinkProps, mapDispatchToLinkProps)(Link); TodoApp 使用 react-redux 四、总结本文从 Redux 的理论基础和源码出发，介绍了 Redux 的各项基础 api。 接着一步一步地介绍如何与 React 进行结合，从过程中的各个痛点引出 react-redux 的作用和原理。 然鹅，还有好多的坑没填，比如：大型项目的文件结构、前端路由（react-router）、中间件（middlewares）、网络请求等各类异步操作、服务器端同构直出… 以上 to be continued…","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://buptsteve.github.io/blog/tags/JavaScript/"},{"name":"Redux","slug":"Redux","permalink":"https://buptsteve.github.io/blog/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://buptsteve.github.io/blog/tags/React/"}]},{"title":"「6」JavaScript 函数表达式学习笔记","date":"2016-03-23T07:27:58.000Z","path":"2016/03/23/006.js-function-chapter7/","text":"零、前言《JavaScript 高级程序设计（第三版）》第7章 函数表达式，学习笔记整理。 主要内容有如下三部分 函数表达式的特征 使用函数实现递归 使用闭包定义私有变量 一、第7章 函数表达式7.0. 函数定义在 JavaScript 中定义函数有两种方法： 函数声明 函数表达式 7.0.1. 函数声明123456function functionName(arg0, arg1, arg2) &#123; // 函数体&#125;// 只在 Firefox、Safari、Chrome 和 Opera 有效alert(functionName.name); // functionName，函数名称 函数声明一个重要特征就是：函数声明提升（function declaration hoisting），简单来说就是 JS 引擎会在执行阶段之前读取函数声明，这就是我们才能够在函数声明之前就调用它的原因。 7.0.2. 函数表达式1234567// 有多种形式，以下为最常见的一种，即创建一个匿名函数并将其赋值给变量 functionNamevar functionName = function(arg0, arg1, arg2) &#123; // 函数体&#125;;// 只在 Firefox、Safari、Chrome 和 Opera 有效alert(functionName.name); // 空字符串 当然函数表达式就没有声明提升这种特征了。以下是一个比较常见的坑… 1234567891011121314151617181920212223242526// 千万别这样做！// 因为有的浏览器会返回 first 的这个 function，而有的浏览器返回的却是第二个if (true) &#123; function foo() &#123; return 'first'; &#125;&#125; else &#123; function foo() &#123; return 'second'; &#125;&#125;foo();// 相反，这样情况，我们要用函数表达式var foo;if (true) &#123; foo = function() &#123; return 'first'; &#125;;&#125; else &#123; foo = function() &#123; return 'second'; &#125;;&#125;foo(); 7.1. 递归 先说个段子：要想理解递归，首先要理解…递归。 说正经的，递归就是函数自己调用自己。 12345678910111213function factorial(num) &#123; // 递归结束条件 if (num &lt;= 1) return 1; // 通过在全局 VO 中，找到自身函数的指针后调用自身 return num * factorial(num-1);&#125;var anotherFactorial = factorial;factorial = null;// 报错！因为修改了全局 VO 中 factorial 指针的指向（null）alert(anotherFactorial(4)); 这么写主要问题就是递归函数与自身的函数名耦合，一旦修改了原本的函数名，则会导致错误。 这时可以利用 arguments.callee 指针来成功寻找到正在执行的函数。 接下来又有一个坑：arguments 在严格模式下无法使用。 不过我们可以使用命名函数表达式来完美解决： 123456789var factorial = function f(num) &#123; // 递归结束条件 if (num &lt;= 1) return 1; // 函数名 f 只在内部作用域里有效 return num * f(num-1);&#125;;typeof f; // undefined 7.2. 闭包 先下定义：闭包是指【有权】访问（另一个函数作用域）中的「变量」的「函数」。 闭包首先是一个函数 能力就是有权访问变量 范围在另一个函数作用域内 我们日常在使用 JavaScript 中，在外部函数中定义的内部函数能够访问外部函数中的变量。 所以，最常见的闭包方式就是在一个函数内部创建并返回另一个函数。 12345678910function foo(arg0, arg1) &#123; return function bar() &#123; // 内部的 bar 函数能够访问外部函数 foo 的 arg0 和 arg1 变量。 return arg0 + arg1; &#125;&#125;var test = foo('a', 'b'); // test 是一个指针，指向返回的 bar 函数test(); // ab，调用闭包后，得到 arg0 + arg1 的值typeof bar; // undefined，当然返回的是一个匿名函数 那么内部的 bar 函数是怎么保存外部 foo 函数的两个参数的呢？ 首先在浏览器端的 JavaScript 代码，有一个全局的执行环境（Execution Context）即 window 对象。 每个执行环境都有一个对应的变量对象（Variable Object）：定义的所有变量和函数都保存其中。 当某个函数被调用时，会创建一个执行环境（EC）及相应的作用域链（Scope Chain）（其实是被推入一个环境栈中，执行之后栈将之弹出）。 作用域链（SC）就是一个指向各个变量对象的指针列表（全局 VO 是其中的最后一个对象）。 一般来说某个执行环境（EC）的所有代码执行完毕后，该环境被销毁，保存其中的所有变量和函数定义也随之销毁。 如果执行环境是一个函数，那么它的变量对象（VO）又叫做活动对象（Activation Object）。 因此在一个函数中解析标识符的过程，类似于上一篇中提到的原型链查找。也是沿着 SC 一级一级地往上找。如果直到全局 VO 还没找到，就会报错。 所以接下来举几个栗子： 1. 普通函数12345678function compare(value1, value2) &#123; if (value1 &lt; value2) return -1; if (value1 &gt; value2) return 1; return 0;&#125;var result = compare(5, 10); 1234567891011121314 ______________________________________________________________ | | V _____________________ | _____________________ _________________ |--&gt; | global VO | | |---&gt;| compare AO || compare EC | | |---------------------| | | |---------------------||-------—---------| _______ | | compare | *----|--| | | arguments | [5, 10] || Scope Chain | *-|----&gt; | SC | | |---------------------| | |---------------------||-----------------| |-------| | | result | undefined | | | value1 | 5 | | 1 | *-|----| |---------------------| | |---------------------| |-------| | | value2 | 10 | | 0 | *-|----------------------------------------| |---------------------| |-------| by 灵魂画师...(累死我了) 在创建 compare 函数时，就已经创建一个预先包含全局 VO 的作用域链（保存在内部的 [[Scope]] 属性中）。 在执行 compare 函数时，就创建 EC，然后复制并构建 [[Scope]] 属性中的作用域链 SC 此时创建 compare AO，并将其放入 SC 的顶端。 所以在函数中访问一个变量时，会从作用域顶端（就是 compare AO）开始找起。 所以一般一个函数执行完毕后，因为 AO 被销毁，所以在函数外部无法访问到函数内部的变量。 2. 闭包示例123456789101112131415161718192021function createCompFunc(propName) &#123; return function(obj1, obj2) &#123; var value1 = obj1[propName]; var value2 = obj2[propName]; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;&#125;var compare = createCompFunc(\"name\"); // 创建函数var result = compare(&#123;name: \"steve\"&#125;, &#123;name: \"young\"&#125;); // 调用函数compare = null; // 解除对匿名函数的引用（释放内存） 1234567891011121314151617181920212223242526 __________________________________________________________________ | _____________________ | | |-----&gt; | global VO | | | | |---------------------| | | | | createCompFunc | *--|--| | | |---------------------| V | | result | undefined | ___________________ _______ | |---------------------|| createCompFunc EC | |---&gt; | SC1 | | ______________________|-------—-----------| | |-------| | |---&gt; | createCompFunc AO || Scope Chain | *--|------| | 1 | *-|-| | |----------------------||-------------------| |-------| | | | arguments | [&quot;name&quot;] | | 0 | *-|-(-| |----------------------| ________________________ |-------| | | | propName | &quot;name&quot; || anoymous function EC | | | |----------------------||-------—----------------| _______ | | _______________________________| Scope Chain | *-----|-----&gt; | SC2 | | | |-&gt; | anoymous function AO ||------------------------| |-------| | | | |-------------------------------| | 2 | *-|-| | | | arguments | [&#123;name: &quot;steve&quot;&#125;, | |-------| | | | | &#123;name: &quot;young&quot;&#125;] | | 1 | *-|---| | |-------------------------------| |-------| | | obj1 | &#123;name: &quot;steve&quot;&#125; | | 0 | *-|-----| |-------------------------------| |-------| | obj2 | &#123;name: &quot;young&quot;&#125; | |-------------------------------| by 灵魂画师...(累死我了) 如图所示，首先看全局变量对象（global VO），其中有一个指针指向 createCompFunc 函数，还有一个声明提升后还未计算完毕的 result 等变量。 首先执行外部的 createCompFunc 函数，创建了它的 EC，其中有一个作用域链指针指向它的作用域链 SC1。 那么显然 SC1 中会有两个指针，分别指向 createCompFunc AO 和 global VO（这就是在函数内部能够访问到全局变量的原因）。 在 createCompFunc AO 中存放的就是函数内部定义的变量。 最后来看 createCompFunc 函数内部返回的匿名函数，当然它也有自己的执行环境 EC，也有自己的作用域链 SC2。 只不过由于它是 createCompFunc 函数内部的函数，当然它也能访问外部 createCompFunc 函数定义的变量，这正是因为 SC2 中位于第二的指针指向 createCompFunc AO（这就是闭包的原理）。 更为重要的是，在 createCompFunc 函数执行完毕后，因为匿名函数仍然引用着 createCompFunc AO，所以其活动对象不会被销毁（这涉及到内存回收机制）。 从上述讨论我们可以清晰地看出：闭包的原理就是内部的函数仍然引用着外部函数的 AO，使得外部函数的 AO 仍然保存在内存中。所以我们可以通过将闭包设置为 null 来解除对该函数的引用，回收其占用的内存。 7.2.1. 闭包与变量下面我们来简单讨论下作用域链机制的副作用（坑）：闭包只能取得外部函数中任何变量的最后一个值。 先来看一个栗子： 1234567891011121314function createFunc() &#123; var result = []; for (var i = 0; i &lt; 10; i++) &#123; result[i] = function() &#123; return i; // 希望保存不同的 i，但是最后 i 都是 10 &#125;; &#125; return result;&#125;var test = createFunc();alert(test[0]()); // 10 其实很好理解，因为闭包在 SC 中保存的是一个指针而已，外部函数执行完毕后 AO 中的变量自然更新为最后一个值啦╮(╯▽╰)╭。 但是我们可以创建另一个立即执行的匿名函数强制让闭包的行为符合预期： 12345678910111213141516function createFunc() &#123; var result = []; for (var i = 0; i &lt; 10; i++) &#123; result[i] = function(num) &#123; return function() &#123; return num; &#125; &#125;(i); &#125; return result;&#125;var test = createFunc();alert(test[0]()); // 0 在这里我们相当于有3层函数。 中间那层的匿名函数有一个参数 num，我们将 i 传入立即执行。 因为简单类型是按值传递的，所以中间那层的匿名函数的 AO 中 num 保存的是不同的 i。 而最内层的匿名函数读取的正是中间层匿名函数的 AO。 7.2.2. 关于 this 对象我们知道，this 是在运行时根据函数的执行环境动态绑定的： 在全局函数中，this 等于 window。 而函数被作为某个对象的方法调用时，this 又指向那个对象。 使用 call() 和 apply() 方法时，this 又会指向传入的那个对象（还有 bind()）。 不过，匿名函数的执行环境具有全局性，因此内部的 this 通常指向 window，见下例： 12345678910111213var name = \"The Window\";var object = &#123; name: \"My Object\", getNameFunc: function() &#123; return function() &#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); // The Window (非严格模式下)，此处有两个括号，因为 object.getNameFunc() 是一个匿名函数，后一个括号是匿名函数调用。 为什么匿名函数没有取得其包含作用域（或外部作用域）的 this 对象呢？ 前面曾经提到过，每个函数在被调用时都会自动取得两个特殊变量：this 和 arguments。而内部函数在搜索这两个变量时，只会搜索到其 AO 为止，所以永远不能直接访问到外部函数中的 this 和 arguments。 不过若是我们将外部作用域中的 this 对象保存在一个闭包能够访问到的变量里，就可以让闭包访问到该对象了： 123456789101112131415var name = \"The Window\";var object = &#123; name: \"My Object\", getNameFunc: function() &#123; var that = this; // 使用 that 保存外部函数的 this（防止被内部函数的 this 屏蔽） return function() &#123; return that.name; // 由于访问的是内部 AO 中没有的变量 that，所以在 SC 中外部的 AO 上搜索，得到外部函数的 this。 &#125;; &#125;&#125;;alert(object.getNameFunc()()); // My Object 接下来再看几个特殊的栗子： 123456789101112131415var name = \"The Window\";var object = &#123; name: \"My Object\", getName: function() &#123; return this.name; &#125;&#125;;object.getName(); // My Object，很好理解 this 就是指向 object(object.getName)(); // My Object，将函数包了起来，但还是通过 object.getName 调用，this 还是指向 object(object.getName = object.getName)(); // The Window(非严格模式下)，看起来很奇怪，将函数 getName 赋值为 getName，再调用赋值后的结果// 因为赋值表达式操作的是 getName 函数本身，所以 this 的值没有得到维持，调用时指向了 widnow。 7.2.3. 内存泄漏因为 IE9 之前对于 JScript 对象和 COM 对象使用不同的垃圾收集机制。所以如果闭包的作用域中保存一个 HTML 元素，那么该元素将无法被销毁╮(╯▽╰)╭。 7.3. 模仿块级作用域我们都知道在 ES6 之前是木有块级作用域的╮(╯▽╰)╭，在块语句中定义的变量实际上是定义在函数 AO 上的。 如果实在需要块级作用域，可以通过立即执行函数进行模拟。 1234// 这只是其中一种写法...重点是不要使用函数声明，这样由于声明提升会报错。(function() &#123; // 这里是块级作用域&#125;)(); 在一个大型程序中过多的全局变量和函数很容易造成命名冲突，这样可以有效减少在全局作用域中添加变量和函数。也可以说是模块化的基础。ps jQuery 源码中最外层函数就是这样的一个立即执行函数… 7.4. 私有变量严格来说，JavaScript 中没有私有成员的概念…╮(╯▽╰)╭，不过在任何函数中定义的变量，外部都无法访问到，可以认为是私有变量。 私有变量包括： 函数的参数 局部变量 内部定义的其他函数 那么如果我们需要访问这些私有变量该怎么办呢？在此就要引入一个概念：特权方法（privileged method）有权访问私有变量和私有函数的公有方法。 这个概念是不是和闭包炒鸡像！？ 其实有两种在对象上创建特权方法的方式，第一种就是利用闭包在构造函数中定义特权方法。基本模式如下： 123456789101112131415function MyObject() &#123; // 私有变量和函数 var privateVar = 10; function privateFunc() &#123; return false; &#125; // 特权方法 this.publicMethod = function() &#123; privateVar++; return privateFunc(); &#125;;&#125; 但是，这样定义特权方法有一个问题：必须使用构造函数模式。而之前已经讨论过了构造函数会为每个实例都创建一组新方法，浪费内存，而接下来介绍的第二种方法，使用静态私有变量就可以避免这个问题。 7.4.1. 静态私有变量基本思想就是：在私有作用域（立即执行函数）中定义私有变量或函数，并在内部通过函数表达式定义构造函数和它的公有方法。基本模式如下： 12345678910111213141516171819(function() &#123; // 私有变量和私有函数 var privateVar = 10; function privateFunc() &#123; return false; &#125; // 构造函数 MyObject = function() &#123;&#125;; // 没有使用 var，所以是在 window 上创建（所以是非严格模式下）。 // 公有/特权方法 MyObject.prototype.publicMethod = function() &#123; privateVar++; return privateFunc(); &#125;;&#125;)(); 显然，通过上一篇对于对象继承的讨论我们知道：定义在原型对象上的属性和方法是所有实例共享的，而这些方法（如 publicMethod）所操作的对象，即私有变量和函数也是同一个。所以通过 MyObject 构造函数创造的实例都有权访问私有变量（而且是同一个），这就是静态私有变量。 7.4.2. 模块模式模块模式（module pattern）是为「单例」创建私有变量和特权方法。 那么问题来了，单例是啥？ 单例（singleton）指的就是只有一个实例的对象。比如 JavaScript 中就是以对象字面量来创建单例对象的。 123456var singleton = &#123; name : value, method: function() &#123; // 方法的代码 &#125;&#125;; 模块模式通过为单例添加私有变量和特权方法使其得到增强： 1234567891011121314151617181920var singleton = function() &#123; // 私有变量和私有函数 var privateVar = 10; function privateFunc() &#123; return false; &#125; // 公有/特权方法 return &#123; publicProperty: true, publicMethod: function() &#123; privateVar++; return privateFunc(); &#125;; &#125;;&#125;(); 如上面代码所示，模块模式就是使用了一个返回对象的匿名函数： 在函数内部定义了私有变量和函数 然后将对象字面量返回。 因为对象是函数内部定义的，所以它的方法是一个闭包。 模块模式的应用场景主要是在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的。 7.4.3. 增强的模块模式应用场景：单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其进行加强的情况。 12345678910111213141516171819202122var singleton = function() &#123; // 私有变量和私有函数 var privateVar = 10; function privateFunc() &#123; return false; &#125; // 创建对象 var object = new CustomType(); // 添加公有/特权属性和方法 object.publicProperty = true; object.publicMethod = function() &#123; privateVar++; return privateFunc(); &#125;; return object;&#125;(); 7.5. 小结1. 在 JavaScript 中，使用函数表达式可以无须对函数命名，从而实现动态编程，还有强大的匿名函数，以下是函数表达式的特点： 函数声明必须要有名字，还会声明提升，而函数表达式不需要，没有名字的函数表达式又叫匿名函数 在递归函数中使用函数名调用自身可能会出现问题，如函数名发生了变化。 在递归函数中要掌握调用函数自身的技巧，如 arguments.callee 等。 2. 闭包：在外部函数中又定义了一个内部函数，这个内部函数有权访问外部函数的所有变量，原理如下： 在 JavaScript 引擎执行时，闭包的 SC 包含了自己的 AO、外部函数的 AO 还有全局 VO。 通常，函数的作用域和所有变量会在函数执行后被销毁。 但是，当函数返回了一个闭包时，外部函数的 AO 会一直保存在内存中，直到解除闭包的引用，如设为 null。 3. 使用闭包可以模仿块级作用域： 立即执行函数既可以执行其中的代码，又不会在内存中留下对该函数的引用。 所以函数内部的所有变量都会被立即销毁，除非将某些变量赋值给外部作用域中的变量。 4. 闭包还可以用于在对象中创建私有变量： 函数内部的变量、方法，外部无法访问。 但通过闭包可以实现公有方法，即访问在包含作用域中定义的变量。 有权访问私有变量的公有方法叫做特权方法。 可以使用构造函数模式、原型模式来实现自定义类型的特权方法。 也可以使用模块模式、增强模块模式来实现单例的特权方法。 综上：JavaScript 中函数表达式和闭包都是很给力的特性。不过，因为创建闭包必须维护额外的作用域，所以过度使用可能会占用大量内存。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://buptsteve.github.io/blog/tags/JavaScript/"}]},{"title":"「5」JavaScript 面向对象深入理解","date":"2016-03-17T08:27:58.000Z","path":"2016/03/17/005.js-oo-chapter6/","text":"零、前言最近为了找暑假实习，正在恶补基础，仔细研读了《JavaScript 高级程序设计（第三版）》第6章 面向对象的程序设计。感觉收获颇多，在此献丑分享一点儿自己的理解。 同样按照书本的顺序分为如下三部分 理解对象属性 理解并创建对象 理解继承 一、第6章 面向对象的程序设计6.1. 理解对象ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”简单来说，对象就是一些名值对（Key-Value），而对象的名字就是一个指针。 6.1.1. 属性类型ECMAScript 中有两种属性：数据属性和访问器属性。 6.1.2. 数据属性 [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性，默认为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性，以及 console.log 时是否显示，默认为 true。 [[Writable]]：表示能否修改属性的值，默认为 true。 [[Value]]：包含这个属性的数据值，默认为 undefined。 要修改以上属性，必须使用 ES5 中的 Object.defineProperty()。 12345678910111213141516171819202122232425// 例1var person = &#123;&#125;;Object.defineProperty(person, \"name\", &#123; writable: false, value : \"steve\"&#125;);alert(person.name); // steveperson.name = \"abc\";alert(person.name); // steve// 例2var person = &#123;&#125;;Object.defineProperty(person, \"name\", &#123; configurable: false, value : \"steve\"&#125;);// 抛出错误Object.defineProperty(person, \"name\", &#123; configurable: true, value : \"steve\"&#125;); ps 在调用 Object.defineProperty() 方法时，默认值为 false(就是说其他没写的属性都是 false)。 6.1.3. 访问器属性访问器属性不包括数据值(Value)，取而代之的是一对儿 getter 和 setter 函数(非必须)。 [[Configurable]]：表能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性，默认为 true。 [[Enumerable]]：表能否通过 for-in 循环返回属性，以及 console.log 时是否显示，默认为 true。 [[Get]]：在读取属性时调用的函数，默认为 true。 [[Set]]：在写入属性时调用的函数，默认为 undefined。 访问器属性不能直接定义，必须使用 Object.defineProperty() 来定义。 1234567891011121314151617181920var book = &#123; _year : 2004, edition: 1&#125;;Object.defineProperty(book, \"year\", &#123; get: function() &#123; return this._year; &#125;, set: function(newValue) &#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;alert(book.edition); // 2 ps 如果只定义了两个方法的其中之一，那么另一种方式则无法使用，例如只定义了 getter，则属性不可写。 6.1.4. 定义多个属性12345678910111213141516171819202122var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2004 &#125;, year: &#123; get: function() &#123; return this._year; &#125;, set: function(newValue) &#123; if (newValue &gt; 2004) &#123; this._year = newValue; &#125; &#125; &#125;&#125;);book.year = 2005;alert(book.edition); // 2 6.1.5. 读取属性的特性12345var desc = Object.getOwnPropertyDescriptor(book, \"_year\");alert(desc.value); // 2004alert(desc.configurable); // falsealert(typeof desc.get); // undefined 6.2. 创建对象使用 Object 构造函数和字面量创建对象，会产生大量重复代码，所以以下代码重用机制应运而生。 6.2.1. 工厂模式特点：使用函数封装特定接口创建对象的细节。 简单来说就是在函数的内部创建对象，为其添加属性和方法后，用 return 返回，在实例化时不使用 new 操作符。 12345678910111213141516function createPerson(name, age, job) &#123; var o = &#123; name: name, age : age, job : job, sayName: function() &#123; alert(this.name); &#125; &#125;; return o;&#125;var person1 = createPerson(\"steve\", 24, \"fe\");var person2 = createPerson(\"young\", 25, \"fs\"); 问题：没有解决对象识别的问题（即怎样知道一个对象的类型），重复构造相同的方法造成内存浪费，也无法进行继承复用。 6.2.2. 构造函数模式特点：在构造函数中使用 this 对象在运行时基于函数的执行环境动态绑定，使用 new 操作符实例化。 ps 通过 new 关键字方式调用的函数都被认为是构造函数。 123456789101112131415function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name); &#125;;&#125;var person1 = new Person(\"steve\", 24, \"fe\");var person2 = new Person(\"young\", 25, \"fs\");alert(person1.constructor === Person); // truealert(person2.constructor === Person); // true 1. 与工厂模式的不同之处 没有显式地创建对象 直接将属性和方法赋值给了 this 对象 没有 return 语句 2. 必须使用 new 操作符创建新实例这个过程经历以下4个步骤： 创建一个新对象 将构造函数的作用域赋给新对象（this 指向新对象） 执行构造函数中的代码（为之添加属性） 返回新对象 这种方式胜过工厂模式的地方就在于：可以将实例标识为一种特定的类型。 3. 构造函数当作普通函数既然实例化需要使用 new 操作符，万一不使用又会怎么样的？ 123456789101112// 当作构造函数使用var person = new Person(\"steve\", 24, \"fe\");person.sayName(); // steve// 当作普通函数使用Person(\"young\", 24, \"fe\"); // 添加到 window 对象中window.sayName(); // young// 在另一个对象的作用域中调用var o = new Object();Person.call(o, \"sasuke\", 24, \"fe\");o.sayName(); // sasuke 4. 构造函数的问题每个方法有独立的内存，造成浪费。 1234567891011121314alert(person1.sayName == person2.sayName); // false// 虽然可以把函数定义转移到构造函数外function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = sayName;&#125;function sayName() &#123; alert(this.Name);&#125; 虽然这样将其设置成了全局函数，但是新问题就是：全局函数却只能被某个对象调用，并且如果需要定义很多方法，就需要定义很多全局函数，也就是说毫无封装性可言。 6.2.3. 原型模式首先我们要知道每一个函数都有一个属性叫做 prototype，这个属性是一个指针，指向函数的原型对象。 原型对象的用途：包含可以由特定类型的「所有实例」[共享]的属性和方法。 换句话来说就是：所有对象实例可以一起通过这个 prototype 来共享属性和方法～。 12345678910111213141516171819function Person() &#123;&#125;// 属性Person.prototype.name = \"steve\";Person.prototype.age = 24;Person.prototype.job = \"Web Developer\";// 方法Person.prototype.sayName = function() &#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); // stevevar person2 = new Person();person2.sayName(); // stevealert(person1.sayName === person2.sayName); // true 共享同一个方法 1. 深入理解原型对象 只要是函数，都有一个 prototype 指针，指向原型对象。 而原型对象默认会自动获得一个 constructor 指针，指向上一条中的函数。（你指我？我也指你→_→） 调用构造函数创建一个新实例后，实例内部也会获得一个 [[prototype]] 指针（ES5 中这么叫），指向原型对象（不是创造它的构造函数！）。 下面进行详细说明： 第一条很好理解，当作大自然的规律来记就好啦，你否认也没用… 第二条就是说原型对象与一般的对象最大的不同就是这个 constructor 指针，所以在重写构造函数的 prototype 时，要想与之前的原型对象保持一致，最好也加上这个 constructor 指针（显得专业嘛～）。 第三条，其实在 Firefox、Safari 和 Chrome 中，[[prototype]] 就是 __proto__ 指针。 ps 无论有没有 __proto__ 指针，我们都可以通过 isPrototypeOf() 方法来确定对象之间是否存在原型关系。（Person.prototype.isPrototypeOf(person1) // true） pps ES5 中增加了一个新方法 Object.getPrototypeOf() （Object.getPrototypeOf(person1) === Person.prototype // true） 总结一下就是：构造函数有指向原型对象的指针(prototype)，原型对象也有指向构造函数的指针(constructor)，实例同样也有指向原型对象的指针([[prototype]]) 那么这玩意儿搞这么复杂有啥用咧…? 简单举个栗子，上文中 6.2.3.原型模式一节中的两个实例(person1,person2)并不包含任何属性和方法，但是我们仍然可以调用 person1.sayName() 方法，这就是通过查找对象属性的过程实现的。 还有我们经常使用的各种数组方法(slice,splice,sort…)，同样也是定义在 Array.prototype 这个对象上的。 其实每当读取某个对象的某个属性时，都会执行一次搜索，目标就是给定的属性名。首先当然先搜索对象实例自身，如果没找到再继续搜索 [[prototype]] 指针指向的原型对象，如果找不到再向上查找… 所以实例的属性可以“屏蔽“原型链上的同名属性。（通过 delete 可以删除实力属性，消除屏蔽） a. 如何判断属性属于实例还是原型链？很简单，使用 hasOwnProperty() 犯法。 b. 如果原型链上也没有咋办？还记得 JavaScript 中的数据类型么，不平凡的那个引用类型 Object。我们使用的 Array、Function、Date、RegExp… 都是由 Object 派生而成。换句话说他们的原型对象都指向了 Object.prototype。最后 Object.prototype 又指向了 null。 所以如果寻找属性直到 Object.prototype 中都没有，从而找到 null。那么 JS 引擎就会抛出 undefined。 2. 原型与 in 操作符in 操作符用来判断对象能否访问给定属性（前提是 enumerable 为 true），有两种方法使用 in 操作符： 单独使用 在 for-in 循环中使用 但由于 in 操作符不区分实例和原型链，所以日常使用中需要结合 hasOwnProperty() 方法 1234function hasPrototypeProperty(object, name) &#123; // 判断是否是原型链上的属性 return !object.hasOwnProperty(name) &amp;&amp; (name in object);&#125; 此外要取得对象上所有可枚举的实例属性，可以用 ES5 中的 Object.keys() 方法（返回数组）。 当然如果要取得所有实例属性，无论是否可枚举，可以用 Object.getOwnPropertyNames() 方法。 3. 更简单的原型方法日常使用中，每当要为原型对象添加一个属性或方法，都要敲一遍 Person.prototype，这样太不优雅了… 所以一般采用对象字面量将属性和方法都包起来。 12345678910111213function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, // 别忘了之前说过的 constructor 指针。 name: \"steve\", age : 24, job : \"Web Developer\", sayName: function() &#123; alert(this.name); &#125;&#125;; 但是，如果你是个完美主义者，还有一点要注意：原生 constructor 属性是不可枚举的，所以可以用 Object.defineProperty() 将其改写回来。 123456789101112131415161718function Person() &#123;&#125;Person.prototype = &#123; name: \"steve\", age : 24, job : \"Web Developer\", sayName: function() &#123; alert(this.name); &#125;&#125;;Object.defineProperty(Person.prototype, \"constructor\", &#123; enumerable : false, // 默认值，其实可以不写 writable : true, configurable: true, value : Person&#125;); 4. 原型的动态性略，只要你了概（解）了指针是咩（什么）就大丈夫（没问题）。 5. 原型对象的原型略，大概内容就是说了下俺们原生的对象和乃们“野生”对象一样也是有原型的╮(╯▽╰)╭。 6. 原型对象的问题问题其实是来自于自身共享的本性。 例如，包含引用类型的属性。由于引用类型实际上就是指针，所以所有实例操作的都是同一个引用对象，见下例： 1234567891011121314151617181920212223function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, name : \"steve\", age : 24, job : \"Web Developer\", friends: [\"shirley\", \"jame\"], sayName: function() &#123; alert(this.name); &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.friends.push(\"van\");alert(person1.friends); // [\"shirley\", \"jame\",\"van\"]alert(person2.friends); // [\"shirley\", \"jame\",\"van\"]alert(person1.friends === person2.friends); // true 6.2.4. 组合使用构造函数模式和原型模式经过上文的讨论我们知道： 构造函数模式可以为每个实例生成单独的属性，但无法共享。 原型模式可以共享，但无法为实例生成单独的属性。 既然构造函数模式和原型模式的优缺点正好互补，那么为何不将两者结合，发挥各自的长处？ 组合模式就是基于这一朴素的思想： 构造函数用于定义实例属性 原型模式用于定义共享的属性和方法 这样一来，每个实例都有自己的实例属性副本，但同时又共享着原型对象中的方法和属性，最大限度地节省了内存，还支持向构造函数中传递参数，可谓博采众长也～=￣ω￣=～。 123456789101112131415161718192021222324function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = [\"shirley\", \"jame\"];&#125;Person.prototype = &#123; constructor: Person, sayName: function() &#123; alert(this.name); &#125;&#125;;var person1 = new Person(\"steve\", 24, \"Web Developer\");var person2 = new Person(\"nicholas\", 29, \"Soft Engineer\");person1.friends.push(\"van\");alert(person1.friends); // [\"shirley\", \"jame\",\"van\"]alert(person2.friends); // [\"shirley\", \"jame\"]alert(person1.friends === person2.friends); // falsealert(person1.sayName === person2.sayName); // true 6.2.5. 动态原型模式本质其实还是组合模式，只不过把原型对象中共享的属性和方法，也封装在构造函数里… 1234567891011121314151617181920212223function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = [\"shirley\", \"jame\"]; if (typeof this.sayName != \"function\") &#123; // 不能使用对象字面量 Person.prototype = &#123;...&#125;; Person.prototype.sayName = function() &#123; alert(this.name); &#125;; &#125;&#125;var person1 = new Person(\"steve\", 24, \"Web Developer\");var person2 = new Person(\"nicholas\", 29, \"Soft Engineer\");person1.friends.push(\"van\");alert(person1.friends); // [\"shirley\", \"jame\",\"van\"]alert(person2.friends); // [\"shirley\", \"jame\"]alert(person1.friends === person2.friends); // falsealert(person1.sayName === person2.sayName); // true 6.2.6. 寄生构造函数模式首先一般来说，组合模式已经足够应付日常需求，所以这个模式是为了应对特殊需求：例如我们需要创建一个具有额外方法的特殊数组，但是不能直接修改 Array 的构造函数（见下例）。 具体形式上除了使用 new 操作符创建实例以外，和工厂模式一毛（模）一样（同样的问题）。 1234567891011121314151617function SpecialArray() &#123; // 内部创建一个新数组 var values = new Array(); // 添加值 values.push.apply(values, arguments); // 添加方法 values.toPipedString = function() &#123; return this.join(\"|\"); &#125;; return values;&#125;var colors = new SpecialArray(\"red\", \"blue\", \"green\"); // 注意：使用 new 创建实例alert(colors.toPipedString()); // red|blue|green 这个模式其实利用了构造函数的特性： 如果被调用的函数没有显式的 return 表达式，则隐式地会返回 this 对象 - 也就是新创建的隐式对象。 显式的 return 表达式将会影响返回结果，但仅限于返回的是一个对象。 1234567891011121314151617function Foo() &#123; return 2;&#125;function Bar() &#123; return new Number(2);&#125;new Foo().constructor === Number // false，返回新创建的隐式对象new Bar().constructor === Number // true，返回 Number 对象function Test() &#123; this.value = 2; return &#123; foo: 1 &#125;;&#125;console.log(new Test()); // &#123;foo: 1&#125;，返回的对象，this 对象被销毁了，value 丢失了 6.2.7. 稳妥构造函数模式首先要介绍 Douglas Crockford 发明的「稳妥对象」(durable objects) 这个概念：没有公共属性，而且方法也不引用 this 的对象。 主要用在需要安全的环境（禁止 this 和 new），或者在防止数据被其他程序（如 Mashup）改动时使用。 1234567891011121314151617function Person(name, age, job) &#123; //创建要返回的对象 var o = new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayName = function() &#123; alert(name); // 注意：这里没有使用 this，因此我的理解是相当于闭包，保存住了外部 Person 的 AO（活动对象） &#125;; //返回对象 return o;&#125;var person = Person(\"steve\", 24, \"web developer\");person.sayName(); //\"steve\" 这里变量 person 中保存的就是一个稳妥对象，因为除了调用 sayName() 方法以外，没有别的方法可以访问内部的数据。 即使有其他代码会给这个对象添加方法或数据，也无法访问传入到构造函数中的原始数据。 6.3. 继承许多面向对象的编程语言都支持两种继承方式： 接口继承：只继承方法签名 实现继承：继承实际的方法 在 ECMAScript 中由于函数没有签名，所以无法实现接口继承，只支持实现继承，而这正是依靠「原型链」来实现的。 6.3.1. 原型链既然这继承的关键在于「原型链」，我们就先来了概（解）下原型链的概念究竟是神马… 基本思想：利用 prototype（原型对象），让一个引用类型继承另一个引用类型的属性和方法。 简单回顾一下之前讨论过的关于，构造函数、原型对象和实例的关系： 每个构造函数都有一个指向自己原型对象的 prototype 指针。 原型对象又都包含一个指向构造函数的 constructor 指针。 实例都包含一个指向原型对象的 [[prototype]] 内部指针（__proto__）。 假如我们让「原型对象」等于另一个类型的「实例」，结果会是怎样的呢？ 123456function foo() &#123;&#125;function bar() &#123;&#125;var a = new foo(); // a 是父类 foo 的实例bar.prototype = a; // 「原型对象 bar.prototype」等于另一个类型的「实例 a」var b = new bar(); // b 是子类 bar 的实例 简单分析一下以上代码： 「1」a 作为 foo 的实例，a 的内部指针 [[prototype]] 指向原型对象 foo.prototype。 「2」bar.prototype 被赋值为 a，所以相当于 bar.prototype 有内部指针 [[prototype]] 指向原型对象 foo.prototype。 「3」b 作为 bar 的实例，b 的内部指针 [[prototype]] 指向原型对象 bar.prototype。 「4」综上，这样便形成了一条：b -&gt; bar.prototype -&gt; foo.prototype 的原型链。 「5」假如另一个原型又是另一个类型的实例，那么上述关系仍然成立，如此层层递进，可以生成更长的原型链。 以上就是原型链的基本概念… 下面再来看看一种实现原型链的基本模式 12345678910111213141516171819202122function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;;function SubType() &#123; this.subproperty = false;&#125;SubType.prototype = new SuperType(); // 注意：使用 new 生成父类实例，重写了原型对象// 必须后添加方法（不然方法就加到之前的对象上去了_(:зゝ∠)_，要理解指针）SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;;var instance = new SubType();alert(instance.getSuperValue()); // true，成功继承父类原型对象上的方法alert(instance.constructor); // SuperType，因为访问的是 Super.prototype 中的 constructor 1. 别忘记默认的原型其实，所有的引用类型都默认继承自 Object，而这个继承也是通过原型链实现的。所以所有自定义类型都能够使用 toString()、valueOf() 等方法。 2. 确定原型和实例的关系有两种方法确定原型和实例的关系： instanceof 操作符 isPrototypeof() 方法 1234567alert(instance instanceof Object); // truealert(instance instanceof SuperType); // truealert(instance instanceof SubType); // truealert(Object.prototype.isPrototypeof(instance)); // truealert(SuperType.prototype.isPrototypeof(instance)); // truealert(SubType.prototype.isPrototypeof(instance)); // true 3. 谨慎地定义方法子类型有时候需要覆盖超类型的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后，这点很好理解。 还要注意以下这种使用对象字面量创建原型方法的情况。 1234567891011121314// blabla...SubType.prototype = new SuperType(); // 注意：使用 new 生成父类实例，重写了原型对象// 隐式地创建了一个新对象，改写了 SubType.prototype 的指针指向SubType.prototype = &#123; getSubValue: function() &#123; return this.subproperty; &#125;, someOtherMethod: function() &#123; return false; &#125;&#125;; 4. 原型链的问题 引用类型属性的问题：相当于将父类属性添加到子类原型对象上形成共享。 创建子类实例时，不能向超类型的构造函数中传递参数：准确的说是无法在不影响所有对象实例的情况下，给父类的构造函数传递参数。 6.3.2. 借用构造函数在解决原型链以上问题的过程中，产生了一种叫做「借用构造函数（伪造对象、经典继承）」的技术。 基本思想是：在子类构造函数内部调用父类构造函数，主要通过 call() 和 apply() 方法实现。 1. 传递参数相对于原型链而言，借用构造函数最大的优势就是解决了传递参数的问题。 12345678910111213function SuperType(name) &#123; this.name = name;&#125;function SubType() &#123; SuperType.call(this, 'steve'); this.age = 24;&#125;var instance = new SubType();alert(instance.name); // stevealert(instance.age); // 24 2. 借用构造函数的问题源自于构造函数的问题：方法都在构造函数中定义，无法函数复用，子类方法也无法使用父类原型对象中的方法。 6.3.3. 组合继承顾名思义，就是将原型链和借用构造函数结合。 12345678910111213141516171819function SuperType(name) &#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function() &#123; return this.name;&#125;;function SubType(name, age) &#123; // 借用构造函数继承属性 SuperType.call(this, name); this.age = age;&#125;// 使用原型链继承了方法SubType.prototype = new SuperType(); 虽然看起来结合了两者的优点，既能够传递参数，又能实现原型链继承，但是应该注意到 SubType.prototype = new SuperType(); 一句。 我们的预期只是子类 SubType 拥有父类的属性，即 SuperType.call(this, name); 的工作。 但是 SubType.prototype 上也拥有了一个值为 undefined 的 name 属性和 colors 数组。这不是我们的本意，这就是直接使用 new 操作符将父类实例赋值给子类原型对象的副作用╮(╯▽╰)╭。 要解决组合模式存在的问题，首先来看几个其他方式的继承。 6.3.4. 原型式继承由 Douglas Crockford（又是你→_→）在2006年的一篇文章中介绍，基本思想是：基于已有对象，借助原型创建新对象。 1234567function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 即先创建一个临时性的构造函数 F，然后将传入的对象 o 作为这个构造函数的原型 F.prototype，最后返回这个临时类型的一个新实例 new F()。从本质上将就是对于传入的对象 o 进行了一次浅复制。 1234567891011121314var person = &#123; name: \"steve\", friends: [\"shirley\", \"jame\"]&#125;;var anotherPerson = object(person);anotherPerson.name = \"young\";anotherPerson.friends.push(\"sasuke\");var yetAnotherPerson = object(person);yetAnotherPerson.name = \"nicholas\";yetAnotherPerson.friends.push(\"jobs\");alert(person.friends); // shirley,jame,sasuke,jobs，friends 被共享了 ES5 中新增了 Object.create() 方法规范化了原型式继承。可以接收两个参数，第一个参数就是要继承的对象，第二个对象是可选的一个为新对象定义额外属性的对象。其实只传一个参数时，两个方法行为相同。 第二个参数与 Object.defineProperties() 方法的第二个参数格式相同（覆盖同名属性），见下例。 12345678910111213var person = &#123; name: \"steve\", friends: [\"shirley\", \"jame\"]&#125;;var anotherPerson = Object.create(person, &#123; name: &#123; value: \"greg\", configurable: false &#125;&#125;);alert(anotherPerson.name); // greg 6.3.5. 寄生式继承基本思路类似用工厂模式包装原型式继承：创建一个仅用于封装继承过程的函数，在内部以某种方式来增强对象，最后返回该对象。 123456789101112131415161718var person = &#123; name: \"steve\", friends: [\"shirley\", \"jame\"]&#125;;function createAnother(original) &#123; var clone = object(original); // 原型式继承对象 original // 增强对象 clone.sayHi = function() &#123; alert(\"Hi\"); &#125;; return clone; // 返回对象&#125;var anotherPerson = createAnother(person);anotherPerson.sayHi(); // Hi 6.3.6. 寄生组合式继承首先实力吹一波：作为压轴出场的终极继承方式，几乎是最理想的继承范式。 前面在介绍组合继承的时候说到了主要问题出在 SubType.prototype = new SuperType(); 这句。它将父类构造函数中的属性也添加到了子类原型对象中，而这不符合我们的期望。 其实让我们回到需求本身：我们希望子类的原型对象能够指向父类的原型对象，实现原型链继承。 那么想一想 6.3.4. 原型式继承，我们让子类原型式继承父类的原型对象不就完美了么？ 12345678910111213141516171819202122232425262728function SuperType(name) &#123; this.name = name; this.colors = [\"red\", \"blue\"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;;function SubType(name, age) &#123; SuperType.call(this, name); // 借用构造函数，继承父类属性（解决了传参） this.age = age;&#125;SubType.prototype = Object.create(SuperType.prototype, &#123; constructor: &#123; value : SubType, // 指回子类构造函数 enumerable : false, // 默认值，其实可以不写 writable : true, configurable: true, &#125;&#125;);// 必须后添加方法（不然方法就加到之前的对象上去了_(:зゝ∠)_，要理解指针）SubType.prototype.sayAge = function() &#123; alert(this.age);&#125;; 6.4. 小结创建对象 工厂模式：简单地在函数内部创建对象，添加属性和方法，然后返回对象。 构造函数模式：在函数内部使用 this 添加属性和方法，可以创建自定义引用类型，可以使用 new 操作符创建实例。但是无法实现函数复用，造成内存浪费等问题。 原型模式：使用构造函数的 prototype 属性来指定共享的属性和方法，本质上就是为了共享而生。 组合模式：结合构造函数和原型模式的优点。 对象继承 原型链：将父类的实例赋值给子类构造函数的原型对象。但这样会有两个问题：传参和子类原型上有多余的父类构造函数中的属性。 借用构造函数：为了解决传参问题，采用在子类中调用父类构造函数的方法。 原型式：可以在不必预先定义构造函数的情况下实现继承，本质是执行对给定对象的浅复制。 寄生组合式：巧妙利用原型式继承解决原型链中的第二个问题，是基于类型继承的最好方式。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://buptsteve.github.io/blog/tags/JavaScript/"}]},{"title":"「4」Byrs-News 建站笔记（一）","date":"2016-03-16T03:27:58.000Z","path":"2016/03/16/004.byrs-news notes 1/","text":"零、前言差不多结束了在移动研究院快一年的实习，加上马上到来的寒假，想着闲着也是闲着不然做个网站练练手吧╮(╯▽╰)╭ 于是在寒假里就捣鼓了这么个网站 Byrs-News | 开源地址，主要内容是通过爬虫 Byr-Crawler 对于北邮人论坛帖子进行定时爬取，在收集整理之后希望大家能够更加“优雅地”浏览论坛～=￣ω￣=～。 一、技术栈 网站采用了 Meteor.js 全栈式开发 数据库选择了 MongoDB 进行存储 内容获取来自自己编写的 Node.js 爬虫 那么首先问题来了… 1.1. Meteor 是个什么玩意儿？Meteor 是一个只使用 JavaScript 就可以开发 Web 和移动端应用的全栈框架。主要特点有： 一种语言(One Language)：JavaScript（就可以搞定服务器、浏览器、移动设备）。 传递数据(Data on the wire)：服务器和客户端之间传递的是数据（而不是 html），由客户端进行数据的渲染。 无处不在的数据库(Database everywhere)：从客户机或服务器上使用相同、透明的 API 访问数据库。（在浏览器端实现了 Minimongo） 延迟补偿(Latency Compensation)：使用预读和模式模拟技术，使之看起来与数据库的连接是零延迟的。 全栈响应式(Full Stack Reactivity)：代码所依赖的数据发生变化时，结果 会自动重新计算。（并不是指响应式） 拥抱生态(Embrace the Ecosystem)：开源、与现有工具和框架整合，而不是取代。 简单等于生产力(Simplicity Equals Productivity)：让一件事看起来简单的最佳方式就是「真正」让它变得简单。 我的感受是使用 Meteor.js 可以在只用一种语言（JavaScript）的情况下，「超快速」地开发出一个功能完善的现代网站。 还有疑问？Take it easy.且看我后文慢慢道来… 1.2. 为什么选择 MongoDB？ 首先当然是因为它是 Meteor 的默认数据库呀╮(╯▽╰)╭ 其次作为一个 NoSQL 数据库比传统关系型数据库更加灵活，更加适用于互联网应用场景 我可以在爬虫运行过程中可以更加方便地修改文档结构 … 1.3. 为什么是 Node.js 爬虫？因为正好最近在学习 Node.js，还有保持项目只有一种语言。 二、项目规范2.1. 命名规范 文件夹和文件采用小写字母，用下划线 _ 连接。 JavaScript 文件中的内容采用驼峰命名法（因为毕竟它自己就是用的驼峰╮(╯▽╰)╭）。 CSS 文件中的内容采用连字符 - 连接（因为本来 CSS 语法就是用连字符，如 font-family 等）。 2.2. 文件夹规范由于是一个全栈式框架（代码写一块儿╮(╯▽╰)╭），所以文件夹的名字十分地重要。因为会影响 Meteor 对其加载的顺序（见下文）。 一般来说有在顶级项目目录下有以下规范的命名： client/ : 放置所有的客户端代码，Meteor 也不会将其在服务端加载。 server/ : 放置所有的服务端代码，Meteor 也不会将其在客户端加载。 public/ : 放置静态资源，例如 favicon.ico, robots.txt 等。 node_modules/ : Node.js 模块代码。（比如 cz-conventional-changelog） tests/ : 本地测试代码。 private/ : 只能被服务器端代码获取，可以通过 Assets API 读取。（不常用） client/compatibility/ : 只能被服务器端代码获取，可以通过 Assets API 读取。（不常用） lib/ : 放置服务端和客户端共用的代码，比如 config.js、数据库文件夹 collections/。 加载顺序（了解即可） 应用根目录内 lib 文件夹下的文件首先加载。 符合 main.* 这个格式的文件最后加载。 子目录中的文件在母目录中的文件之前加载，即最深层子目录中的文件首先加载（在 lib 之后），根目录的文件最后加载（在 main.* 之前）。 同目录下的文件，按文件名的字母顺序来加载。 三、重要参考资料 官网 官方快速入门教程: 学习点这 StackOverflow: 碰到问题点这 官方论坛 Github","tags":[{"name":"meteor","slug":"meteor","permalink":"https://buptsteve.github.io/blog/tags/meteor/"}]},{"title":"「3」前端开发利器 webpack","date":"2015-12-29T07:12:58.000Z","path":"2015/12/29/003.js-webpack/","text":"零、前言在编写构建前端项目时，以下这些需求想必十分常见： html/css/js 代码的预编译： Jade, Ejs… Sass, Less, Stylus… Dart, CoffeeScript, TypeScript, ES6/7… 拯救你的 F5 或者 Command/Ctrl + R（即自动监听、编译并刷新浏览器） 发布时的代码压缩、混淆，图片的压缩和 base64 嵌入 以上这些「体力♂活儿」显然不能自己浪费时间手动完成，所以优雅的解决方式就是：自动化构建工具～！ 话说我最早了解到前端自动化构建工具，是通过慕课网学习的时候看到的 grunt 教程，随意浏览了点儿发现上手有点儿难 _(:зゝ∠)_ 同时也没有什么需求就没有学下去。 然后学习了 less/sass/stylus 等预编译语言，先是使用了 koala 进行 less 文件的编译。之后又有了「拯救 F5」的需求，觉得再使用 livereload 这样不够绅士(´･ω･`)。于是开始学习 gulp， gulp 是基于 Unix 的哲♂学，即 Do one thing and do it well. 类似于 Unix 的管道命令（pipe：| ），gulp 基于 Node.js 中的 stream 机制。Gulp 的每个插件从 stream 中读取输入，做一些处理，再输出到 stream 中。同时使用 browser-sync 插件能够解决我的重复刷新的繁重劳动。 无奈前端变化太快_(:зゝ∠)_，使用 gulp 没多久。通过 vue.js 一个 MVVM 框架，知道了 webpack 这一新的前端自动化构建工具。使用 webpack 可以方便地将 *.vue文件编译打包到工程中，并且 react 的大部分项目也使用 webpack 进行构建。那么问题来了，webpack 究竟靠什么火起来了呢？ 一、webpack1.1. 为什么选择 webpack ? 参考链接a. 模块化首先要明确：随着前端越来越「重」，项目变得越来越大，团队人数增加、功能增加地越多，势必引起出错、依赖情况的出现。那么想想服务器端、桌面大型程序等是怎么做的呢？ 答案只有一个：模块化开发！ 然而浏览器本身并不提供模块管理的机制（ES6 终于引入 Module），为了调用各个模块，有时不得不在网页中，加入一大堆script标签。这样就使得网页体积臃肿，难以维护，还产生大量的HTTP请求，拖慢显示速度，影响用户体验。 在此对于模块化就不继续展开了…Require.js/Sea.js/Common.js/AMD/CMD/ES6…etc. b. 代码传输明确了模块化开发这一前提之后，那么新的问题又来了…模块化之后的文件怎么从服务器传递到客户端（浏览器）？ 有两种「极端」的方式： 每一个请求传送一个模块（类似于一堆的 &lt;srcipt&gt; 标签…） 一个请求传送所有模块（例如 browserify 的打包方式） 这两种方式方式各有优缺点： 一个请求一个模块 优点：只加载需要的模块； 缺点：大量请求会使得启动缓慢… 一个请求所有模块 优点：请求数少，等待时间少； 缺点：不需要的模块同样被传送了… 因此，在大多数的情况下最佳实践应该是一个折中的方案： 在编译所有模块时，将模块细分成为多个小的 batches(chunks)，于是我们分解得到了许多请求。模块的 chunks 初始状态时并没有全部加载，只在需要的时候发起请求。因此初始请求不会包含所有的代码，显然加载的代码量更小，速度更快。 其中关键的「分割点」即 chunks 的划分边界，是取决于开发者并且是可选的。 c. 模块热替换（HMR）此外还有一个重要原因：webpack 支持模块热替换（HMR）（例如 react-hot-loader） 针对浏览器自动刷新，LiveReload 和 Browser-sync 是两款常用的工具，然而 HMR 更进了一步。我们知道 React 出现的原因之一就是积累用户在浏览器中的状态，而 HMR 能够在修改代码保存之后仍然保存之前的状态，就是俗称的「热替换」。 1.2. 怎么使用 webpack？了解了为什么（why）之后，接着学习怎么做（how）。 a. webpack 的安装 首先使用 npm 全局安装 webpack： 1$ npm i(nstall) -g webpack 接着局部安装 webpack： 1$ npm i(nstall) --save-dev webpack b. webpack 的配置 官方文档 Pete Hunt webpack 配置的本质就是：一个配置的 Object。 因此有两种使用方法配置 webpack: 一种是 Cli（即 Command Line Interface）方法：读取 webpack.config.js 文件； 另一种是 Node.js API 的方法：传递配置对象作为参数。 前端一般使用第一种，即配置 webpack.config.js 文件，简单例子如下： 1234567// webpack.config.jsmodule.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;&#125;; 就是设置入口、出口文件，炒鸡简单有木有~ 接着我们需要进行一些预编译工作，例如把 CoffeeScript 或 ES6 的代码编译为 ES5 的 JavaScript，例子如下： 12345678910111213141516// webpack.config.jsmodule.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, module: &#123; loaders: [&#123; test: /\\.coffee$/, loader: 'coffee-loader' &#125;, &#123; test: /\\.js$/, loader: 'babel-loader' &#125;] &#125;&#125;; 只需要加入 loader，loader 中的 test 表示哪些文件需要经过 loader 进行处理。 对于 css 和 图片资源同样也有 loader，这样就可以像引用 js 一样在代码中引用，例如： 12345require('./bootstrap.css');require('./myapp.less');var img = document.createElement('img');img.src = require('./glyph.png'); loader 的编写类似于之前的例子：（!用于链式操作，且从右往左执行） 1234567891011121314151617181920212223// webpack.config.jsmodule.exports = &#123; entry: './main.js', output: &#123; path: './build', // This is where images AND js will go publicPath: 'http://mycdn.com/', // This is used to generate URLs to e.g. images filename: 'bundle.js' &#125;, module: &#123; loaders: [&#123; test: /\\.less$/, loader: 'style-loader!css-loader!less-loader' &#125;, // use ! to chain loaders &#123; test: /\\.css$/, loader: 'style-loader!css-loader' &#125;, &#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192' &#125; // inline base64 URLs for &lt;=8k images, direct URLs for the rest ] &#125;&#125;; last but not the least: 添加 webpack-dev-server 作为实时代码更新安装完成后只需添加两行代码到 webpack.config.js 中： 123456789module.exports = &#123; ... entry: [ 'webpack-dev-server/client?http://0.0.0.0:8080', 'webpack/hot/only-dev-server', './app/main.js' ], ...&#125;; 并且在 package.json 中的 scripts 添加一行代码： 12345&#123; \"scripts\": &#123; \"dev\": \"webpack-dev-server --devtool eval --progress --colors --hot --content-base build\" &#125;,&#125; 这样在日常开发中只需要执行： 1$ npm run dev 在浏览器中访问 http://localhost:8080 即可看到编译结果，并且更改代码后能够自动刷新。","tags":[{"name":"效率","slug":"效率","permalink":"https://buptsteve.github.io/blog/tags/效率/"},{"name":"webpack","slug":"webpack","permalink":"https://buptsteve.github.io/blog/tags/webpack/"}]},{"title":"「2」如何搭建自己的服务器？","date":"2015-11-03T05:04:58.000Z","path":"2015/11/03/002.centos-server/","text":"零、问题的由来？平时逛 北邮人论坛 看到各种大神做的各种作品，技痒难耐，也想自己捣鼓捣鼓、学习服务器。正好实验室有空闲电脑，就自己搭一个玩儿啦～。在纠结半天，看了好多资(si)料(bi)后，决定选用 CentOS 作为操作系统， 主要开发环境为 Python 和 Node.js。 一、系统安装（怎么获取镜像就不赘述了～） 利用 ultraISO 将镜像文件拷入 u 盘内 设置 BIOS，优先从 u 盘启动 按照步骤安装… 二、网关问题由于北邮校内使用 ipv4 流量需要登录网关，下面介绍两种方法： 2.1. VNCCentOS 可以使用 tigervnc，使用 yum 即可安装： 12$ yum install tigervnc$ yum install tigervnc-server 安装完成后，使用命令vncserver :n 打开相应端口n（这里的n是sessionnumber，不指定默认为1，也可以是2、3等等。第一次会提示输入密码，以后可以使用vncpasswd命令修改密码。） 当然别忘了设置 iptables…小白就 iptables -F 吧 之后就可以从本地 vncviewer 连接啦… 2.2. 命令行（推荐）网关登录还可以使用 curl 命令： 登录： 1$ curl -d 'DDDDD=「你的帐号」&amp;upass=「你的密码」&amp;AMKKey=' 10.3.8.211 注销： 1$ curl 10.3.8.211/F.htm 还可以写入命令行的 alias 中 12345$ vi ~/.bashrc (这里看你具体用的啥)# 添加以下 aliasalias ibu='curl -d \"DDDDD=「你的帐号」&amp;upass=「你的密码」&amp;AMKKey=\" 10.3.8.211 &amp;&amp; clear'alias obu='curl 10.3.8.211/F.htm &amp;&amp; clear' 这样要登录网关只需要输入 ibu，同理退出就是 obu。 三、Python 3 环境由于 CentOS 自带 Python 为 2.7.5 版本（最好不要卸载，因为会被 yum 使用），而我日常使用 3.0+ 所以需要更新 Python 版本。下面介绍一种两个环境共存的方法（以 3.5 版本为例）： 1$ wget https://www.python.org/ftp/python/3.5.0/Python-3.5.0.tar.xz 下载 Python 3.5.0 ，之后解压，安装… C Complier问题：在上一步安装 Python3 的过程中执行 ./configure 时报错，原来是没有 C Complier… 1$ yum install gcc 继续安装 Python3 123$ ./configure --prefix=/opt/python3$ make$ sudo make install 验证是否安装成功 1$ /opt/python3/bin/python3 -V 重要事项！ 由于此种方法仍保留了原系统中的 Python2 ，因此别忘了在自己编写的 Python3 脚本中加入 1#!/opt/python3/bin/python3 即，选择 python3 进行解析。 四、Node.js 环境4.1. 安装推荐使用 nvm 进行安装和版本切换。 4.2. 仓库问题由于 GFW 的原因，可能使用自带 registry 会太慢或者失败，因此可以试试以下解决方案 推荐一个切换仓库的 npm 包 nrm 1$ npm i(nstall) -g nrm nrm 使用介绍12345678910111213141516// 列出可用仓库$ nrm ls* npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ taobao - http://registry.npm.taobao.org/ eu ----- http://registry.npmjs.eu/ au ----- http://registry.npmjs.org.au/ sl ----- http://npm.strongloop.com/ nj ----- https://registry.nodejitsu.com/ pt ----- http://registry.npmjs.pt/// 切换仓库到 cnpm$ nrm use cnpm Registry has been set to: http://r.cnpmjs.org/ 当然嫌麻烦可以直接用 淘宝 npm 镜像 3. 切换 Node.js 版本直接使用 nvm 或者 tj 的作品 n 1$ npm i(nstall) -g n 使用介绍12345678910111213// 安装 0.8.14/0.8.17/0.9.6 三个版本的 nodejs$ n 0.8.14$ n 0.8.17$ n 0.9.6// 选择版本（移动上下箭头，回车或右键头选择，Ctrl+C 取消）$ n 0.8.14ο 0.8.17 0.9.6// 删除 0.9.4 版本$ n - 0.9.4","tags":[{"name":"Linux","slug":"Linux","permalink":"https://buptsteve.github.io/blog/tags/Linux/"},{"name":"Server","slug":"Server","permalink":"https://buptsteve.github.io/blog/tags/Server/"},{"name":"Python","slug":"Python","permalink":"https://buptsteve.github.io/blog/tags/Python/"},{"name":"Node.js","slug":"Node-js","permalink":"https://buptsteve.github.io/blog/tags/Node-js/"}]},{"title":"「1」优雅地打开软件是怎样的体验？","date":"2015-11-01T11:04:58.000Z","path":"2015/11/01/001.the-way-to-open-software/","text":"零、问题的由来不知道大家平时是怎么打开常用软件的： 1. windows 用户 从桌面上一堆杂乱的文件中找到快捷方式双击打开？ 从桌面上分类整理好的文件夹中找到快捷方式双击打开？ 或是更进一步地利用 Fences 从桌面选择？ 利用 Everything 进行文件名搜索？ win8下的 Metro，win10下的 blablabla… 2. OS X 用户 通过在 Dock 中寻找后，单击打开？ 通过拇指与其他三个手指合拢进入 Launchpad 后，单击打开？ 利用自带的 spotlight 或者 alfred 等工具输入软件名打开？ 通过终端… 3. linux 用户 通过终端… 要啥自行车…╮(╯▽╰)╭… (才不会告诉你是因为我不造呢…) 一、我的选择 (私のchoice)1.1. OS X 下通过 ctrl + space 唤起 alfred ，之后输入软件缩写，点击回车或 cmd + n打开软件。(btw 可以将 Application 中的各个 app 的名字重新命名缩写过，比如将 网易云音乐 缩写成 wyy) 1.2. windows 下1.2.1. 自带的运行就是那个 win + r ，不过为了保持与 OS X 操作的一致性利用了AutoHotkey 将其统一修改为 ctrl + space。 具体的配置文件是 点我 中的 autohotkey/steve.ahk 1.2.2. 然后呢？还需要2步设置：(居然比把大象放冰箱还少一步啊喂！) 将 (桌面上或者其他地方的) 软件快捷方式改名缩写成2~3个字母 把该快捷方式 duang～ 地一声剪切到 C:\\Windows 下，搞定收工～=￣ω￣=～ 不过有的软件比如 Github.appref-ms 这种格式的就没办法通过以上方法快速打开了。这时候就又要推荐一个好用软件啦：Rolan，将快捷方式或其他的文件/文件夹拖进去就ok。要使用的时候就通过快捷键呼叫出 Rolan 后即可打开。 二、综上无论何时，无论当前层叠了多少窗口…只需要: 按下 Ctrl + Space 输入缩写过的 2~3 个字母的软件名称 按下 Enter 确认 Duang～一下就优雅地把软件打开了~\\(≧▽≦)/~","tags":[{"name":"效率","slug":"效率","permalink":"https://buptsteve.github.io/blog/tags/效率/"}]},{"title":"「0」Hello World","date":"2015-10-29T11:04:58.000Z","path":"2015/10/29/000.hello-world/","text":"零、Blog的由来作为一个学计算机的，一直想整个自己的 Blog，尤其是最近在搞前端。先是看到 jekyll 感觉不错，折腾了半天感觉还是不够给力。最后还是选择了 hexo3。 主要是这几个优点吧： 免费╮(╯▽╰)╭ 基于 Node.js 速度快、操作更简单、命令少，专注于写作本身 由于 deploy 命令，发布到 github 上生成静态站点也很简单 所以整个 Blog 就是采用 hexo3 + github pages,主题基于 indigo 进行修改，下面就详细说说怎么搭起来吧… 一、hexo的安装首先由于 hexo 是基于 Node.js 开发的，所以我们先要安装 Node.js 环境，进入Node.js官网，一般会发现有两个版本：LTS 和 Stable。 这两个版本的区别在于一个是 LTS 长期支持版（也是推荐选项），另一个是拥有最新功能的稳定版（适合有新功能需求的尝鲜用户）。 安装完成后，在命令行运行以下命令（其中括号的意思是 install 可以缩写为 i）： 1$ npm i(nstall) -g hexo npm 安装方式中 -g 的意思是全局安装。 二、初体验~2.1. 生成项目找到一个合适的位置，创建我们的项目文件夹： 一般的用户：自己图形界面新建了一个,然后点进去 命令行用户：mkdir &lt;folder&gt; &amp;&amp; cd &lt;folder&gt; hexo的用户：hexo init &lt;folder&gt; &amp;&amp; cd &lt;folder&gt; 2.2. 安装依赖1$ npm i(nstall) npm 就会自动根据 package.json 中的配置自动进行安装 2.3. 运行预览12$ hexo g(enerate)$ hexo s(erver) 如果这步报错一般是因为没装 hexo-server，运行以下命令安装即可： 1$ npm i(nstall) --save hexo-server npm 安装方式中 –save 的意思是作为项目依赖(dependencies)进行安装，可以缩写为 -S (注意大写)此外还有 –save-dev 的意思是作为项目的「开发」依赖(devDependencies)进行安装，可以缩写为 -D (注意大写)这两种安装方式都会将这个包的名称和版本写进 package.json 配置文件中 最后打开浏览器输入http://localhost:4000就可以看到页面啦～ 三、换主题（theme）然而只是使用默认的主题（theme）怎么会有逼格→_→，果断要整一个吊炸天的主题呀~，下面以 indigo 为例作为说明。 3.1. 下载主题首先在项目目录下（就是说有个 themes 的文件夹），执行以下命令，将主题下载到 themes 文件夹下的 indigo 文件夹中。 1$ git clone https://github.com/yscoder/hexo-theme-indigo themes/indigo 3.2. 配置使用主题接着修改 _config.yml（项目的配置文件，不是主题的） 将 theme 改为 indigo 四、部署到 github pages4.1. 安装 hexo-deployer-git1$ npm i(nstall) hexo-deployer-git --save 4.2. 关于 github pages4.2.1. 分类1. 项目站点（Project Pages）github 会根据 gh-pages 分支下文件生成静态页面，地址是 [yourName].github.io/[projectName]。（[yourName] 是你的账户名，[projectName] 是你的项目名） 2. 个人或公司站点（User/Organization Pages）首先要创建一个叫做 [yourName].github.io 的项目，接着 github 会根据 master 分支下文件生成静态页面，地址是 [yourName].github.io/。 4.2.2. 一些坑… 有的主题中各种静态文件路径是写死的，比如好多主题中的文件引入是针对第二类页面写死的。 有些主题中的 CDN 资源被墙，那就需要找到这些文件手动修改地址╮(╯▽╰)╭。 4.3. 修改 _config.yml 文件官方文档中是这么介绍的 1234567891011121314# You can use this:deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message]# or this:deploy: type: git message: [message] repo: github: &lt;repository url&gt;,[branch] gitcafe: &lt;repository url&gt;,[branch] 123* repo: Repository URL* branch: Git branch to deploy the static site to* message: Commit message. The default commit message is Site updated: &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;. 根据 4.2. 所述，部署部分的填写也分为两种情况： 1. 个人或公司站点 repo：填写项目地址，例如 `git@github.com:BuptStEve/BuptStEve.github.io.git` branch：填写 master 2. 项目站点 repo：填写项目地址，例如 `git@github.com:BuptStEve/blog.git` branch：填写 gh-pages url：https://buptsteve.github.io/blog/ （注意最后的 /） root：/blog/ （注意最后的 /） 4.4. 开始部署首先生成站点文件 1$ hexo g 接着发布 1$ hexo d(eploy) 最后打开对应地址就可以看到自己的博客啦～=￣ω￣=～。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://buptsteve.github.io/blog/tags/hexo/"}]}]