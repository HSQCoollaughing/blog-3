<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="keywords" content=""><meta name="theme-color" content="#3F51B5"><meta name="summary" content="BuptStEve"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>「10」JavaScript 函数式编程（二） | BuptStEve&#39;s Blog | Talk is cheap show me the offer!</title><meta name="description" content="slide 地址 三、可以，这很函数式~ 3.1.函数是一等公民！3.1.1.滥用匿名函数其实经常写 JavaScript 的人可能潜移默化地已经接受了这个观念，例如你可以像对待任何其他数据类型一样对待函数——把它们存在数组里，当作参数传递，赋值给变量.等等。 然而，常常可以看到滥用匿名函数的现象… 1234567891011121314151617// 太傻了const getServerStu"><meta name="keywords" content="JavaScript,FP,函数式"><meta property="og:type" content="article"><meta property="og:title" content="「10」JavaScript 函数式编程（二）"><meta property="og:url" content="https://buptsteve.github.io/blog/2017/11/23/010.fp-in-js-2/index.html"><meta property="og:site_name" content="BuptStEve&#39;s Blog"><meta property="og:description" content="slide 地址 三、可以，这很函数式~ 3.1.函数是一等公民！3.1.1.滥用匿名函数其实经常写 JavaScript 的人可能潜移默化地已经接受了这个观念，例如你可以像对待任何其他数据类型一样对待函数——把它们存在数组里，当作参数传递，赋值给变量.等等。 然而，常常可以看到滥用匿名函数的现象… 1234567891011121314151617// 太傻了const getServerStu"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/this-is-very-fp.gif"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/this-js.jpg"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/composition-of-functions.jpg"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/function-composition.png"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/start-transform-effect.png"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/transformation-1.png"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/transformation-2.png"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/transformation-3.png"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/transformation-4.png"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/i-don%27t-think-so.jpg"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/i-think-it-is-ok.jpg"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/hoogle.png"><meta property="og:updated_time" content="2018-12-27T07:30:20.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="「10」JavaScript 函数式编程（二）"><meta name="twitter:description" content="slide 地址 三、可以，这很函数式~ 3.1.函数是一等公民！3.1.1.滥用匿名函数其实经常写 JavaScript 的人可能潜移默化地已经接受了这个观念，例如你可以像对待任何其他数据类型一样对待函数——把它们存在数组里，当作参数传递，赋值给变量.等等。 然而，常常可以看到滥用匿名函数的现象… 1234567891011121314151617// 太傻了const getServerStu"><meta name="twitter:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/this-is-very-fp.gif"><link rel="shortcut icon" href="/blog/img/favicon.ico"><link rel="stylesheet" href="/blog/css/style.css"><link rel="alternative" href="/blog/atom.xml" title="BuptStEve&#39;s Blog" type="application/atom+xml"></head><body><div id="loading" class="active"></div><nav id="menu" class="hide"><div class="inner flex-row-vertical"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off"><i class="icon icon-lg icon-close"></i></a><div class="brand-wrap"><div class="brand"><a href="/blog" class="avatar"><img src="/blog/img/logo.jpg"></a><hgroup class="introduce"><h5 class="nickname">Steve Young</h5><a href="mailto:yangzhenyu2016@gmail.com" title="yangzhenyu2016@gmail.com" class="mail">yangzhenyu2016@gmail.com</a></hgroup></div></div><div class="scroll-wrap flex-col"><ul class="nav"><li class="waves-block waves-effect"><a href="/blog/"><i class="icon icon-lg icon-home"></i> 主页</a></li><li class="waves-block waves-effect"><a href="/blog/archives"><i class="icon icon-lg icon-archives"></i> Archives</a></li><li class="waves-block waves-effect"><a href="/blog/tags"><i class="icon icon-lg icon-tags"></i> Tags</a></li><li class="waves-block waves-effect"><a href="https://github.com/buptsteve" target="_blank"><i class="icon icon-lg icon-github"></i> Github</a></li><li class="waves-block waves-effect"><a href="http://weibo.com/0osteveyoungo0" target="_blank"><i class="icon icon-lg icon-weibo"></i> Weibo</a></li></ul><footer class="footer"><p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC"></a></p><p>BuptStEve&#39;s Blog &copy; 2019</p><p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p><a href="/blog/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a></footer></div></div></nav><main id="main"><header class="top-header" id="header"><div class="flex-row"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle"><i class="icon icon-lg icon-navicon"></i></a><div class="flex-col header-title ellipsis">「10」JavaScript 函数式编程（二）</div><div class="search-wrap" id="search-wrap"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i></a> <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search"><i class="icon icon-lg icon-search"></i></a></div></div></header><header class="content-header"><div class="container"><h1 class="author">「10」JavaScript 函数式编程（二）</h1><h5 class="subtitle"><time datetime="2017-11-23T09:45:00.000Z" itemprop="datePublished" class="page-time">2017-11-23</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/全栈/">全栈</a></li></ul></h5></div></header><div class="container body-wrap"><article id="post-010.fp-in-js-2" class="article article-type-post" itemprop="blogPost"><div class="post-meta flex-row"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/FP/">FP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/函数式/">函数式</a></li></ul></div><div class="post-body"><aside class="post-widget" id="post-widget"><nav class="post-toc-wrap" id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#三、可以，这很函数式"><span class="post-toc-text">三、可以，这很函数式~</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1-函数是一等公民！"><span class="post-toc-text">3.1.函数是一等公民！</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-1-1-滥用匿名函数"><span class="post-toc-text">3.1.1.滥用匿名函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-1-2-为何钟爱一等公民？"><span class="post-toc-text">3.1.2.为何钟爱一等公民？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-1-3-提高函数复用率"><span class="post-toc-text">3.1.3.提高函数复用率</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-1-4-this"><span class="post-toc-text">3.1.4.this</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-柯里化（curry）"><span class="post-toc-text">3.2.柯里化（curry）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-2-1-柯里化概念"><span class="post-toc-text">3.2.1.柯里化概念</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-2-2-柯里化-VS-偏函数应用（partial-application）"><span class="post-toc-text">3.2.2.柯里化 VS 偏函数应用（partial application）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-2-3-柯里化的实现"><span class="post-toc-text">3.2.3.柯里化的实现</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-2-4-柯里化的意义"><span class="post-toc-text">3.2.4.柯里化的意义</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-函数组合（compose）"><span class="post-toc-text">3.3.函数组合（compose）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-1-组合的概念"><span class="post-toc-text">3.3.1.组合的概念</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-2-组合的实现"><span class="post-toc-text">3.3.2.组合的实现</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-3-Pointfree"><span class="post-toc-text">3.3.3.Pointfree</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-4-函数组合的意义"><span class="post-toc-text">3.3.4.函数组合的意义</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-4-Hindley-Milner-类型签名"><span class="post-toc-text">3.4.Hindley-Milner 类型签名</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-4-1-基本概念"><span class="post-toc-text">3.4.1.基本概念</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-4-2-参数态（Parametricity）"><span class="post-toc-text">3.4.2.参数态（Parametricity）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-4-3-自由定理（Free-Theorems）"><span class="post-toc-text">3.4.3.自由定理（Free Theorems）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-4-4-类型约束"><span class="post-toc-text">3.4.4.类型约束</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-4-5-类型签名的作用"><span class="post-toc-text">3.4.5.类型签名的作用</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考资料"><span class="post-toc-text">参考资料</span></a></li></ol></nav></aside><div class="post-main"><div class="post-content" id="post-content" itemprop="postContent"><p><strong><a href="https://slides.com/yangzhenyu/functional-programming-in-javascript" target="_blank" rel="noopener">slide 地址</a></strong></p><h2 id="三、可以，这很函数式"><a href="#三、可以，这很函数式" class="headerlink" title="三、可以，这很函数式~"></a>三、可以，这很函数式~</h2><p><img src="/blog/imgs/fp-in-js/this-is-very-fp.gif" alt="this-is-very-fp"></p><h3 id="3-1-函数是一等公民！"><a href="#3-1-函数是一等公民！" class="headerlink" title="3.1.函数是一等公民！"></a>3.1.函数是一等公民！</h3><h4 id="3-1-1-滥用匿名函数"><a href="#3-1-1-滥用匿名函数" class="headerlink" title="3.1.1.滥用匿名函数"></a>3.1.1.滥用匿名函数</h4><p>其实经常写 JavaScript 的人可能潜移默化地已经接受了这个观念，例如你可以像对待任何其他数据类型一样对待函数——把它们存在数组里，当作参数传递，赋值给变量.等等。</p><p>然而，常常可以看到滥用匿名函数的现象…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 太傻了</span></span><br><span class="line"><span class="keyword">const</span> getServerStuff = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ajaxCall(<span class="function"><span class="keyword">function</span> (<span class="params">json</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> callback(json)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这才像样</span></span><br><span class="line"><span class="keyword">const</span> getServerStuff = ajaxCall</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面来推导一下...</span></span><br><span class="line"><span class="keyword">const</span> getServerStuff</span><br><span class="line">  === <span class="function"><span class="params">callback</span> =&gt;</span> ajaxCall(<span class="function"><span class="params">json</span> =&gt;</span> callback(json))</span><br><span class="line">  === <span class="function"><span class="params">callback</span> =&gt;</span> ajaxCall(callback)</span><br><span class="line">  === ajaxCall</span><br><span class="line"></span><br><span class="line"><span class="comment">// from JS函数式编程指南</span></span><br></pre></td></tr></table></figure><p>再来看一个例子…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BlogController = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> index = <span class="function"><span class="keyword">function</span> (<span class="params">posts</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Views.index(posts)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> show = <span class="function"><span class="keyword">function</span> (<span class="params">post</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Views.show(post)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> create = <span class="function"><span class="keyword">function</span> (<span class="params">attrs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Db.create(attrs)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> update = <span class="function"><span class="keyword">function</span> (<span class="params">post, attrs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Db.update(post, attrs)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> destroy = <span class="function"><span class="keyword">function</span> (<span class="params">post</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Db.destroy(post)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; index, show, create, update, destroy &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码 99% 都是多余的...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BlogController = &#123;</span><br><span class="line">  index: Views.index,</span><br><span class="line">  show: Views.show,</span><br><span class="line">  create: Db.create,</span><br><span class="line">  update: Db.update,</span><br><span class="line">  destroy: Db.destroy,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...或者直接全部删掉</span></span><br><span class="line"><span class="comment">// 因为它的作用仅仅就是把视图（Views）和数据库（Db）打包在一起而已。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// from JS函数式编程指南</span></span><br></pre></td></tr></table></figure><h4 id="3-1-2-为何钟爱一等公民？"><a href="#3-1-2-为何钟爱一等公民？" class="headerlink" title="3.1.2.为何钟爱一等公民？"></a>3.1.2.为何钟爱一等公民？</h4><p>以上那种多包一层的写法最大的问题就是，一旦内部函数需要新增或修改参数，那么包裹它的函数也要改…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始函数</span></span><br><span class="line">httpGet(<span class="string">'/post/2'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> renderPost(json)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假如需要多传递一个 err 参数</span></span><br><span class="line">httpGet(<span class="string">'/post/2'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">json, err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> renderPost(json, err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// renderPost 将会在 httpGet 中调用，</span></span><br><span class="line"><span class="comment">// 想要多少参数，想怎么改都行</span></span><br><span class="line">httpGet(<span class="string">'/post/2'</span>, renderPost)</span><br></pre></td></tr></table></figure><h4 id="3-1-3-提高函数复用率"><a href="#3-1-3-提高函数复用率" class="headerlink" title="3.1.3.提高函数复用率"></a>3.1.3.提高函数复用率</h4><p>除了上面说的避免使用不必要的中间函数包裹以外，对于函数参数的起名也很重要，尽量编写通用参数的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只针对当前的博客</span></span><br><span class="line"><span class="keyword">const</span> validArticles = <span class="function"><span class="keyword">function</span> (<span class="params">articles</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> articles.filter(<span class="function"><span class="keyword">function</span> (<span class="params">article</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> article !== <span class="literal">null</span> &amp;&amp; article !== <span class="literal">undefined</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用性好太多</span></span><br><span class="line"><span class="keyword">const</span> compact = <span class="function"><span class="keyword">function</span>(<span class="params">xs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> xs.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x !== <span class="literal">null</span> &amp;&amp; x !== <span class="literal">undefined</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上例子说明了在命名的时候，我们特别容易把自己限定在特定的数据上（本例中是 articles）。这种现象很常见，也是重复造轮子的一大原因。</p><h4 id="3-1-4-this"><a href="#3-1-4-this" class="headerlink" title="3.1.4.this"></a>3.1.4.this</h4><p><img src="/blog/imgs/fp-in-js/this-js.jpg" alt="this-js"></p><p>在函数式编程中，其实根本用不到 this…</p><p>但这里并不是说要避免使用 this<br><del>（江来报道上出了偏差…识得唔识得？）</del></p><h3 id="3-2-柯里化（curry）"><a href="#3-2-柯里化（curry）" class="headerlink" title="3.2.柯里化（curry）"></a>3.2.柯里化（curry）</h3><h4 id="3-2-1-柯里化概念"><a href="#3-2-1-柯里化概念" class="headerlink" title="3.2.1.柯里化概念"></a>3.2.1.柯里化概念</h4><blockquote><p>把接受多个参数的函数变换成一系列接受单一参数（从最初函数的第一个参数开始）的函数的技术。（注意是单一参数）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; curry &#125; <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y</span><br><span class="line"><span class="keyword">const</span> curriedAdd = curry(add)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> increment = curriedAdd(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> addTen = curriedAdd(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">increment(<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line">addTen(<span class="number">2</span>) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><blockquote><p>柯里化是由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，<br>当然编程语言 Haskell 也是源自他的名字，<br>虽然柯里化是由 Moses Schnfinkel 和 Gottlob Frege 发明的。</p></blockquote><h4 id="3-2-2-柯里化-VS-偏函数应用（partial-application）"><a href="#3-2-2-柯里化-VS-偏函数应用（partial-application）" class="headerlink" title="3.2.2.柯里化 VS 偏函数应用（partial application）"></a>3.2.2.柯里化 VS 偏函数应用（partial application）</h4><blockquote><p>In computer science, partial application (or partial function application) refers to the process of fixing a number of arguments to a function, producing another function of smaller arity.</p><p>by wikipedia</p></blockquote><p>偏函数应用简单来说就是：一个函数，接受一个多参数的函数且传入部分参数后，返回一个需要更少参数的新函数。</p><p>柯里化一般和偏函数应用相伴出现，但这两者是不同的概念：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; curry, partial &#125; <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> x + y + z</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curriedAdd = curry(add)       <span class="comment">// &lt;- 只接受一个函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addThree = partial(add, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// &lt;- 不仅接受函数，还接受至少一个参数</span></span><br><span class="line">  === curriedAdd(<span class="number">1</span>)(<span class="number">2</span>)              <span class="comment">// &lt;- 柯里化每次都返回一个单参函数</span></span><br></pre></td></tr></table></figure><p>简单来说，一个多参函数（n-ary），柯里化后就变成了 n * 1-ary，而偏函数应用了 x 个参数后就变成了 (n-x)-ary</p><h4 id="3-2-3-柯里化的实现"><a href="#3-2-3-柯里化的实现" class="headerlink" title="3.2.3.柯里化的实现"></a>3.2.3.柯里化的实现</h4><p>虽然从理论上说柯里化应该返回的是一系列的单参函数，但在实际的使用过程中为了像偏函数应用那样方便的调用，所以这里柯里化后的函数也能接受多个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个函数 curry 满足以下调用、</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">const</span> curried = curry(f)</span><br><span class="line"></span><br><span class="line">curried(a, b, c, d)</span><br><span class="line">curried(a, b, c)(d)</span><br><span class="line">curried(a)(b, c, d)</span><br><span class="line">curried(a, b)(c, d)</span><br><span class="line">curried(a)(b, c)(d)</span><br><span class="line">curried(a)(b)(c, d)</span><br><span class="line">curried(a, b)(c)(d)</span><br></pre></td></tr></table></figure><p>很明显第一反应是需要使用递归，这样才能返回一系列的函数。而递归的结束条件就是接受了原函数数量的参数，所以重点就是参数的传递~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> curry = <span class="function"><span class="keyword">function</span> <span class="title">curry</span> (<span class="params">fn, arr</span>) </span>&#123;</span><br><span class="line">  arr = arr || []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">var</span> arg = arr.concat(args)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arg.length &gt;= fn.length</span><br><span class="line">      ? fn.apply(<span class="literal">null</span>, arg)</span><br><span class="line">      : curry(fn, arg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">fn, arr = []</span>) =&gt;</span> (...args) =&gt; (</span><br><span class="line">  arg =&gt; arg.length &gt;= fn.length</span><br><span class="line">    ? fn(...arg)</span><br><span class="line">    : curry(fn, arg)</span><br><span class="line">)([...arr, ...args])</span><br></pre></td></tr></table></figure><h4 id="3-2-4-柯里化的意义"><a href="#3-2-4-柯里化的意义" class="headerlink" title="3.2.4.柯里化的意义"></a>3.2.4.柯里化的意义</h4><p><strong>写习惯了传统编程语言的人的第一反应一般都是，柯里化这玩意儿有啥用咧？</strong></p><p>柯里化和偏函数应用的主要意义就是固定一些我们已知的参数，然后返回一个函数继续等待接收那些未知的参数。</p><p>所以常见的使用场景之一就是高级抽象后的代码复用。例如首先编写一个多参数的通用函数，将其柯里化后，就可以基于偏函数应用将其绑定不同的业务代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义通用函数</span></span><br><span class="line"><span class="keyword">const</span> converter = (</span><br><span class="line">  toUnit,</span><br><span class="line">  factor,</span><br><span class="line">  offset = <span class="number">0</span>,</span><br><span class="line">  input</span><br><span class="line">) =&gt; ([</span><br><span class="line">  ((offset + input) * factor).toFixed(<span class="number">2</span>),</span><br><span class="line">  toUnit,</span><br><span class="line">].join(<span class="string">' '</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别绑定不同参数</span></span><br><span class="line"><span class="keyword">const</span> milesToKm =</span><br><span class="line">  curry(converter)(<span class="string">'km'</span>, <span class="number">1.60936</span>, <span class="literal">undefined</span>)</span><br><span class="line"><span class="keyword">const</span> poundsToKg =</span><br><span class="line">  curry(converter)(<span class="string">'kg'</span>, <span class="number">0.45460</span>, <span class="literal">undefined</span>)</span><br><span class="line"><span class="keyword">const</span> farenheitToCelsius =</span><br><span class="line">  curry(converter)(<span class="string">'degrees C'</span>, <span class="number">0.5556</span>, <span class="number">-32</span>)</span><br><span class="line"></span><br><span class="line">-- <span class="keyword">from</span> https:<span class="comment">//stackoverflow.com/a/6861858</span></span><br></pre></td></tr></table></figure><p>你可能会反驳说其实也可以不使用这些花里胡哨的柯里化啊，偏函数应用啊什么的东东，我就铁头娃愣头青地直接怼也能实现以上的逻辑。（这一手皮的嘛，就不谈了…）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">converter</span> (<span class="params">ratio, symbol, input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (input * ratio).toFixed(<span class="number">2</span>) + <span class="string">' '</span> + symbol</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">converter(<span class="number">2.2</span>, <span class="string">'lbs'</span>, <span class="number">4</span>)</span><br><span class="line">converter(<span class="number">1.62</span>, <span class="string">'km'</span>, <span class="number">34</span>)</span><br><span class="line">converter(<span class="number">1.98</span>, <span class="string">'US pints'</span>, <span class="number">2.4</span>)</span><br><span class="line">converter(<span class="number">1.75</span>, <span class="string">'imperial pints'</span>, <span class="number">2.4</span>)</span><br><span class="line"></span><br><span class="line">-- <span class="keyword">from</span> https:<span class="comment">//stackoverflow.com/a/32379766</span></span><br></pre></td></tr></table></figure><p>然而两者的区别在于，假如函数 <code>converter</code> 所需的参数无法同时得到，对柯里化的方式来说没有影响，因为已经用闭包保存住了已知参数。而后者可能就需要使用变量暂存或其他方法来<strong>保证同时得到所有参数</strong>。</p><h3 id="3-3-函数组合（compose）"><a href="#3-3-函数组合（compose）" class="headerlink" title="3.3.函数组合（compose）"></a>3.3.函数组合（compose）</h3><h4 id="3-3-1-组合的概念"><a href="#3-3-1-组合的概念" class="headerlink" title="3.3.1.组合的概念"></a>3.3.1.组合的概念</h4><p>函数组合就是将两个或多个函数结合起来形成一个新函数。</p><p>就好像将一节一节的管道连接起来，原始数据经过这一节一节的管道处理之后得到最终结果。</p><p>说起来很玄乎，其实就是假设有一个函数 f 和另一个函数 g，还有数据 x，经过计算最终结果就是 f(g(x))。</p><p><img src="/blog/imgs/fp-in-js/composition-of-functions.jpg" alt="composition-of-functions"></p><p>在高中数学中我们应该都学到过复合函数。</p><blockquote><p>如果 y 是 w 的函数，w 又是 x 的函数，即 y = f(w), w = g(x)，那么 y 关于 x 的函数 y = f[g(x)] 叫做函数 y = f(w) 和 w = g(x) 的复合函数。其中 w 是中间变量，x 是自变量，y 是函数值。</p></blockquote><p>此外在离散数学里，应该还学过复合函数 f(g(h(x))) 可记为 (f ○ g ○ h)(x)。（其实这就是函数组合）</p><h4 id="3-3-2-组合的实现"><a href="#3-3-2-组合的实现" class="headerlink" title="3.3.2.组合的实现"></a>3.3.2.组合的实现</h4><p><img src="/blog/imgs/fp-in-js/function-composition.png" alt="function-composition"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add1 = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> mul3 = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> div2 = <span class="function"><span class="params">x</span> =&gt;</span> x / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">div2(mul3(add1(add1(<span class="number">0</span>)))) <span class="comment">// 结果是 3，但这样写可读性太差了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> operate = compose(div2, mul3, add1, add1)</span><br><span class="line">operate(<span class="number">0</span>) <span class="comment">// =&gt; 相当于 div2(mul3(add1(add1(0))))</span></span><br><span class="line">operate(<span class="number">2</span>) <span class="comment">// =&gt; 相当于 div2(mul3(add1(add1(2))))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// redux 版</span></span><br><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (fns.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  <span class="keyword">if</span> (fns.length === <span class="number">1</span>) <span class="keyword">return</span> fns[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fns.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (...args) =&gt; a(b(...args)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一行版，支持多参数，但必须至少传一个函数</span></span><br><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> fns.reduceRight(<span class="function">(<span class="params">acc, fn</span>) =&gt;</span> (...args) =&gt; fn(acc(...args)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一行版，只支持单参数，但支持不传函数</span></span><br><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> arg =&gt; fns.reduceRight(<span class="function">(<span class="params">acc, fn</span>) =&gt;</span> fn(acc), arg)</span><br></pre></td></tr></table></figure><h4 id="3-3-3-Pointfree"><a href="#3-3-3-Pointfree" class="headerlink" title="3.3.3.Pointfree"></a>3.3.3.Pointfree</h4><p>起名字是一个很麻烦的事儿，而 <code>Pointfree</code> 风格能够有效减少大量中间变量的命名。</p><blockquote><p>Pointfree 即不使用所要处理的值，只合成运算过程。中文可以译作”无值”风格。</p></blockquote><blockquote><p>from <a href="http://www.ruanyifeng.com/blog/2017/03/pointfree.html" target="_blank" rel="noopener">Pointfree 编程风格指南</a></p></blockquote><p>请看下面的例子。（注意理解函数是一等公民和函数组合的概念）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addOne = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x * x</span><br></pre></td></tr></table></figure><p>上面是两个简单函数 <code>addOne</code> 和 <code>square</code>，现在把它们合成一个运算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addOneThenSquare = compose(square, addOne)</span><br><span class="line">addOneThenSquare(<span class="number">2</span>) <span class="comment">//  9</span></span><br></pre></td></tr></table></figure><p>上面代码中，addOneThenSquare 是一个合成函数。定义它的时候，根本不需要提到要处理的值，这就是 <code>Pointfree</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非 Pointfree，因为提到了数据：word</span></span><br><span class="line"><span class="keyword">const</span> snakeCase = <span class="function"><span class="keyword">function</span> (<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> word.toLowerCase().replace(<span class="regexp">/\s+/ig</span>, <span class="string">'_'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pointfree</span></span><br><span class="line"><span class="keyword">const</span> snakeCase = compose(replace(<span class="regexp">/\s+/ig</span>, <span class="string">'_'</span>), toLowerCase)</span><br></pre></td></tr></table></figure><p>然而可惜的是，以上很 <code>Pointfree</code> 的代码会报错，因为在 JavaScript 中 <code>replace</code> 和 <code>toLowerCase</code> 函数是定义在 <code>String</code> 的原型链上的…</p><p>此外有的库（如 Underscore、Lodash…）把需要处理的数据放到了第一个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</span><br><span class="line"></span><br><span class="line">_.map([<span class="number">4</span>, <span class="number">8</span>], square) <span class="comment">// 第一个参数是待处理数据</span></span><br><span class="line"></span><br><span class="line">R.map(square, [<span class="number">4</span>, <span class="number">8</span>]) <span class="comment">// 一般函数式库都将数据放在最后</span></span><br></pre></td></tr></table></figure><p>这样会有一些很不函数式的问题，即：</p><p>1.无法柯里化后偏函数应用</p><p>2.无法进行函数组合</p><p>3.无法扩展 map（reduce 等方法） 到各种其他类型</p><p>（详情参阅参考文献之《Hey Underscore, You’re Doing It Wrong!》）</p><h4 id="3-3-4-函数组合的意义"><a href="#3-3-4-函数组合的意义" class="headerlink" title="3.3.4.函数组合的意义"></a>3.3.4.函数组合的意义</h4><blockquote><p>首先让我们从抽象的层次来思考一下：一个 app 由什么组成？（<del>当然是由 a、p、p 三个字母组成的啦</del>）</p></blockquote><p>一个应用其实就是一个长时间运行的进程，并将一系列异步的事件转换为对应结果。</p><p><img src="/blog/imgs/fp-in-js/start-transform-effect.png" alt="start-transform-effect"></p><ul><li><p>一个 start 可以是：</p><ul><li>开启应用</li><li>DOM 事件(DOMContentLoaded, onClick, onSubmit…)</li><li>接收到的 HTTP 请求</li><li>返回的 HTTP 响应</li><li>查询数据库的结果</li><li>WebSocket 消息</li><li>..</li></ul></li><li><p>一个 end 或者说是 effect 可以是：</p><ul><li>渲染或更新 UI</li><li>触发一个 DOM 事件</li><li>创建一个 HTTP 请求</li><li>返回一个 HTTP 响应</li><li>保存数据到 DB</li><li>发送 WebSocket 消息</li><li>…</li></ul></li></ul><p>那么在 start 和 end 之间的东东，我们可以看做数据流的变换（transformations）。这些变换具体的说就是一系列的变换动词的结合。</p><p>这些动词描述了这些变换<strong>做了些什么</strong>（而不是<strong>怎么做</strong>）如：</p><ul><li>filter</li><li>slice</li><li>map</li><li>reduce</li><li>concat</li><li>zip</li><li>fork</li><li>flatten</li><li>…</li></ul><p>当然日常编写的程序中一般不会像之前的例子那样的简单，它的数据流可能是像下面这样的…</p><p><img src="/blog/imgs/fp-in-js/transformation-1.png" alt="transformation-1"><br><img src="/blog/imgs/fp-in-js/transformation-2.png" alt="transformation-2"><br><img src="/blog/imgs/fp-in-js/transformation-3.png" alt="transformation-3"><br><img src="/blog/imgs/fp-in-js/transformation-4.png" alt="transformation-4"></p><p>并且，如果这些变换在编写时，遵守了基本的函数式规则和最佳实践（纯函数，无副作用，引用透明…）。</p><p>那么这些变换可以被轻易地重用、改写、维护、测试，这也就意味着编写的应用可以很方便地进行扩展，而这些变换结合的基础正是<strong>函数组合</strong>。</p><h3 id="3-4-Hindley-Milner-类型签名"><a href="#3-4-Hindley-Milner-类型签名" class="headerlink" title="3.4.Hindley-Milner 类型签名"></a>3.4.Hindley-Milner 类型签名</h3><h4 id="3-4-1-基本概念"><a href="#3-4-1-基本概念" class="headerlink" title="3.4.1.基本概念"></a>3.4.1.基本概念</h4><p>先来看一些例子~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strLength :: String -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> strLength = <span class="function"><span class="params">s</span> =&gt;</span> s.length</span><br><span class="line"></span><br><span class="line"><span class="comment">// join :: String -&gt; [String] -&gt; String</span></span><br><span class="line"><span class="keyword">const</span> join = curry(<span class="function">(<span class="params">what, xs</span>) =&gt;</span> xs.join(what))</span><br><span class="line"></span><br><span class="line"><span class="comment">// match :: Regex -&gt; String -&gt; [String]</span></span><br><span class="line"><span class="keyword">const</span> match = curry(<span class="function">(<span class="params">reg, s</span>) =&gt;</span> s.match(reg))</span><br><span class="line"></span><br><span class="line"><span class="comment">// replace :: Regex -&gt; String -&gt; String -&gt; String</span></span><br><span class="line"><span class="keyword">const</span> replace = curry(<span class="function">(<span class="params">reg, sub, s</span>) =&gt;</span> s.replace(reg, sub))</span><br></pre></td></tr></table></figure><p>在 Hindley-Milner 系统中，函数都写成类似 a -&gt; b 这个样子，其中 a 和 b 是任意类型的变量。</p><blockquote><p>以上例子中的多参函数，可能看起来比较奇怪，为啥没有括号？</p></blockquote><p>例如对于 <code>match</code> 函数，我们将其柯里化后，完全可以把它的类型签名这样分组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// match :: Regex -&gt; (String -&gt; [String])</span></span><br><span class="line"><span class="keyword">const</span> match = curry(<span class="function">(<span class="params">reg, s</span>) =&gt;</span> s.match(reg))</span><br></pre></td></tr></table></figure><p>现在我们可以看出 <code>match</code> 这个函数首先接受了一个 <code>Regex</code> 作为参数，返回一个从 <code>String</code> 到 <code>[String]</code> 的函数。</p><p>因为柯里化，造成的结果就是这样：给 <code>match</code> 函数一个 <code>Regex</code> 参数后，得到一个新函数，它能够接着处理 <code>String</code> 参数。</p><p>假设我们将第一个参数传入 <code>/holiday/ig</code>，那么代码就变成了这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// match :: Regex -&gt; (String -&gt; [String])</span></span><br><span class="line"><span class="keyword">const</span> match = curry(<span class="function">(<span class="params">reg, s</span>) =&gt;</span> s.match(reg))</span><br><span class="line"></span><br><span class="line"><span class="comment">// onHoliday :: String -&gt; [String]</span></span><br><span class="line"><span class="keyword">const</span> onHoliday = match(<span class="regexp">/holiday/ig</span>)</span><br></pre></td></tr></table></figure><p>可以看出柯里化后每传一个参数，就会弹出类型签名最前面的那个类型。所以 <code>onHoliday</code> 就是已经有了 <code>Regex</code> 参数的 <code>match</code> 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// replace :: Regex -&gt; (String -&gt; (String -&gt; String))</span></span><br><span class="line"><span class="keyword">const</span> replace = curry(<span class="function">(<span class="params">reg, sub, s</span>) =&gt;</span> s.replace(reg, sub))</span><br></pre></td></tr></table></figure><p>同样的思路来看最后一个函数 <code>replace</code>，可以看出为 <code>replace</code> 加上这么多括号未免有些多余。</p><p>所以这里的括号是完全可以省略的，如果我们愿意，甚至可以一次性把所有的参数都传进来。</p><p>再来看几个例子~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  id :: a -&gt; a</span></span><br><span class="line"><span class="keyword">const</span> id = <span class="function"><span class="params">x</span> =&gt;</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment">//  map :: (a -&gt; b) -&gt; [a] -&gt; [b]</span></span><br><span class="line"><span class="keyword">const</span> map = curry(<span class="function">(<span class="params">f, xs</span>) =&gt;</span> xs.map(f))</span><br></pre></td></tr></table></figure><p>这里的 id 函数接受任意类型的 a 并返回同一个类型的数据（话说 map 的签名里为啥加了括号呢~）。</p><p>和普通代码一样，我们也可以在类型签名中使用变量。把变量命名为 a 和 b 只是一种约定俗成的习惯，你可以使用任何你喜欢的名称。但对于相同的变量名，其类型一定相同。</p><p>这是非常重要的一个原则，所以我们必须重申：a -&gt; b 可以是从任意类型的 a 到任意类型的 b，但是 a -&gt; a 必须是同一个类型。</p><p>例如，id 可以是 String -&gt; String，也可以是 Number -&gt; Number，但不能是 String -&gt; Bool。</p><p>相似地，map 也使用了变量，只不过这里的 b 可能与 a 类型相同，也可能不相同。</p><p>我们可以这么理解：map 接受两个参数，第一个是从任意类型 a 到任意类型 b 的函数；第二个是一个数组，元素是任意类型的 a；map 最后返回的是一个类型 b 的数组。</p><p>辨别类型和它们的含义是一项重要的技能，这项技能可以让你在函数式编程的路上走得更远。不仅论文、博客和文档等更易理解，类型签名本身也基本上能够告诉你它的函数性（functionality）。要成为一个能够熟练读懂类型签名的人，你得勤于练习；不过一旦掌握了这项技能，你将会受益无穷，不读手册也能获取大量信息。</p><p>最后再举几个复杂的例子~~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  head :: [a] -&gt; a</span></span><br><span class="line"><span class="keyword">const</span> head = <span class="function"><span class="params">xs</span> =&gt;</span> xs[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//  filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</span></span><br><span class="line"><span class="keyword">const</span> filter = curry(<span class="function">(<span class="params">f, xs</span>) =&gt;</span> xs.filter(f))</span><br><span class="line"></span><br><span class="line"><span class="comment">//  reduce :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</span></span><br><span class="line"><span class="keyword">const</span> reduce = curry(<span class="function">(<span class="params">f, x, xs</span>) =&gt;</span> xs.reduce(f, x))</span><br></pre></td></tr></table></figure><p>reduce 可能是以上签名里让人印象最为深刻的一个，同时也是最复杂的一个了，所以如果你理解起来有困难的话，也不必气馁。为了满足你的好奇心，我还是试着解释一下吧；尽管我的解释远远不如你自己通过类型签名理解其含义来得有教益。</p><p>不保证解释完全正确…（译者注：此处原文是“here goes nothing”，一般用于人们在做没有把握的事情之前说的话。）</p><p>注意看 reduce 的签名，可以看到它的第一个参数是个函数（所以用了括号），这个函数接受一个 b 和一个 a 并返回一个 b。</p><p>那么这些 a 和 b 是从哪来的呢？</p><p>很简单，签名中的第二个和第三个参数就是 b 和元素为 a 的数组，所以唯一合理的假设就是这里的 b 和每一个 a 都将传给前面说的函数作为参数。我们还可以看到，reduce 函数最后返回的结果是一个 b，也就是说，reduce 的第一个参数函数的输出就是 reduce 函数的输出。知道了 reduce 的含义，我们才敢说上面关于类型签名的推理是正确的。</p><h4 id="3-4-2-参数态（Parametricity）"><a href="#3-4-2-参数态（Parametricity）" class="headerlink" title="3.4.2.参数态（Parametricity）"></a>3.4.2.参数态（Parametricity）</h4><p>一旦引入一个类型变量，就会出现一个奇怪的特性叫做参数态。</p><p>这个特性表明，函数将会以一种统一的行为作用于所有的类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head :: [a] -&gt; a</span></span><br></pre></td></tr></table></figure><p>以 head 函数为例，可以看到它接受 [a] 返回 a。我们除了知道参数是个数组，其他的一概不知；所以函数的功能就只限于操作这个数组上。</p><p>在它对 a 一无所知的情况下，它可能对 a 做什么操作呢？</p><p>换句话说，a 告诉我们它不是一个<strong>特定</strong>的类型，这意味着它可以是<strong>任意</strong>类型；那么我们的函数对每一个可能的类型的操作都必须保持统一，这就是参数态的含义。</p><p>要让我们来猜测 head 的实现的话，唯一合理的推断就是它返回数组的第一个，或者最后一个，或者某个随机的元素；当然，head 这个命名已经告诉我们了答案。</p><p>再看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reverse :: [a] -&gt; [a]</span></span><br></pre></td></tr></table></figure><p>仅从类型签名来看，reverse 可能的目的是什么？</p><p>再次强调，它不能对 a 做任何特定的事情。它不能把 a 变成另一个类型，或者引入一个 b；这都是不可能的。</p><p>那它可以排序么？我觉得不行，我觉得很普通~，没有足够的信息让它去为每一个可能的类型排序。</p><p><img width="200" src="/blog/imgs/fp-in-js/i-don't-think-so.jpg" alt="i-don't-think-so"></p><p>它能重新排列么？我觉得还 ok，但它必须以一种可预料的方式达成目标。另外，它也有可能删除或者重复某一个元素。</p><p><img width="200" src="/blog/imgs/fp-in-js/i-think-it-is-ok.jpg" alt="i-think-it-is-ok"></p><p>重点是，不管在哪种情况下，类型 a 的多态性（polymorphism）都会大幅缩小 reverse 函数可能的行为的范围。</p><p><img src="/blog/imgs/fp-in-js/hoogle.png" alt="hoogle"></p><p>这种“可能性范围的缩小”（narrowing of possibility）允许我们利用类似 <a href="https://www.haskell.org/hoogle/" target="_blank" rel="noopener">Hoogle</a> 这样的类型签名搜索引擎去搜索我们想要的函数。类型签名所能包含的信息量真的非常大。</p><h4 id="3-4-3-自由定理（Free-Theorems）"><a href="#3-4-3-自由定理（Free-Theorems）" class="headerlink" title="3.4.3.自由定理（Free Theorems）"></a>3.4.3.自由定理（Free Theorems）</h4><p>类型签名除了能够帮助我们推断函数可能的实现，还能够给我们带来自由定理。下面是两个直接从 <a href="http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf" target="_blank" rel="noopener">Wadler 关于此主题的论文</a> 中随机选择的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head :: [a] -&gt; a</span></span><br><span class="line">compose(f, head) === compose(head, map(f))</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</span></span><br><span class="line"><span class="comment">// 其中 f 和 p 是谓词函数</span></span><br><span class="line">compose(map(f), filter(compose(p, f))) ===</span><br><span class="line">  compose(filter(p), map(f))</span><br></pre></td></tr></table></figure><p>不用写一行代码你也能理解这些定理，它们直接来自于类型本身。</p><p>第一个例子中，等式左边说的是，先获取数组的头部（译者注：即第一个元素），然后对它调用函数 f；等式右边说的是，先对数组中的每一个元素调用 f，然后再取其返回结果的头部。这两个表达式的作用是相等的，但是前者要快得多。</p><p>第二个例子 filter 也是一样。等式左边是说，先组合 f 和 p 检查哪些元素要过滤掉，然后再通过 map 实际调用 f（别忘了 filter 是不会改变数组中元素的，这就保证了 a 将保持不变）；等式右边是说，先用 map 调用 f，然后再根据 p 过滤元素。这两者也是相等的。</p><p>你可能会想，这不是常识么。但计算机是没有常识的。实际上，计算机必须要有一种形式化方法来自动进行类似的代码优化。数学提供了这种方法，能够形式化直观的感觉，这无疑对死板的计算机逻辑非常有用。</p><p>以上只是两个例子，但它们传达的定理却是普适的，可以应用到所有的多态性类型签名上。在 JavaScript 中，你可以借助一些工具来声明重写规则，也可以直接使用 compose 函数来定义重写规则。总之，这么做的好处是显而易见且唾手可得的，可能性则是无限的。</p><h4 id="3-4-4-类型约束"><a href="#3-4-4-类型约束" class="headerlink" title="3.4.4.类型约束"></a>3.4.4.类型约束</h4><p>最后要注意的一点是，签名也可以把类型约束为一个特定的接口（interface）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort :: Ord a =&gt; [a] -&gt; [a]</span></span><br></pre></td></tr></table></figure><p>胖箭头左边表明的是这样一个事实：a 一定是个 Ord 对象，或者说 a 必须要实现 Ord 接口。</p><p>Ord 到底是什么？它是从哪来的？在一门强类型语言中，它可能就是一个自定义的接口，能够让不同的值排序。通过这种方式，我们不仅能够获取关于 a 的更多信息，了解 sort 函数具体要干什么，而且还能限制函数的作用范围。我们把这种接口声明叫做类型约束（type constraints）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assertEqual :: (Eq a, Show a) =&gt; a -&gt; a -&gt; Assertion</span></span><br></pre></td></tr></table></figure><p>这个例子中有两个约束：Eq 和 Show。它们保证了我们可以检查不同的 a 是否相等，并在有不相等的情况下打印出其中的差异。</p><h4 id="3-4-5-类型签名的作用"><a href="#3-4-5-类型签名的作用" class="headerlink" title="3.4.5.类型签名的作用"></a>3.4.5.类型签名的作用</h4><p>总结一下类型签名的作用就是：</p><ul><li>声明函数的输入和输出</li><li>让函数保持通用和抽象</li><li>可以用于编译时候检查</li><li>代码是最好的文档</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/" target="_blank" rel="noopener">JS函数式编程指南</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/03/pointfree.html" target="_blank" rel="noopener">Pointfree 编程风格指南</a></li><li><a href="https://www.youtube.com/watch?v=m3svKOdZijA" target="_blank" rel="noopener">Hey Underscore, You’re Doing It Wrong!</a></li><li><a href="https://www.youtube.com/watch?v=yXJtrxVZmT4" target="_blank" rel="noopener">Functional Concepts with JavaScript: Part I</a></li><li><a href="https://egghead.io/courses/professor-frisby-introduces-composable-functional-javascript" target="_blank" rel="noopener">Professor Frisby Introduces Composable Functional JavaScript</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html" target="_blank" rel="noopener">函数式编程入门教程</a></li></ul><p>以上 to be continued…</p><blockquote><p>本文地址： <a href="https://buptsteve.github.io/blog/2017/11/23/010.fp-in-js-2/" target="_blank" rel="external">https://buptsteve.github.io/blog/2017/11/23/010.fp-in-js-2/</a></p><footer><cite><a href="https://buptsteve.github.io/blog">@BuptStEve's Blog</a></cite></footer></blockquote></div><nav class="post-nav"><div class="waves-block waves-effect prev fl"><a href="/blog/2018/05/21/011.say-goodbye-to-mina-setData/" id="post-prev" class="post-nav-link"><div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div><h4 class="title">「11」终极蛇皮上帝视角之微信小程序之告别 setData</h4></a></div><div class="waves-block waves-effect next fr"><a href="/blog/2017/10/10/009.fp-in-js-1/" id="post-next" class="post-nav-link"><div class="tips">Next<i class="icon icon-angle-right icon-lg icon-pl"></i></div><h4 class="title">「9」JavaScript 函数式编程（一）</h4></a></div></nav></div></div></article></div></main><div class="mask" id="mask"></div><a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a><script src="/blog/js/wave.min.js"></script><script src="/blog/js/main.js"></script><div class="search-panel" id="search-panel"><ul class="search-result" id="search-result"></ul></div><script type="text/template" id="search-tpl"><li class="item">
        <a href="/{path}" class="waves-block waves-effect">
            <div class="title ellipsis" title="{title}">{title}</div>
            
            <div class="flex-row flex-middle">
                <div class="tags ellipsis">
                    {tags}
                </div>

                <time class="flex-col time">{date}</time>
            </div>
        </a>
    </li></script><script src="/blog/js/search.js"></script><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="//www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-85691829-1","auto"),ga("send","pageview")</script></body></html>