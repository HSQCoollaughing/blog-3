<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="keywords" content=""><meta name="theme-color" content="#3F51B5"><meta name="summary" content="BuptStEve"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>「16」如何构建通用存储中间层 | BuptStEve&#39;s Blog | Talk is cheap show me the offer!</title><meta name="description" content="零、问题的由来开门见山地说，这篇文章【又】是一篇安利软文~，安利的对象就是 tua-storage。 顾名思义，这就是一款存储数据的工具。  用 tua-storage 好处大大的有么？  那必须滴~，下面开始我的表演~  多端统一 api 支持数据同步 数据过期逻辑 自动清理过期数据 支持永久保存 支持批量操作  一、多端统一 api日常开发中，在不同的平台下由于有不同的存储层接口，所以往往导致"><meta name="keywords" content="tua,storage"><meta property="og:type" content="article"><meta property="og:title" content="「16」如何构建通用存储中间层"><meta property="og:url" content="https://buptsteve.github.io/blog/2018/11/16/016.how-to-build-a-common-storage-layer/index.html"><meta property="og:site_name" content="BuptStEve&#39;s Blog"><meta property="og:description" content="零、问题的由来开门见山地说，这篇文章【又】是一篇安利软文~，安利的对象就是 tua-storage。 顾名思义，这就是一款存储数据的工具。  用 tua-storage 好处大大的有么？  那必须滴~，下面开始我的表演~  多端统一 api 支持数据同步 数据过期逻辑 自动清理过期数据 支持永久保存 支持批量操作  一、多端统一 api日常开发中，在不同的平台下由于有不同的存储层接口，所以往往导致"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/tua/贪玩一笑.jpg"><meta property="og:updated_time" content="2018-11-20T07:33:31.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="「16」如何构建通用存储中间层"><meta name="twitter:description" content="零、问题的由来开门见山地说，这篇文章【又】是一篇安利软文~，安利的对象就是 tua-storage。 顾名思义，这就是一款存储数据的工具。  用 tua-storage 好处大大的有么？  那必须滴~，下面开始我的表演~  多端统一 api 支持数据同步 数据过期逻辑 自动清理过期数据 支持永久保存 支持批量操作  一、多端统一 api日常开发中，在不同的平台下由于有不同的存储层接口，所以往往导致"><meta name="twitter:image" content="https://buptsteve.github.io/blog/imgs/tua/贪玩一笑.jpg"><link rel="shortcut icon" href="/blog/img/favicon.ico"><link rel="stylesheet" href="/blog/css/style.css"><link rel="alternative" href="/blog/atom.xml" title="BuptStEve&#39;s Blog" type="application/atom+xml"></head><body><div id="loading" class="active"></div><nav id="menu" class="hide"><div class="inner flex-row-vertical"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off"><i class="icon icon-lg icon-close"></i></a><div class="brand-wrap"><div class="brand"><a href="/blog" class="avatar"><img src="/blog/img/logo.jpg"></a><hgroup class="introduce"><h5 class="nickname">Steve Young</h5><a href="mailto:yangzhenyu2016@gmail.com" title="yangzhenyu2016@gmail.com" class="mail">yangzhenyu2016@gmail.com</a></hgroup></div></div><div class="scroll-wrap flex-col"><ul class="nav"><li class="waves-block waves-effect"><a href="/blog/"><i class="icon icon-lg icon-home"></i> 主页</a></li><li class="waves-block waves-effect"><a href="/blog/archives"><i class="icon icon-lg icon-archives"></i> Archives</a></li><li class="waves-block waves-effect"><a href="/blog/tags"><i class="icon icon-lg icon-tags"></i> Tags</a></li><li class="waves-block waves-effect"><a href="https://github.com/buptsteve" target="_blank"><i class="icon icon-lg icon-github"></i> Github</a></li><li class="waves-block waves-effect"><a href="http://weibo.com/0osteveyoungo0" target="_blank"><i class="icon icon-lg icon-weibo"></i> Weibo</a></li></ul><footer class="footer"><p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC"></a></p><p>BuptStEve&#39;s Blog &copy; 2018</p><p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p><a href="/blog/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a></footer></div></div></nav><main id="main"><header class="top-header" id="header"><div class="flex-row"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle"><i class="icon icon-lg icon-navicon"></i></a><div class="flex-col header-title ellipsis">「16」如何构建通用存储中间层</div><div class="search-wrap" id="search-wrap"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i></a> <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search"><i class="icon icon-lg icon-search"></i></a></div></div></header><header class="content-header"><div class="container"><h1 class="author">「16」如何构建通用存储中间层</h1><h5 class="subtitle"><time datetime="2018-11-16T02:27:00.000Z" itemprop="datePublished" class="page-time">2018-11-16</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/全栈/">全栈</a></li></ul></h5></div></header><div class="container body-wrap"><article id="post-016.how-to-build-a-common-storage-layer" class="article article-type-post" itemprop="blogPost"><div class="post-meta flex-row"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/storage/">storage</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/tua/">tua</a></li></ul></div><div class="post-body"><aside class="post-widget" id="post-widget"><nav class="post-toc-wrap" id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#零、问题的由来"><span class="post-toc-text">零、问题的由来</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#一、多端统一-api"><span class="post-toc-text">一、多端统一 api</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-1-异步方法"><span class="post-toc-text">1.1.异步方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-2-同步方法"><span class="post-toc-text">1.2.同步方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-3-区分场景"><span class="post-toc-text">1.3.区分场景</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二、支持数据同步"><span class="post-toc-text">二、支持数据同步</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-数据同步函数"><span class="post-toc-text">2.1.数据同步函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-合并分散配置"><span class="post-toc-text">2.2.合并分散配置</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-3-自动生成配置"><span class="post-toc-text">2.3.自动生成配置</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#三、数据过期逻辑"><span class="post-toc-text">三、数据过期逻辑</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1-默认过期时间"><span class="post-toc-text">3.1.默认过期时间</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-数据保存前缀"><span class="post-toc-text">3.2.数据保存前缀</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-白名单机制"><span class="post-toc-text">3.3.白名单机制</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#四、自动清理过期数据"><span class="post-toc-text">四、自动清理过期数据</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-1-清理逻辑"><span class="post-toc-text">4.1.清理逻辑</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-清理时间间隔"><span class="post-toc-text">4.2.清理时间间隔</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#五、支持永久保存"><span class="post-toc-text">五、支持永久保存</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#六、支持批量操作"><span class="post-toc-text">六、支持批量操作</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#七、小结"><span class="post-toc-text">七、小结</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#灵感来源"><span class="post-toc-text">灵感来源</span></a></li></ol></nav></aside><div class="post-main"><div class="post-content" id="post-content" itemprop="postContent"><h2 id="零、问题的由来"><a href="#零、问题的由来" class="headerlink" title="零、问题的由来"></a>零、问题的由来</h2><p>开门见山地说，这篇文章【又】是一篇安利软文~，安利的对象就是 <a href="https://github.com/tuateam/tua-storage" target="_blank" rel="noopener">tua-storage</a>。</p><p>顾名思义，这就是一款存储数据的工具。</p><blockquote><p>用 tua-storage 好处大大的有么？</p></blockquote><p>那必须滴~，下面开始我的表演~</p><ul><li>多端统一 api</li><li>支持数据同步</li><li>数据过期逻辑</li><li>自动清理过期数据</li><li>支持永久保存</li><li>支持批量操作</li></ul><h2 id="一、多端统一-api"><a href="#一、多端统一-api" class="headerlink" title="一、多端统一 api"></a>一、多端统一 api</h2><p>日常开发中，在不同的平台下由于有不同的存储层接口，所以往往导致相同逻辑的同一份代码要写几份儿。</p><p>例如，小程序中保存数据要使用【异步】的 <code>wx.setStorage</code>、<code>wx.getStorage</code> 或对应的同步方法；</p><p>而在 web 端使用 localStorage 的话，则是【同步】的 <code>setItem</code>、<code>getItem</code> 等方法；</p><p>在 React-Native 的场景下，使用的又是 <code>AsyncStorage</code> 中【异步】的 <code>setItem</code>、<code>getItem</code>…</p><h3 id="1-1-异步方法"><a href="#1-1-异步方法" class="headerlink" title="1.1.异步方法"></a>1.1.异步方法</h3><p>然而，经过 <code>tua-storage</code> 的二次封装，以上两个方法统一变成了：</p><ul><li><code>save</code>: 异步保存</li><li><code>load</code>: 异步读取</li></ul><p>此外还有一些其他方法：</p><ul><li><code>clear</code>: 异步清除（删除多个）</li><li><code>remove</code>: 异步删除（删除单个）</li><li><code>getInfo</code>: 异步获取信息（如 <code>keys</code>）</li></ul><p><a href="https://tuateam.github.io/tua-storage/config-methods/methods.html" target="_blank" rel="noopener">详情参阅这里的文档</a></p><h3 id="1-2-同步方法"><a href="#1-2-同步方法" class="headerlink" title="1.2.同步方法"></a>1.2.同步方法</h3><p>在某些场景下正好需要调用同步方法的话，咋办咧？</p><p>与 Node.js 的 api 风格差不多，在上述异步方法后面加上 <code>Sync</code> 就是对应的同步方法：</p><ul><li><code>saveSync</code></li><li><code>loadSync</code></li><li><code>clearSync</code></li><li><code>removeSync</code></li><li><code>getInfoSync</code></li></ul><p>那么在 <code>AsyncStorage</code> 的场景下，压根就没有同步方法时调用以上方法会怎么样呢？</p><p>嗯，你猜得没错，会直接报错…</p><h3 id="1-3-区分场景"><a href="#1-3-区分场景" class="headerlink" title="1.3.区分场景"></a>1.3.区分场景</h3><blockquote><p>如何区分不同的场景呢？</p></blockquote><p>在初始化的时候传递 <code>storageEngine</code> 即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TuaStorage <span class="keyword">from</span> <span class="string">'tua-storage'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tuaStorage = <span class="keyword">new</span> TuaStorage(&#123;</span><br><span class="line">    <span class="comment">// 小程序</span></span><br><span class="line">    storageEngine: wx,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// web</span></span><br><span class="line">    storageEngine: localStorage,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// React-Native</span></span><br><span class="line">    storageEngine: AsyncStorage,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Node.js</span></span><br><span class="line">    storageEngine: &#123;&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注意：传递的是【对象】，而非字符串！</p></blockquote><h2 id="二、支持数据同步"><a href="#二、支持数据同步" class="headerlink" title="二、支持数据同步"></a>二、支持数据同步</h2><p>对于一个二次封装多端存储层的库来说，保证多端 api 的统一仅仅是常规操作而已。</p><p><code>tua-storage</code> 的另一大亮点就是数据同步功能。</p><p>想想平时我们是怎么使用存储层的</p><ul><li>读取一个数据</li><li>正好存储层里有这个数据<ul><li>返回数据（皆大欢喜，happy ending~）</li></ul></li><li>假如存储层里没这个数据<ul><li>手动调用各种方法去同步这个数据</li><li>手动存到存储层中，以便下次读取</li></ul></li></ul><blockquote><p>各位有没有看出其中麻烦的地方在哪儿？</p></blockquote><blockquote><p><strong>数据同步部分的复杂度全留给了业务侧。</strong></p></blockquote><p>让我们回归这件事的【<strong>初心</strong>】：我仅仅需要获取这个数据！我不管它是来自存储层、来自接口数据、还是来自其他什么地方…</p><h3 id="2-1-数据同步函数"><a href="#2-1-数据同步函数" class="headerlink" title="2.1.数据同步函数"></a>2.1.数据同步函数</h3><p>因此 <code>tua-storage</code> 在读取数据时很贴心地提供了一个 <code>syncFn</code> 参数，作为数据同步的函数，当请求的数据不存在或已过期时自动调用该函数。并且数据同步后默认会保存下来，这样下次再请求时存储层中就有数据了。</p><p><code>syncParams</code> 的使用场景是接口需要传参时，这些参数会传给 <code>syncFn</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tuaStorage.load(&#123;</span><br><span class="line">    key: <span class="string">'some data'</span>,</span><br><span class="line">    syncFn: <span class="function">(<span class="params">&#123; a &#125;</span>) =&gt;</span> axios(<span class="string">'some api url'</span> + a),</span><br><span class="line">    <span class="comment">// 以下参数会传到 syncFn 中</span></span><br><span class="line">    syncParams: &#123; <span class="attr">a</span>: <span class="string">'a'</span> &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这么一来，存储层就和接口层对接起来了。业务侧再也不用手动调用 api 获取数据。</p><h3 id="2-2-合并分散配置"><a href="#2-2-合并分散配置" class="headerlink" title="2.2.合并分散配置"></a>2.2.合并分散配置</h3><p>每次读取数据时如果都要手动传同步函数，实际编码时还是很麻烦…</p><blockquote><p>不急，吃口药~</p></blockquote><p><code>tua-storage</code> 在初始化时能够传递一个叫做 <code>syncFnMap</code> 参数。顾名思义，这是一个将 <code>key</code> 和 <code>syncFn</code> 映射起来的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tuaStorage = <span class="keyword">new</span> TuaStorage(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    syncFnMap: &#123;</span><br><span class="line">        <span class="string">'data one'</span>: <span class="function"><span class="params">()</span> =&gt;</span> axios(<span class="string">'data one api'</span>),</span><br><span class="line">        <span class="string">'data two'</span>: <span class="function"><span class="params">()</span> =&gt;</span> axios(<span class="string">'data two api'</span>),</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不用手动传 syncFn，默认匹配 syncFnMap 中的对应函数</span></span><br><span class="line">tuaStorage.load(&#123; <span class="attr">key</span>: <span class="string">'data one'</span> &#125;)</span><br></pre></td></tr></table></figure><h3 id="2-3-自动生成配置"><a href="#2-3-自动生成配置" class="headerlink" title="2.3.自动生成配置"></a>2.3.自动生成配置</h3><p>其实手动编写每个 api 请求函数也是很繁琐的，要是有个根据配置自动生成请求函数的库就好了~</p><p>诶~，巧了么不是~。各位开发者老爷们了解一下同样跨平台的 <a href="https://tuateam.github.io/tua-api/" target="_blank" rel="noopener">tua-api</a> ~？</p><p><code>tua-storage</code> 搭配 <code>tua-api</code> 之后会变成这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TuaStorage <span class="keyword">from</span> <span class="string">'tua-storage'</span></span><br><span class="line"><span class="keyword">import</span> &#123; getSyncFnMapByApis &#125; <span class="keyword">from</span> <span class="string">'tua-api'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地写好的各种接口配置</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> apis <span class="keyword">from</span> <span class="string">'@/apis'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tuaStorage = <span class="keyword">new</span> TuaStorage(&#123;</span><br><span class="line">    syncFnMap: getSyncFnMapByApis(apis),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="三、数据过期逻辑"><a href="#三、数据过期逻辑" class="headerlink" title="三、数据过期逻辑"></a>三、数据过期逻辑</h2><p>一般各个平台的存储层都没有数据过期这一逻辑。但在使用 <code>tua-storage</code> 时默认每个数据都有过期时间这一属性。</p><h3 id="3-1-默认过期时间"><a href="#3-1-默认过期时间" class="headerlink" title="3.1.默认过期时间"></a>3.1.默认过期时间</h3><p>默认为 30 秒，可以在初始化时配置默认超时时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TuaStorage <span class="keyword">from</span> <span class="string">'tua-storage'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tuaStorage = <span class="keyword">new</span> TuaStorage(&#123;</span><br><span class="line">    <span class="comment">// 改为 60 秒</span></span><br><span class="line">    defaultExpires: <span class="number">60</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个 Promise</span></span><br><span class="line">tuaStorage</span><br><span class="line">    .save(&#123;</span><br><span class="line">        key: <span class="string">'data key'</span>,</span><br><span class="line">        data: &#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里传递的过期时间优先级更高</span></span><br><span class="line">        expires: <span class="number">90</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="built_in">console</span>.log)</span><br><span class="line">    .catch(<span class="built_in">console</span>.error)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存到 storage 中的数据大概长这样</span></span><br><span class="line"><span class="comment">// key 之前会加上初始化传入的默认前缀</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">'TUA_STORAGE_PREFIX: data key'</span>: &#123;</span><br><span class="line">        expires: <span class="number">90</span>,</span><br><span class="line">        rawData: &#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-数据保存前缀"><a href="#3-2-数据保存前缀" class="headerlink" title="3.2.数据保存前缀"></a>3.2.数据保存前缀</h3><p>为了保证存在 storage 中的数据名称不冲突，以及实现版本控制，<code>tua-storage</code> 默认有一个存储前缀：<code>storageKeyPrefix</code>。</p><p>默认值为 <code>TUA_STORAGE_PREFIX:</code>，所以在上一小节中保存的数据会有一个奇怪的前缀。</p><blockquote><p>保证名称不冲突很好理解，如何实现版本控制呢？</p></blockquote><h3 id="3-3-白名单机制"><a href="#3-3-白名单机制" class="headerlink" title="3.3.白名单机制"></a>3.3.白名单机制</h3><p><code>clear</code> 函数能够接受一个白名单数组（因为内部是通过 <code>indexOf</code> 来判断的，所以不必填写完整的 <code>key</code> 值）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TuaStorage <span class="keyword">from</span> <span class="string">'tua-storage'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tuaStorage = <span class="keyword">new</span> TuaStorage(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">tuaStorage.clear([<span class="string">'key'</span>])</span><br><span class="line">    .then(<span class="built_in">console</span>.log)</span><br><span class="line">    .catch(<span class="built_in">console</span>.error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设现在 storage 中有以下数据</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">'foo'</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">'bar'</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">'foo-key'</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">'bar-key'</span>: &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除后剩下的数据是</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">'foo-key'</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">'bar-key'</span>: &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在调用 <code>clear</code> 时，在白名单中传入新的存储前缀，即可实现删除上一版本数据的功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TuaStorage <span class="keyword">from</span> <span class="string">'tua-storage'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上一版本的前缀</span></span><br><span class="line"><span class="keyword">const</span> prefix1 = <span class="string">'STORAGE_PREFIX_V1.0: '</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一版本的前缀</span></span><br><span class="line"><span class="keyword">const</span> prefix2 = <span class="string">'STORAGE_PREFIX_V1.1: '</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tuaStorage = <span class="keyword">new</span> TuaStorage(&#123;</span><br><span class="line">    <span class="comment">// 将默认前缀切换成新版本的</span></span><br><span class="line">    storageKeyPrefix: prefix2,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始清除上个版本的数据</span></span><br><span class="line">tuaStorage.clear([ prefix2 ])</span><br><span class="line">    .then(<span class="built_in">console</span>.log)</span><br><span class="line">    .catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure><p><a href="https://tuateam.github.io/tua-storage/config-methods/default.html" target="_blank" rel="noopener">更多默认配置参阅这里的文档</a></p><h2 id="四、自动清理过期数据"><a href="#四、自动清理过期数据" class="headerlink" title="四、自动清理过期数据"></a>四、自动清理过期数据</h2><p>默认在启动时会进行一次过期数据清理（可以关闭），之后每过一段时间会再次清理。</p><blockquote><p>什么样的数据会被清理呢？</p></blockquote><h3 id="4-1-清理逻辑"><a href="#4-1-清理逻辑" class="headerlink" title="4.1.清理逻辑"></a>4.1.清理逻辑</h3><p>首先当然是清理已到过期时间的数据，即有一个属性为 <code>expires</code> 的数据，且当前时间已超过了该时间。</p><p>一旦遇到不满足格式的数据（非对象、没有 <code>expires</code> 属性）则跳过，这样就不会误清除其他程序保存的数据。</p><h3 id="4-2-清理时间间隔"><a href="#4-2-清理时间间隔" class="headerlink" title="4.2.清理时间间隔"></a>4.2.清理时间间隔</h3><p>在初始化时可传入 <code>autoClearTime</code> 修改默认自动清理时间间隔。</p><p>默认为一分钟，注意是以秒为单位。</p><h2 id="五、支持永久保存"><a href="#五、支持永久保存" class="headerlink" title="五、支持永久保存"></a>五、支持永久保存</h2><p>在某些场景下，可能不方便写过期时间，这时默认可以传递 <code>expires: null</code>，标记该数据永不过期。</p><blockquote><p>不喜欢用 <code>null</code> 标记？</p></blockquote><p>大丈夫~，初始化时传递 <code>neverExpireMark</code> 即可修改为你喜欢的别的标记。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TuaStorage <span class="keyword">from</span> <span class="string">'tua-storage'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tuaStorage = <span class="keyword">new</span> TuaStorage(&#123;</span><br><span class="line">    neverExpireMark: <span class="string">'never'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 永不过期</span></span><br><span class="line">tuaStorage.save(&#123;</span><br><span class="line">    key: <span class="string">'some key'</span>,</span><br><span class="line">    data: <span class="string">'some data'</span>,</span><br><span class="line">    expires: <span class="string">'never'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="六、支持批量操作"><a href="#六、支持批量操作" class="headerlink" title="六、支持批量操作"></a>六、支持批量操作</h2><p>假设现在有一组数据需要保存或读取，常规操作就是使用 <code>Promise.all</code> 发起多个操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TuaStorage <span class="keyword">from</span> <span class="string">'tua-storage'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tuaStorage = <span class="keyword">new</span> TuaStorage(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dataToBeSaved = [</span><br><span class="line">    &#123; <span class="attr">key</span>: <span class="string">'key one'</span>, <span class="attr">data</span>: <span class="string">'some data'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">key</span>: <span class="string">'key two'</span>, <span class="attr">data</span>: <span class="string">'some data'</span> &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步</span></span><br><span class="line"><span class="keyword">const</span> result = dataToBeSaved</span><br><span class="line">    .map(tuaStorage.save.bind(tuaStorage))</span><br><span class="line">    .then(<span class="built_in">Promise</span>.all.bind(<span class="built_in">Promise</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步</span></span><br><span class="line"><span class="keyword">const</span> result = dataToBeSaved</span><br><span class="line">    .map(tuaStorage.saveSync.bind(tuaStorage))</span><br></pre></td></tr></table></figure><p>讲道理这样写还是挺烦的…所以 <code>tua-storage</code> 的各个 api 还支持直接传入数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步</span></span><br><span class="line">tuaStorage.save(dataToBeSaved)</span><br><span class="line">    .then(<span class="built_in">console</span>.log)</span><br><span class="line">    .catch(<span class="built_in">console</span>.log)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步</span></span><br><span class="line">tuaStorage.saveSync(dataToBeSaved)</span><br></pre></td></tr></table></figure><h2 id="七、小结"><a href="#七、小结" class="headerlink" title="七、小结"></a>七、小结</h2><p>还在为 web 端、小程序端、React-Native 端、node 端业务侧代码使用不一样的方式调用存储层烦恼么？还在为手动数据同步，保存数据，处理过期逻辑而烦躁么？各位开发者老爷们不妨试一试 <a href="https://github.com/tuateam/tua-storage" target="_blank" rel="noopener">tua-storage</a>，（挤需体验三番钟，里造会干我一样，爱象介款工具）。</p><p><img src="/blog/imgs/tua/贪玩一笑.jpg" alt="贪玩一笑"></p><h2 id="灵感来源"><a href="#灵感来源" class="headerlink" title="灵感来源"></a>灵感来源</h2><p>inspired by <a href="https://github.com/sunnylqm/react-native-storage" target="_blank" rel="noopener">react-native-storage</a></p><blockquote><p>本文地址： <a href="https://buptsteve.github.io/blog/2018/11/16/016.how-to-build-a-common-storage-layer/" target="_blank" rel="external">https://buptsteve.github.io/blog/2018/11/16/016.how-to-build-a-common-storage-layer/</a></p><footer><cite><a href="https://buptsteve.github.io/blog">@BuptStEve's Blog</a></cite></footer></blockquote></div><nav class="post-nav"><div class="waves-block waves-effect next fr"><a href="/blog/2018/11/05/015.how-to-build-a-common-api-layer/" id="post-next" class="post-nav-link"><div class="tips">Next<i class="icon icon-angle-right icon-lg icon-pl"></i></div><h4 class="title">「15」如何构建通用 api 中间层</h4></a></div></nav></div></div></article></div></main><div class="mask" id="mask"></div><a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a><script src="/blog/js/wave.min.js"></script><script src="/blog/js/main.js"></script><div class="search-panel" id="search-panel"><ul class="search-result" id="search-result"></ul></div><script type="text/template" id="search-tpl"><li class="item">
        <a href="/{path}" class="waves-block waves-effect">
            <div class="title ellipsis" title="{title}">{title}</div>
            
            <div class="flex-row flex-middle">
                <div class="tags ellipsis">
                    {tags}
                </div>

                <time class="flex-col time">{date}</time>
            </div>
        </a>
    </li></script><script src="/blog/js/search.js"></script><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="//www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-85691829-1","auto"),ga("send","pageview")</script></body></html>