<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="keywords" content=""><meta name="theme-color" content="#3F51B5"><meta name="summary" content="BuptStEve"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>「15」如何构建通用 api 中间层 | BuptStEve&#39;s Blog | Talk is cheap show me the offer!</title><meta name="description" content="零、问题的由来开门见山地说，这篇文章是一篇安利软文~，安利的对象就是最近搞的 tua-api。 顾名思义，这就是一款辅助获取接口数据的工具。  发请求相关的工具辣么多，那我为啥要用你呢？  理想状态下，项目中应该有一个 api 中间层。各种接口在这里定义，业务侧不应该手动编写接口地址，而应该调用接口层导出的函数。 123456import &amp;#123; fooApi &amp;#125; from &apos;@/"><meta name="keywords" content="tua,api"><meta property="og:type" content="article"><meta property="og:title" content="「15」如何构建通用 api 中间层"><meta property="og:url" content="https://buptsteve.github.io/blog/2018/11/05/015.how-to-build-a-common-api-layer/index.html"><meta property="og:site_name" content="BuptStEve&#39;s Blog"><meta property="og:description" content="零、问题的由来开门见山地说，这篇文章是一篇安利软文~，安利的对象就是最近搞的 tua-api。 顾名思义，这就是一款辅助获取接口数据的工具。  发请求相关的工具辣么多，那我为啥要用你呢？  理想状态下，项目中应该有一个 api 中间层。各种接口在这里定义，业务侧不应该手动编写接口地址，而应该调用接口层导出的函数。 123456import &amp;#123; fooApi &amp;#125; from &apos;@/"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/tua/i-choose-death.jpg"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/tua/欲言又止.jpg"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/tua/笑容逐渐放肆.jpg"><meta property="og:updated_time" content="2018-11-14T02:54:23.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="「15」如何构建通用 api 中间层"><meta name="twitter:description" content="零、问题的由来开门见山地说，这篇文章是一篇安利软文~，安利的对象就是最近搞的 tua-api。 顾名思义，这就是一款辅助获取接口数据的工具。  发请求相关的工具辣么多，那我为啥要用你呢？  理想状态下，项目中应该有一个 api 中间层。各种接口在这里定义，业务侧不应该手动编写接口地址，而应该调用接口层导出的函数。 123456import &amp;#123; fooApi &amp;#125; from &apos;@/"><meta name="twitter:image" content="https://buptsteve.github.io/blog/imgs/tua/i-choose-death.jpg"><link rel="shortcut icon" href="/blog/img/favicon.ico"><link rel="stylesheet" href="/blog/css/style.css"><link rel="alternative" href="/blog/atom.xml" title="BuptStEve&#39;s Blog" type="application/atom+xml"></head><body><div id="loading" class="active"></div><nav id="menu" class="hide"><div class="inner flex-row-vertical"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off"><i class="icon icon-lg icon-close"></i></a><div class="brand-wrap"><div class="brand"><a href="/blog" class="avatar"><img src="/blog/img/logo.jpg"></a><hgroup class="introduce"><h5 class="nickname">Steve Young</h5><a href="mailto:yangzhenyu2016@gmail.com" title="yangzhenyu2016@gmail.com" class="mail">yangzhenyu2016@gmail.com</a></hgroup></div></div><div class="scroll-wrap flex-col"><ul class="nav"><li class="waves-block waves-effect"><a href="/blog/"><i class="icon icon-lg icon-home"></i> 主页</a></li><li class="waves-block waves-effect"><a href="/blog/archives"><i class="icon icon-lg icon-archives"></i> Archives</a></li><li class="waves-block waves-effect"><a href="/blog/tags"><i class="icon icon-lg icon-tags"></i> Tags</a></li><li class="waves-block waves-effect"><a href="https://github.com/buptsteve" target="_blank"><i class="icon icon-lg icon-github"></i> Github</a></li><li class="waves-block waves-effect"><a href="http://weibo.com/0osteveyoungo0" target="_blank"><i class="icon icon-lg icon-weibo"></i> Weibo</a></li></ul><footer class="footer"><p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC"></a></p><p>BuptStEve&#39;s Blog &copy; 2018</p><p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p><a href="/blog/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a></footer></div></div></nav><main id="main"><header class="top-header" id="header"><div class="flex-row"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle"><i class="icon icon-lg icon-navicon"></i></a><div class="flex-col header-title ellipsis">「15」如何构建通用 api 中间层</div><div class="search-wrap" id="search-wrap"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i></a> <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search"><i class="icon icon-lg icon-search"></i></a></div></div></header><header class="content-header"><div class="container"><h1 class="author">「15」如何构建通用 api 中间层</h1><h5 class="subtitle"><time datetime="2018-11-05T03:08:00.000Z" itemprop="datePublished" class="page-time">2018-11-05</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/全栈/">全栈</a></li></ul></h5></div></header><div class="container body-wrap"><article id="post-015.how-to-build-a-common-api-layer" class="article article-type-post" itemprop="blogPost"><div class="post-meta flex-row"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/api/">api</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/tua/">tua</a></li></ul></div><div class="post-body"><aside class="post-widget" id="post-widget"><nav class="post-toc-wrap" id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#零、问题的由来"><span class="post-toc-text">零、问题的由来</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#一、如何发请求"><span class="post-toc-text">一、如何发请求</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-1-原生-XHR-XMLHttpRequest"><span class="post-toc-text">1.1.原生 XHR (XMLHttpRequest)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-2-jQuery-封装的-ajax"><span class="post-toc-text">1.2.jQuery 封装的 ajax</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-3-现代浏览器的原生-fetch"><span class="post-toc-text">1.3.现代浏览器的原生 fetch</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-4-基于-Promise-的-axios"><span class="post-toc-text">1.4.基于 Promise 的 axios</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-5-不得不用的-jsonp"><span class="post-toc-text">1.5.不得不用的 jsonp</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-6-小程序场景"><span class="post-toc-text">1.6.小程序场景</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二、构建接口层基础功能"><span class="post-toc-text">二、构建接口层基础功能</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-接口地址划分"><span class="post-toc-text">2.1.接口地址划分</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-文件结构"><span class="post-toc-text">2.2.文件结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-3-基础配置内容"><span class="post-toc-text">2.3.基础配置内容</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-4-配置导出"><span class="post-toc-text">2.4.配置导出</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-5-接口参数与接口类型"><span class="post-toc-text">2.5.接口参数与接口类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-6-接口重命名"><span class="post-toc-text">2.6.接口重命名</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#三、高级功能"><span class="post-toc-text">三、高级功能</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1-小程序端的-loading-展示"><span class="post-toc-text">3.1.小程序端的 loading 展示</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-基础钩子函数"><span class="post-toc-text">3.2.基础钩子函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-middleware-中间件"><span class="post-toc-text">3.3.middleware 中间件</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#四、小结"><span class="post-toc-text">四、小结</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考文献"><span class="post-toc-text">参考文献</span></a></li></ol></nav></aside><div class="post-main"><div class="post-content" id="post-content" itemprop="postContent"><h2 id="零、问题的由来"><a href="#零、问题的由来" class="headerlink" title="零、问题的由来"></a>零、问题的由来</h2><p>开门见山地说，这篇文章是一篇安利软文~，安利的对象就是最近搞的 <a href="https://github.com/tuateam/tua-api" target="_blank" rel="noopener">tua-api</a>。</p><p>顾名思义，这就是一款辅助获取接口数据的工具。</p><blockquote><p>发请求相关的工具辣么多，那我为啥要用你呢？</p></blockquote><p>理想状态下，项目中应该有一个 api 中间层。各种接口在这里定义，业务侧不应该手动编写接口地址，而应该调用接口层导出的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fooApi &#125; <span class="keyword">from</span> <span class="string">'@/apis/'</span></span><br><span class="line"></span><br><span class="line">fooApi</span><br><span class="line">    .bar(&#123; <span class="attr">a</span>: <span class="string">'1'</span>, <span class="attr">b</span>: <span class="string">'2'</span> &#125;) <span class="comment">// 发起请求，a、b 是请求参数</span></span><br><span class="line">    .then(<span class="built_in">console</span>.log)       <span class="comment">// 收到响应</span></span><br><span class="line">    .catch(<span class="built_in">console</span>.error)    <span class="comment">// 处理错误</span></span><br></pre></td></tr></table></figure><p>那么如何组织实现这个 api 中间层呢？这里涉及两方面：</p><ul><li>如何发请求，即“武器”部分</li><li>如何组织管理 api 地址</li></ul><p>让我们先回顾一下有关发请求的历史。</p><h2 id="一、如何发请求"><a href="#一、如何发请求" class="headerlink" title="一、如何发请求"></a>一、如何发请求</h2><h3 id="1-1-原生-XHR-XMLHttpRequest"><a href="#1-1-原生-XHR-XMLHttpRequest" class="headerlink" title="1.1.原生 XHR (XMLHttpRequest)"></a>1.1.原生 XHR (XMLHttpRequest)</h3><p>说到发请求，最经典的方式莫过于调用浏览器原生的 XHR。在此不赘述，有兴趣可以看看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">MDN 上的文档</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="built_in">window</span>.XMLHttpRequest</span><br><span class="line">    ? <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    <span class="comment">// 在万恶的 IE 上可能还没有 XMLHttpRequest 这对象</span></span><br><span class="line">    : <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>)</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'some url'</span>)</span><br><span class="line">xhr.responseType = <span class="string">'json'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统使用 onreadystatechange</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(xhr.responseText)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者直接使用 onload 事件</span></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理出错</span></span><br><span class="line">xhr.onerror = <span class="built_in">console</span>.error</span><br><span class="line"></span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure><p>这代码都不用看，想想就头皮发麻…</p><h3 id="1-2-jQuery-封装的-ajax"><a href="#1-2-jQuery-封装的-ajax" class="headerlink" title="1.2.jQuery 封装的 ajax"></a>1.2.jQuery 封装的 ajax</h3><p>由于原生 XHR 写起来太繁琐，再加上当时 jQuery 如日中天。日常开发中用的比较多的还是 jQuery 提供的 ajax 方法。<a href="http://api.jquery.com/jquery.ajax/" target="_blank" rel="noopener">jQuery ajax 文档点这里</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = &#123;</span><br><span class="line">    url: <span class="string">'some url'</span>,</span><br><span class="line">    data: &#123; <span class="attr">name</span>: <span class="string">'Steve'</span>, <span class="attr">location</span>: <span class="string">'Beijing'</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$.ajax(params)</span><br><span class="line">    .done(<span class="built_in">console</span>.log)</span><br><span class="line">    .fail(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure><p>jQuery 不仅封装了 XHR，还十分贴心地提供跨域的 jsonp 功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">'some url'</span>,</span><br><span class="line">    data: &#123; <span class="attr">name</span>: <span class="string">'Steve'</span>, <span class="attr">location</span>: <span class="string">'Beijing'</span> &#125;,</span><br><span class="line">    dataType: <span class="string">'jsonp'</span>,</span><br><span class="line">    success: <span class="built_in">console</span>.log,</span><br><span class="line">    error: <span class="built_in">console</span>.error,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>讲道理，jQuery 的 ajax 已经很好用了。然而随着 Vue、React、Angular 的兴起，连 jQuery 本身都被革命了。新项目为了发个请求还引入巨大的 jQuery 肯定不合理，当然后面这些替代方案也功不可没…</p><h3 id="1-3-现代浏览器的原生-fetch"><a href="#1-3-现代浏览器的原生-fetch" class="headerlink" title="1.3.现代浏览器的原生 fetch"></a>1.3.现代浏览器的原生 fetch</h3><p>XHR 是一个设计粗糙的 API。记得当年笔试某部门的实习生的时候就有手写 XHR 的题目，我反正记不住 api，并没有写出来…</p><p>fetch api 基于 Promise 设计，调用起来比 XHR 方便多了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(url)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="built_in">console</span>.log)</span><br><span class="line">    .catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure><p>async/await 自然也能使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> fetch(url).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然 fetch 也有不少的问题</p><ul><li><a href="https://caniuse.com/#search=fetch" target="_blank" rel="noopener">兼容性问题</a></li><li>使用繁琐，详见参考文献之 <a href="http://undefinedblog.com/window-fetch-is-not-as-good-as-you-imagined/" target="_blank" rel="noopener">fetch 没有你想象的那么美</a></li><li>不支持 jsonp（虽然理论上不应该支持，但实际上日常还是需要使用的）</li><li>只对网络请求报错，对400，500都当做成功的请求，需要二次封装</li><li>默认不会带 cookie，需要添加配置项</li><li>不支持 abort，不支持超时控制，使用 setTimeout 及 Promise.race 的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li><li>没有办法原生监测请求的进度，而 XHR 可以</li></ul><h3 id="1-4-基于-Promise-的-axios"><a href="#1-4-基于-Promise-的-axios" class="headerlink" title="1.4.基于 Promise 的 axios"></a>1.4.基于 Promise 的 axios</h3><p>axios 算是请求框架中的明星项目了。目前 github 5w+ 的 star…</p><p>先来看看有什么特性吧~</p><ul><li>同时支持浏览器端和服务端的请求。（XMLHttpRequests、http）</li><li>支持 Promise</li><li>支持请求和和数据返回的拦截</li><li>转换请求返回数据，自动转换JSON数据</li><li>支持取消请求</li><li>客户端防止 xsrf 攻击</li></ul><p>嗯，看起来确实是居家旅行全栈开发必备好库，<a href="https://github.com/axios/axios/issues/342#issuecomment-224327183" target="_blank" rel="noopener">但是 axios 并不支持 jsonp…</a></p><h3 id="1-5-不得不用的-jsonp"><a href="#1-5-不得不用的-jsonp" class="headerlink" title="1.5.不得不用的 jsonp"></a>1.5.不得不用的 jsonp</h3><p>在服务器端不方便配置跨域头的情况下，采用 jsonp 的方式发起跨域请求是一种常规操作。</p><p>在此不探究具体的实现，原理上来说就是</p><ul><li>由于 script 标签可以设置跨域的来源，所以首先动态插入一个 script，将 src 设置为目标地址</li><li>服务端收到请求后，根据回调函数名（可自己约定，或作为参数传递）将 json 数据填入（即 json padding，所以叫 jsonp…）。例如 <code>callback({ &quot;foo&quot;: &quot;bar&quot; })</code>。</li><li>浏览器端收到响应后自然会执行该 script 即调用该函数，那么回调函数就收到了服务端填入的 json 数据了。</li></ul><p>上面讲到新项目一般都弃用 jQuery 了，那么跨域请求还是得发呀。所以可能你还需要一个发送 jsonp 的库。（实践中选了 <code>fetch-jsonp</code>，当然其他库也可以）</p><p>综上，日常开发在框架的使用上以 <code>axios</code> 为主，实在不得不发 jsonp 请求时，就用 <code>fetch-jsonp</code>。这就是我们中间层的基础，即“武器”部分。</p><h3 id="1-6-小程序场景"><a href="#1-6-小程序场景" class="headerlink" title="1.6.小程序场景"></a>1.6.小程序场景</h3><p>在小程序场景没得选，只能使用官方的 <code>wx.request</code> 函数…</p><h2 id="二、构建接口层基础功能"><a href="#二、构建接口层基础功能" class="headerlink" title="二、构建接口层基础功能"></a>二、构建接口层基础功能</h2><p>对于简单的页面，直接裸写请求地址也没毛病。但是一旦项目变大，页面数量也上去了，直接在页面，或是组件中裸写接口的话，会带来以下问题</p><ul><li>代码冗余：很多接口请求都是类似的代码，有许多相同的逻辑</li><li>不同的库和场景下的接口写法不同（ajax、jsonp、小程序…）</li><li>不方便切换测试域名</li><li>不方便编写接口注释</li><li>没法实现统一拦截器、甚至中间件功能</li></ul><blockquote><p>如何封装这些接口呢？</p></blockquote><h3 id="2-1-接口地址划分"><a href="#2-1-接口地址划分" class="headerlink" title="2.1.接口地址划分"></a>2.1.接口地址划分</h3><p>首先我们来分析一下接口地址的组成</p><ul><li><code>https://example-base.com/foo/create</code></li><li><code>https://example-base.com/foo/modify</code></li><li><code>https://example-base.com/foo/delete</code></li></ul><p>对于以上地址，在 <code>tua-api</code> 中一般将其分为3部分</p><ul><li>host: <code>&#39;https://example-base.com/&#39;</code></li><li>prefix: <code>&#39;foo&#39;</code></li><li>pathList: <code>[ &#39;create&#39;, &#39;modify&#39;, &#39;delete&#39; ]</code></li></ul><h3 id="2-2-文件结构"><a href="#2-2-文件结构" class="headerlink" title="2.2.文件结构"></a>2.2.文件结构</h3><p><code>apis/</code> 一般是这样的文件结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── apis</span><br><span class="line">    ├── prefix-1.js</span><br><span class="line">    ├── prefix-2.js</span><br><span class="line">    ├── foo.js      // &lt;-- 以上的 api 地址会放在这里</span><br><span class="line">    └── index.js</span><br></pre></td></tr></table></figure><p><code>index.js</code> 作为接口层的入口，会导入并生成各个 api 然后再导出。</p><h3 id="2-3-基础配置内容"><a href="#2-3-基础配置内容" class="headerlink" title="2.3.基础配置内容"></a>2.3.基础配置内容</h3><p>所以以上的示例接口地址可以这么写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/apis/foo.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// 请求的公用服务器地址。</span></span><br><span class="line">    host: <span class="string">'http://example-base.com/'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求的中间路径，建议与文件同名，以便后期维护。</span></span><br><span class="line">    prefix: <span class="string">'foo'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口地址数组</span></span><br><span class="line">    pathList: [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">'create'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">'modify'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">'delete'</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时如果想修改服务器地址，只需要修改 host 即可。甚至还能这么玩</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/apis/foo.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 某个获取页面地址参数的函数</span></span><br><span class="line"><span class="keyword">const</span> getUrlParams = <span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// 根据 NODE_ENV 采用不同的服务器</span></span><br><span class="line">    host: process.env.NODE_ENV === <span class="string">'test'</span></span><br><span class="line">        ? <span class="string">'http://example-test.com/'</span></span><br><span class="line">        : <span class="string">'http://example-base.com/'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据页面参数采用不同的服务器，即页面地址带 ?test=1 则走测试地址</span></span><br><span class="line">    host: getUrlParams().test</span><br><span class="line">        ? <span class="string">'http://example-test.com/'</span></span><br><span class="line">        : <span class="string">'http://example-base.com/'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-配置导出"><a href="#2-4-配置导出" class="headerlink" title="2.4.配置导出"></a>2.4.配置导出</h3><p>下面来看一下 <code>apis/index.js</code> 该怎么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TuaApi <span class="keyword">from</span> <span class="string">'tua-api'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">const</span> tuaApi = <span class="keyword">new</span> TuaApi(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fooApi = tuaApi.getApi(<span class="built_in">require</span>(<span class="string">'./foo'</span>).default)</span><br></pre></td></tr></table></figure><p>这样我们就把接口地址封装了起来，业务侧不需要关心接口的逻辑，而后期接口的修改和升级时只需要修改这里的配置即可。</p><h3 id="2-5-接口参数与接口类型"><a href="#2-5-接口参数与接口类型" class="headerlink" title="2.5.接口参数与接口类型"></a>2.5.接口参数与接口类型</h3><p>示例的接口地址太理想化了，如果有参数如何传递？</p><p>假设以上接口添加 id、from 和 foo 参数。并且增加以下逻辑：</p><ul><li>foo 参数默认填 <code>bar</code></li><li>from 参数默认填 <code>index-page</code></li><li>delete 接口使用 jsonp 的方式，from 参数默认填 <code>delete-page</code></li><li>modify 接口使用 post 的方式，from 参数不需要填</li></ul><p><img src="/blog/imgs/tua/i-choose-death.jpg" alt="i-choose-death"></p><p>哎~，别急着死，暂且看看怎么用 <code>tua-api</code> 来抽象这些逻辑？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/apis/foo.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共参数，将会合并到后面的各个接口参数中</span></span><br><span class="line">    commonParams: &#123;</span><br><span class="line">        foo: <span class="string">'bar'</span>,</span><br><span class="line">        <span class="keyword">from</span>: <span class="string">'index-page'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    pathList: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">'create'</span>,</span><br><span class="line">            params: &#123;</span><br><span class="line">                <span class="comment">// 类似 Vue 中 props 的类型检查</span></span><br><span class="line">                id: &#123; <span class="attr">required</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">'modify'</span>,</span><br><span class="line">            <span class="comment">// 使用 post 的方式</span></span><br><span class="line">            type: <span class="string">'post'</span>,</span><br><span class="line">            params: &#123;</span><br><span class="line">                <span class="comment">// 写成 isRequired 也行</span></span><br><span class="line">                id: &#123; <span class="attr">isRequired</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">                <span class="comment">// 接口不合并公共参数，即不传 from 参数</span></span><br><span class="line">                commonParams: <span class="literal">null</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">'delete'</span>,</span><br><span class="line">            <span class="comment">// 使用 jsonp 的方式（不填则默认使用 axios）</span></span><br><span class="line">            reqType: <span class="string">'jsonp'</span>,</span><br><span class="line">            params: &#123;</span><br><span class="line">                id: &#123; <span class="attr">required</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">                <span class="comment">// 这里填写的 from 会覆盖 commonParams 中的同名属性</span></span><br><span class="line">                <span class="keyword">from</span>: <span class="string">'delete-page'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来看看业务侧代码有什么变化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fooApi &#125; <span class="keyword">from</span> <span class="string">'@/apis/'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接调用将会报错，因为没有传递 id 参数</span></span><br><span class="line"><span class="keyword">await</span> fooApi.create()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求参数使用传入的 from：id=1&amp;foo=bar&amp;from=foo-page</span></span><br><span class="line"><span class="keyword">await</span> fooApi.create(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">from</span>: <span class="string">'foo-page'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求参数将只有 id：id=1</span></span><br><span class="line"><span class="keyword">await</span> fooApi.modify(&#123; <span class="attr">id</span>: <span class="number">1</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求参数将使用自身的 from：id=1&amp;foo=bar&amp;from=delete-page</span></span><br><span class="line"><span class="keyword">await</span> fooApi.delete(&#123; <span class="attr">id</span>: <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><h3 id="2-6-接口重命名"><a href="#2-6-接口重命名" class="headerlink" title="2.6.接口重命名"></a>2.6.接口重命名</h3><p>假设现在后台又添加了以下两个新接口，咱们该怎么写配置呢？</p><ul><li><code>remove/all</code></li><li><code>add-array</code></li></ul><p><del>首先，把后台同学砍死…2333</del></p><p><img src="/blog/imgs/tua/欲言又止.jpg" alt="欲言又止"></p><p>这什么鬼接口地址，直接填的话会业务侧就会写成这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fooApi[<span class="string">'remove/all'</span>]</span><br><span class="line">fooApi[<span class="string">'add-array'</span>]</span><br></pre></td></tr></table></figure><p>这代码简直无法直视…让我们用 <code>name</code> 属性，将接口重命名一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/apis/foo.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    pathList: [</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">'remove/all'</span>, <span class="attr">name</span>: <span class="string">'removeAll'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">'add-array'</span>, <span class="attr">name</span>: <span class="string">'addArray'</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://tuateam.github.io/tua-api/config/detail.html" target="_blank" rel="noopener">更多配置请点击这里查看</a></p><h2 id="三、高级功能"><a href="#三、高级功能" class="headerlink" title="三、高级功能"></a>三、高级功能</h2><p>一个接口层仅仅只能发 api 请求是远远不够的，在日常使用中往往还有以下需求</p><ul><li>发起请求时展示 loading，收到响应后隐藏</li><li>出错时展示错误信息，例如弹一个 toast</li><li>接口上报：包括性能和错误</li><li>添加特技：如接口参数加密、校验</li></ul><h3 id="3-1-小程序端的-loading-展示"><a href="#3-1-小程序端的-loading-展示" class="headerlink" title="3.1.小程序端的 loading 展示"></a>3.1.小程序端的 loading 展示</h3><p>小程序端由于原生自带 UI 组件，所以框架内置了该功能。主要包括以下参数</p><ul><li>isShowLoading</li><li>showLoadingFn</li><li>hideLoadingFn</li></ul><p>顾名思义，就是开关和具体的显示、隐藏的方法，<a href="https://tuateam.github.io/tua-api/config/detail.html#afterfn-%E6%94%B6%E5%88%B0%E5%93%8D%E5%BA%94%E5%90%8E%E7%9A%84%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">详情参阅这里</a></p><h3 id="3-2-基础钩子函数"><a href="#3-2-基础钩子函数" class="headerlink" title="3.2.基础钩子函数"></a>3.2.基础钩子函数</h3><p>最简单的钩子函数就是 <code>beforeFn/afterFn</code> 这俩函数了。</p><p>beforeFn 是在请求发起前执行的函数（例如小程序可以通过返回 header 传递 cookie），因为是通过 <code>beforeFn().then(...)</code> 调用，所以注意要返回 Promise。</p><p>afterFn 是在收到响应后执行的函数，可以不用返回 Promise。</p><blockquote><p>注意接收的参数是一个【数组】 <code>[ res.data, ctx ]</code></p></blockquote><blockquote><p>所以默认值是 <code>const afterFn = ([x]) =&gt; x</code>，即返回接口数据到业务侧</p></blockquote><ul><li>第一个参数是接口返回的数据对象 <code>{ code, data, msg }</code></li><li>第二个参数是请求相关参数的对象，例如有请求的 host、type、params、fullPath、reqTime、startTime、endTime 等等</li></ul><h3 id="3-3-middleware-中间件"><a href="#3-3-middleware-中间件" class="headerlink" title="3.3.middleware 中间件"></a>3.3.middleware 中间件</h3><p>钩子函数有时不太够用，并且代码一长不太好维护。所以 tua-api 还引入了中间件功能，用法上和 koa 的中间件很像（其实底层直接用了 <code>koa-compose</code>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    middleware: [ fn1, fn2, fn3 ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先说下中间件执行顺序，koa 中间件的执行顺序和 redux 的正好相反，例如以上写法会以以下顺序执行：</p><p><code>请求参数 -&gt; fn1 -&gt; fn2 -&gt; fn3 -&gt; 响应数据 -&gt; fn3 -&gt; fn2 -&gt; fn1</code></p><p>简单说下中间件的写法，分为两种</p><ul><li>普通函数：注意一定要 <code>return next()</code> 否则 <code>Promise</code> 链就断了！</li><li>async 函数：注意一定要 <code>await next()</code>！</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数，注意一定要 return next()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    ctx.req       <span class="comment">// 请求的各种配置</span></span><br><span class="line">    ctx.res       <span class="comment">// 响应，但这时还未发起请求，所以是 undefined！</span></span><br><span class="line">    ctx.startTime <span class="comment">// 发起请求的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递控制权给下一个中间件</span></span><br><span class="line">    <span class="keyword">return</span> next().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 注意这里才有响应！</span></span><br><span class="line">        ctx.res       <span class="comment">// 响应对象</span></span><br><span class="line">        ctx.res.data  <span class="comment">// 响应的数据</span></span><br><span class="line">        ctx.reqTime   <span class="comment">// 请求花费的时间</span></span><br><span class="line">        ctx.endTime   <span class="comment">// 收到响应的时间</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async/await</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    ctx.req <span class="comment">// 请求的各种配置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递控制权给下一个中间件</span></span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里才有响应响应！</span></span><br><span class="line">    ctx.res <span class="comment">// 响应对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://tuateam.github.io/tua-api/quick-start/middleware.html#%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">其他参数参阅这里</a></p><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>这篇安利文，先是从前端发请求的历史出发。一步步介绍了如何构建以及使用 api 中间层，来统一管理接口地址，最后还介绍了下中间件等高级功能。话说回来，这么好用的 <a href="https://github.com/tuateam/tua-api" target="_blank" rel="noopener">tua-api</a> 各位开发者老爷们不来了解一下么？</p><p><img src="/blog/imgs/tua/笑容逐渐放肆.jpg" alt="笑容逐渐放肆"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000012836882" target="_blank" rel="noopener">Jquery ajax, Axios, Fetch区别之我见</a></li><li><a href="https://github.com/camsong/blog/issues/2" target="_blank" rel="noopener">传统 Ajax 已死，Fetch 永生</a></li><li><a href="http://undefinedblog.com/window-fetch-is-not-as-good-as-you-imagined/" target="_blank" rel="noopener">fetch 没有你想象的那么美</a></li><li><a href="https://www.cnblogs.com/huilixieqi/p/6494380.html" target="_blank" rel="noopener">fetch 使用的常见问题及解决方法</a></li></ul><blockquote><p>本文地址： <a href="https://buptsteve.github.io/blog/2018/11/05/015.how-to-build-a-common-api-layer/" target="_blank" rel="external">https://buptsteve.github.io/blog/2018/11/05/015.how-to-build-a-common-api-layer/</a></p><footer><cite><a href="https://buptsteve.github.io/blog">@BuptStEve's Blog</a></cite></footer></blockquote></div><nav class="post-nav"><div class="waves-block waves-effect prev fl"><a href="/blog/2018/11/16/016.how-to-build-a-common-storage-layer/" id="post-prev" class="post-nav-link"><div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div><h4 class="title">「16」如何构建通用存储中间层</h4></a></div><div class="waves-block waves-effect next fr"><a href="/blog/2018/08/10/014.fp-in-js-3/" id="post-next" class="post-nav-link"><div class="tips">Next<i class="icon icon-angle-right icon-lg icon-pl"></i></div><h4 class="title">「14」JavaScript 函数式编程（三）</h4></a></div></nav></div></div></article></div></main><div class="mask" id="mask"></div><a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a><script src="/blog/js/wave.min.js"></script><script src="/blog/js/main.js"></script><div class="search-panel" id="search-panel"><ul class="search-result" id="search-result"></ul></div><script type="text/template" id="search-tpl"><li class="item">
        <a href="/{path}" class="waves-block waves-effect">
            <div class="title ellipsis" title="{title}">{title}</div>
            
            <div class="flex-row flex-middle">
                <div class="tags ellipsis">
                    {tags}
                </div>

                <time class="flex-col time">{date}</time>
            </div>
        </a>
    </li></script><script src="/blog/js/search.js"></script><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="//www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-85691829-1","auto"),ga("send","pageview")</script></body></html>