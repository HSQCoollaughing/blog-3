<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="keywords" content=""><meta name="theme-color" content="#3F51B5"><meta name="summary" content="BuptStEve"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>「11」终极蛇皮上帝视角之微信小程序之告别 setData | BuptStEve&#39;s Blog | Talk is cheap show me the offer!</title><meta name="description" content="众所周知 Vue 是借助 ES5 的 Object.defineProperty 方法设置 getter、setter 达到数据驱动界面，当然其中还有模板编译等等其他过程。 而小程序官方的 api 是在 Page 中调用 this.setData 方法来改变数据，从而改变界面。 那么假如我们将两者结合一下，将 this.setData 封装起来，岂不是可以像开发 Vue 应用一样地使用 this."><meta name="keywords" content="tua-mp,小程序"><meta property="og:type" content="article"><meta property="og:title" content="「11」终极蛇皮上帝视角之微信小程序之告别 setData"><meta property="og:url" content="https://buptsteve.github.io/blog/2018/05/21/11.say-goodbye-to-mina-setData/index.html"><meta property="og:site_name" content="BuptStEve&#39;s Blog"><meta property="og:description" content="众所周知 Vue 是借助 ES5 的 Object.defineProperty 方法设置 getter、setter 达到数据驱动界面，当然其中还有模板编译等等其他过程。 而小程序官方的 api 是在 Page 中调用 this.setData 方法来改变数据，从而改变界面。 那么假如我们将两者结合一下，将 this.setData 封装起来，岂不是可以像开发 Vue 应用一样地使用 this."><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/tua-mp/否认三连.jpg"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/tua-mp/改代码.png"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/tua-mp/很多很多.jpg"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/tua-mp/那么在哪里才能买得到呢.jpg"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/tua-mp/塘主.gif"><meta property="og:updated_time" content="2018-06-12T10:06:48.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="「11」终极蛇皮上帝视角之微信小程序之告别 setData"><meta name="twitter:description" content="众所周知 Vue 是借助 ES5 的 Object.defineProperty 方法设置 getter、setter 达到数据驱动界面，当然其中还有模板编译等等其他过程。 而小程序官方的 api 是在 Page 中调用 this.setData 方法来改变数据，从而改变界面。 那么假如我们将两者结合一下，将 this.setData 封装起来，岂不是可以像开发 Vue 应用一样地使用 this."><meta name="twitter:image" content="https://buptsteve.github.io/blog/imgs/tua-mp/否认三连.jpg"><link rel="shortcut icon" href="/blog/img/favicon.ico"><link rel="stylesheet" href="/blog/css/style.css"><link rel="alternative" href="/blog/atom.xml" title="BuptStEve&#39;s Blog" type="application/atom+xml"></head><body><div id="loading" class="active"></div><nav id="menu" class="hide"><div class="inner flex-row-vertical"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off"><i class="icon icon-lg icon-close"></i></a><div class="brand-wrap"><div class="brand"><a href="/blog" class="avatar"><img src="/blog/img/logo.jpg"></a><hgroup class="introduce"><h5 class="nickname">Steve Young</h5><a href="mailto:yangzhenyu2016@gmail.com" title="yangzhenyu2016@gmail.com" class="mail">yangzhenyu2016@gmail.com</a></hgroup></div></div><div class="scroll-wrap flex-col"><ul class="nav"><li class="waves-block waves-effect"><a href="/blog/"><i class="icon icon-lg icon-home"></i> 主页</a></li><li class="waves-block waves-effect"><a href="/blog/archives"><i class="icon icon-lg icon-archives"></i> Archives</a></li><li class="waves-block waves-effect"><a href="/blog/tags"><i class="icon icon-lg icon-tags"></i> Tags</a></li><li class="waves-block waves-effect"><a href="https://github.com/buptsteve" target="_blank"><i class="icon icon-lg icon-github"></i> Github</a></li><li class="waves-block waves-effect"><a href="http://weibo.com/0osteveyoungo0" target="_blank"><i class="icon icon-lg icon-weibo"></i> Weibo</a></li></ul><footer class="footer"><p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC"></a></p><p>BuptStEve&#39;s Blog &copy; 2018</p><p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p><a href="/blog/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a></footer></div></div></nav><main id="main"><header class="top-header" id="header"><div class="flex-row"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle"><i class="icon icon-lg icon-navicon"></i></a><div class="flex-col header-title ellipsis">「11」终极蛇皮上帝视角之微信小程序之告别 setData</div><div class="search-wrap" id="search-wrap"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i></a> <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search"><i class="icon icon-lg icon-search"></i></a></div></div></header><header class="content-header"><div class="container"><h1 class="author">「11」终极蛇皮上帝视角之微信小程序之告别 setData</h1><h5 class="subtitle"><time datetime="2018-05-20T16:00:00.000Z" itemprop="datePublished" class="page-time">2018-05-21</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/前端/">前端</a></li></ul></h5></div></header><div class="container body-wrap"><article id="post-11.say-goodbye-to-mina-setData" class="article article-type-post" itemprop="blogPost"><div class="post-meta flex-row"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/tua-mp/">tua-mp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/小程序/">小程序</a></li></ul></div><div class="post-body"><aside class="post-widget" id="post-widget"><nav class="post-toc-wrap" id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#0-源码地址"><span class="post-toc-text">0.源码地址</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-绑定简单属性"><span class="post-toc-text">1.绑定简单属性</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-绑定嵌套对象"><span class="post-toc-text">2.绑定嵌套对象</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-劫持数组方法"><span class="post-toc-text">3.劫持数组方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-实现-computed-功能"><span class="post-toc-text">4.实现 computed 功能</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-实现-watch-功能"><span class="post-toc-text">5.实现 watch 功能</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-记录路径"><span class="post-toc-text">6.记录路径</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-异步-setData"><span class="post-toc-text">7.异步 setData</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-代码重构"><span class="post-toc-text">8.代码重构</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#9-依赖收集"><span class="post-toc-text">9.依赖收集</span></a></li></ol></nav></aside><div class="post-main"><div class="post-content" id="post-content" itemprop="postContent"><p>众所周知 Vue 是借助 ES5 的 <code>Object.defineProperty</code> 方法设置 getter、setter 达到数据驱动界面，当然其中还有模板编译等等其他过程。</p><p>而小程序官方的 api 是在 <code>Page</code> 中调用 <code>this.setData</code> 方法来改变数据，从而改变界面。</p><p>那么假如我们将两者结合一下，将 <code>this.setData</code> 封装起来，岂不是可以像开发 Vue 应用一样地使用 <code>this.foo = &#39;hello&#39;</code> 来开发小程序了？</p><ul><li>更进一步地，可以实现 h5 和小程序 js 部分代码的同构</li><li>更进一步地，增加模板编译和解析就可以连 wxml/html 部分也同构</li><li>更进一步地，兼容 RN/Weex/快应用</li><li>更进一步地，世界大同，天下为公，前端工程师全部失业…23333</li></ul><p><img src="/blog/imgs/tua-mp/否认三连.jpg" alt="否认三连.jpg"></p><h2 id="0-源码地址"><a href="#0-源码地址" class="headerlink" title="0.源码地址"></a>0.源码地址</h2><ul><li><a href="https://github.com/tuateam/tua-mp" target="_blank" rel="noopener">github 地址</a></li></ul><h2 id="1-绑定简单属性"><a href="#1-绑定简单属性" class="headerlink" title="1.绑定简单属性"></a>1.绑定简单属性</h2><p>第一步我们先定一个小目标：<del>挣他一个亿！！！</del></p><p><strong>对于简单非嵌套属性（非对象，数组），直接对其赋值就能改变界面。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.wxml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>msg: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">"tapMsg"</span>&gt;</span>change msg<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line">TuaPage(&#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            msg: <span class="string">'hello world'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        tapMsg () &#123;</span><br><span class="line">            <span class="keyword">this</span>.msg = <span class="keyword">this</span>.reverseStr(<span class="keyword">this</span>.msg)</span><br><span class="line">        &#125;,</span><br><span class="line">        reverseStr (str) &#123;</span><br><span class="line">            <span class="keyword">return</span> str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这一步很简单啦，直接对于 data 中的每个属性都绑定下 getter、setter，在 setter 中调用下 <code>this.setData</code> 就好啦。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 source 上的属性代理到 target 上</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; source 被代理对象</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; target 被代理目标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> proxyData = <span class="function">(<span class="params">source, target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(source).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(</span><br><span class="line">            target,</span><br><span class="line">            key,</span><br><span class="line">            <span class="built_in">Object</span>.getOwnPropertyDescriptor(source, key)</span><br><span class="line">        )</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历观察 vm.data 中的所有属性，并将其直接挂到 vm 上</span></span><br><span class="line"><span class="comment"> * @param &#123;Page|Component&#125; vm Page 或 Component 实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> bindData = <span class="function">(<span class="params">vm</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> defineReactive = <span class="function">(<span class="params">obj, key, val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span>,</span><br><span class="line">            get () &#123; <span class="keyword">return</span> val &#125;,</span><br><span class="line">            set (newVal) &#123;</span><br><span class="line">                <span class="keyword">if</span> (newVal === val) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">                val = newVal</span><br><span class="line">                vm.setData($data)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 观察对象</span></span><br><span class="line"><span class="comment">     * @param &#123;any&#125; obj 待观察对象</span></span><br><span class="line"><span class="comment">     * @return &#123;any&#125; 已被观察的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> observe = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> observedObj = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 过滤 __wxWebviewId__ 等内部属性</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="regexp">/^__.*__$/</span>.test(key)) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            defineReactive(</span><br><span class="line">                observedObj,</span><br><span class="line">                key,</span><br><span class="line">                obj[key]</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> observedObj</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> $data = observe(vm.data)</span><br><span class="line"></span><br><span class="line">    vm.$data = $data</span><br><span class="line">    proxyData($data, vm)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配 Vue 风格代码，使其支持在小程序中运行（告别不方便的 setData）</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; args Page 参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TuaPage = <span class="function">(<span class="params">args = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        data: rawData = &#123;&#125;,</span><br><span class="line">        methods = &#123;&#125;,</span><br><span class="line">        ...rest</span><br><span class="line">    &#125; = args</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">typeof</span> rawData === <span class="string">'function'</span></span><br><span class="line">        ? rawData()</span><br><span class="line">        : rawData</span><br><span class="line"></span><br><span class="line">    Page(&#123;</span><br><span class="line">        ...rest,</span><br><span class="line">        ...methods,</span><br><span class="line">        data,</span><br><span class="line">        onLoad (...options) &#123;</span><br><span class="line">            bindData(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">            rest.onLoad &amp;&amp; rest.onLoad.apply(<span class="keyword">this</span>, options)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-绑定嵌套对象"><a href="#2-绑定嵌套对象" class="headerlink" title="2.绑定嵌套对象"></a>2.绑定嵌套对象</h2><blockquote><p>那么如果数据是嵌套的对象咋办咧？</p></blockquote><p>其实也很简单，咱们递归观察一下就好。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.wxml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>a.b: &#123;&#123; a.b &#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">"tapAB"</span>&gt;</span>change a.b<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line">TuaPage(&#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            a: &#123; <span class="attr">b</span>: <span class="string">'this is b'</span> &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        tapAB () &#123;</span><br><span class="line">            <span class="keyword">this</span>.a.b = <span class="keyword">this</span>.reverseStr(<span class="keyword">this</span>.a.b)</span><br><span class="line">        &#125;,</span><br><span class="line">        reverseStr (str) &#123;</span><br><span class="line">            <span class="keyword">return</span> str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>observe</code> -&gt; <code>observeDeep</code>：在 <code>observeDeep</code> 中判断是对象就递归观察下去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归观察对象</span></span><br><span class="line"><span class="comment"> * @param &#123;any&#125; obj 待观察对象</span></span><br><span class="line"><span class="comment"> * @return &#123;any&#125; 已被观察的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> observeDeep = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> observedObj = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="regexp">/^__.*__$/</span>.test(key)) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            defineReactive(</span><br><span class="line">                observedObj,</span><br><span class="line">                key,</span><br><span class="line">                <span class="comment">// -&gt; 注意在这里递归</span></span><br><span class="line">                observeDeep(obj[key]),</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> observedObj</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单属性直接返回</span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h2 id="3-劫持数组方法"><a href="#3-劫持数组方法" class="headerlink" title="3.劫持数组方法"></a>3.劫持数组方法</h2><p>大家都知道，Vue 劫持了一些数组方法。咱们也来依葫芦画瓢地实现一下~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 劫持数组的方法</span></span><br><span class="line"><span class="comment"> * @param &#123;Array&#125; arr 原始数组</span></span><br><span class="line"><span class="comment"> * @return &#123;Array&#125; observedArray 被劫持方法后的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> observeArray = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> observedArray = arr.map(observeDeep)</span><br><span class="line"></span><br><span class="line">    ;[</span><br><span class="line">        <span class="string">'pop'</span>,</span><br><span class="line">        <span class="string">'push'</span>,</span><br><span class="line">        <span class="string">'sort'</span>,</span><br><span class="line">        <span class="string">'shift'</span>,</span><br><span class="line">        <span class="string">'splice'</span>,</span><br><span class="line">        <span class="string">'unshift'</span>,</span><br><span class="line">        <span class="string">'reverse'</span>,</span><br><span class="line">    ].forEach(<span class="function">(<span class="params">method</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> original = observedArray[method]</span><br><span class="line"></span><br><span class="line">        observedArray[method] = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">            vm.setData($data)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> observedArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实，Vue 还做了个优化，如果当前环境有 <code>__proto__</code> 属性，那么就把以上方法直接加到数组的原型链上，而不是对每个数组数据的方法进行修改。</p></blockquote><h2 id="4-实现-computed-功能"><a href="#4-实现-computed-功能" class="headerlink" title="4.实现 computed 功能"></a>4.实现 computed 功能</h2><p><code>computed</code> 功能日常还蛮常用的，通过已有的 <code>data</code> 元数据，派生出一些方便的新数据。</p><p>要实现的话，因为 <code>computed</code> 中的数据都定义成函数，所以其实直接将其设置为 <code>getter</code> 就行啦。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 computed 中定义的新属性挂到 vm 上</span></span><br><span class="line"><span class="comment"> * @param &#123;Page|Component&#125; vm Page 或 Component 实例</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; computed 计算属性对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> bindComputed = <span class="function">(<span class="params">vm, computed</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> $computed = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.keys(computed).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty($computed, key, &#123;</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span>,</span><br><span class="line">            get: computed[key].bind(vm),</span><br><span class="line">            set () &#123;&#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    proxyData($computed, vm)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂到 $data 上，这样在 data 中数据变化时可以一起被 setData</span></span><br><span class="line">    proxyData($computed, vm.$data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    vm.setData($computed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-实现-watch-功能"><a href="#5-实现-watch-功能" class="headerlink" title="5.实现 watch 功能"></a>5.实现 watch 功能</h2><p>接下来又是一个炒鸡好用的 <code>watch</code> 功能，即监听 <code>data</code> 或 <code>computed</code> 中的数据，在其变化的时候调用回调函数，并传入 <code>newVal</code> 和 <code>oldVal</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defineReactive = <span class="function">(<span class="params">obj, key, val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        get () &#123; <span class="keyword">return</span> val &#125;,</span><br><span class="line">        set (newVal) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal === val) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里保存 oldVal</span></span><br><span class="line">            <span class="keyword">const</span> oldVal = val</span><br><span class="line">            val = newVal</span><br><span class="line">            vm.setData($data)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 实现 watch data 属性</span></span><br><span class="line">            <span class="keyword">const</span> watchFn = watch[key]</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> watchFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">                watchFn.call(vm, newVal, oldVal)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bindComputed = <span class="function">(<span class="params">vm, computed, watch</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> $computed = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.keys(computed).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里保存 oldVal</span></span><br><span class="line">        <span class="keyword">let</span> oldVal = computed[key].call(vm)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty($computed, key, &#123;</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span>,</span><br><span class="line">            get () &#123;</span><br><span class="line">                <span class="keyword">const</span> newVal = computed[key].call(vm)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 实现 watch computed 属性</span></span><br><span class="line">                <span class="keyword">const</span> watchFn = watch[key]</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> watchFn === <span class="string">'function'</span> &amp;&amp; newVal !== oldVal) &#123;</span><br><span class="line">                    watchFn.call(vm, newVal, oldVal)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重置 oldVal</span></span><br><span class="line">                oldVal = newVal</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> newVal</span><br><span class="line">            &#125;,</span><br><span class="line">            set () &#123;&#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>看似不错，实则不然。</strong></p><p>咱们现在碰到了一个问题：<strong>如何监听类似 ‘a.b’ 这样的嵌套数据？</strong></p><p>这个问题的原因在于我们在递归遍历数据的时候没有记录下路径。</p><h2 id="6-记录路径"><a href="#6-记录路径" class="headerlink" title="6.记录路径"></a>6.记录路径</h2><p>解决这个问题并不难，其实我们只要在递归观察的每一步中传递 <code>key</code> 即可，注意对于数组中的嵌套元素传递的是 <code>[${index}]</code>。</p><p>并且一旦我们知道了数据的路径，还可以进一步提高 <code>setData</code> 的性能。</p><p>因为我们可以精细地调用 <code>vm.setData({ [prefix]: newVal })</code> 修改其中的部分数据，而不是将整个 <code>$data</code> 都 <code>setData</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defineReactive = <span class="function">(<span class="params">obj, key, val, path</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        set (newVal) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            vm.setData(&#123;</span><br><span class="line">                <span class="comment">// 因为不知道依赖所以更新整个 computed</span></span><br><span class="line">                ...vm.$computed,</span><br><span class="line">                <span class="comment">// 直接修改目标数据</span></span><br><span class="line">                [path]: newVal,</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过路径来找 watch 目标</span></span><br><span class="line">            <span class="keyword">const</span> watchFn = watch[path]</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> watchFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">                watchFn.call(vm, newVal, oldVal)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observeArray = <span class="function">(<span class="params">arr, path</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> observedArray = arr.map(</span><br><span class="line">        <span class="comment">// 注意这里的路径拼接</span></span><br><span class="line">        (item, idx) =&gt; observeDeep(item, <span class="string">`<span class="subst">$&#123;path&#125;</span>[<span class="subst">$&#123;idx&#125;</span>]`</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    ;[</span><br><span class="line">        <span class="string">'pop'</span>,</span><br><span class="line">        <span class="string">'push'</span>,</span><br><span class="line">        <span class="string">'sort'</span>,</span><br><span class="line">        <span class="string">'shift'</span>,</span><br><span class="line">        <span class="string">'splice'</span>,</span><br><span class="line">        <span class="string">'unshift'</span>,</span><br><span class="line">        <span class="string">'reverse'</span>,</span><br><span class="line">    ].forEach(<span class="function">(<span class="params">method</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> original = observedArray[method]</span><br><span class="line"></span><br><span class="line">        observedArray[method] = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line"></span><br><span class="line">            vm.setData(&#123;</span><br><span class="line">                <span class="comment">// 因为不知道依赖所以更新整个 computed</span></span><br><span class="line">                ...vm.$computed,</span><br><span class="line">                <span class="comment">// 直接修改目标数据</span></span><br><span class="line">                [path]: observedArray,</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> observedArray</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observeDeep = <span class="function">(<span class="params">obj, prefix = <span class="string">''</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(obj)) &#123;</span><br><span class="line">        <span class="keyword">return</span> observeArray(obj, prefix)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> observedObj = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="regexp">/^__.*__$/</span>.test(key)) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> path = prefix === <span class="string">''</span></span><br><span class="line">                ? key</span><br><span class="line">                : <span class="string">`<span class="subst">$&#123;prefix&#125;</span>.<span class="subst">$&#123;key&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">            defineReactive(</span><br><span class="line">                observedObj,</span><br><span class="line">                key,</span><br><span class="line">                observeDeep(obj[key], path),</span><br><span class="line">                path,</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> observedObj</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 computed 中定义的新属性挂到 vm 上</span></span><br><span class="line"><span class="comment"> * @param &#123;Page|Component&#125; vm Page 或 Component 实例</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; computed 计算属性对象</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; watch 侦听器对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> bindComputed = <span class="function">(<span class="params">vm, computed, watch</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    proxyData($computed, vm)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂在 vm 上，在 data 变化时重新 setData</span></span><br><span class="line">    vm.$computed = $computed</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    vm.setData($computed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-异步-setData"><a href="#7-异步-setData" class="headerlink" title="7.异步 setData"></a>7.异步 setData</h2><p>目前的代码还有个问题：每次对于 <code>data</code> 某个数据的修改都会触发 <code>setData</code>，那么假如反复地修改同一个数据，就会频繁地触发 <code>setData</code>。并且每一次修改数据都会触发 <code>watch</code> 的监听…</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips.html" target="_blank" rel="noopener">而这恰恰是使用小程序 <code>setData</code> api 的大忌：</a></p><blockquote><p>总结一下就是这三种常见的 setData 操作错误：</p><ol><li>频繁的去 setData</li><li>每次 setData 都传递大量新数据</li><li>后台态页面进行 setData</li></ol></blockquote><p><strong>计将安出？</strong></p><p><img src="/blog/imgs/tua-mp/改代码.png" alt="改代码.png"></p><p>答案就是缓存一下，异步执行 <code>setData</code>~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newState = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步 setData 提高性能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> asyncSetData = (&#123;</span><br><span class="line">    vm,</span><br><span class="line">    newData,</span><br><span class="line">    watchFn,</span><br><span class="line">    prefix,</span><br><span class="line">    oldVal,</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">    newState = &#123;</span><br><span class="line">        ...newState,</span><br><span class="line">        ...newData,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Promise -&gt; MutationObserve -&gt; setTimeout</span></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!newState) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        vm.setData(&#123;</span><br><span class="line">            <span class="comment">// 因为不知道依赖所以更新整个 computed</span></span><br><span class="line">            ...vm.$computed,</span><br><span class="line">            ...newState,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> watchFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">            watchFn.call(vm, newState[prefix], oldVal)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        newState = <span class="literal">null</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Vue 中因为兼容性问题，优先选择使用 <code>Promise.then</code>，其次是 <code>MutationObserve</code>，最后才是 <code>setTimeout</code>。</p><p>因为 <code>Promise.then</code> 和 <code>MutationObserve</code> 属于 <code>microtask</code>，而 <code>setTimeout</code> 属于 <code>task</code>。</p><p><a href="https://www.zhihu.com/question/55364497/answer/144215284" target="_blank" rel="noopener">为啥要用 <code>microtask</code> ？</a></p><p>根据 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noopener">HTML Standard</a>，在每个 <code>task</code> 运行完以后，<code>UI</code> 都会重渲染，那么在 <code>microtask</code> 中就完成数据更新，当前 <code>task</code> 结束就可以得到最新的 <code>UI</code> 了。反之如果新建一个 <code>task</code> 来做数据更新，那么渲染就会进行两次。（当然，浏览器实现有不少不一致的地方）</p><p>有兴趣的话推荐看下这篇文章：<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules</a></p><h2 id="8-代码重构"><a href="#8-代码重构" class="headerlink" title="8.代码重构"></a>8.代码重构</h2><p>之前的代码为了方便地获取 vm 和 watch，在 <code>bindData</code> 函数中又定义了三个函数，整个代码耦合度太高了，函数依赖很不明确。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码耦合度太高</span></span><br><span class="line"><span class="keyword">const</span> bindData = <span class="function">(<span class="params">vm, watch</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> defineReactive = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> observeArray = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> observeDeep = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在下一步编写单元测试的时候很麻烦。</p><p>为了写测试让咱们来重构一把，利用学习过的<strong>函数式编程</strong>中的<strong>高阶函数</strong>把依赖注入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高阶函数，传递 vm 和 watch 然后得到 asyncSetData</span></span><br><span class="line"><span class="keyword">const</span> getAsyncSetData = <span class="function">(<span class="params">vm, watch</span>) =&gt;</span> (&#123; ... &#125;) =&gt; &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 bindData 中移出来</span></span><br><span class="line"><span class="comment">// 原来放在里面就是为了获取 vm，然后调用 vm.setData</span></span><br><span class="line"><span class="comment">// 以及通过 watch 获取监听函数</span></span><br><span class="line"><span class="keyword">const</span> defineReactive = (&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    asyncSetData, <span class="comment">// 不传 vm 改成传递 asyncSetData</span></span><br><span class="line">&#125;) =&gt; &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理</span></span><br><span class="line"><span class="keyword">const</span> observeArray = (&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    asyncSetData, <span class="comment">// 同理</span></span><br><span class="line">&#125;) =&gt; &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样外移，因为依赖已注入了 asyncSetData</span></span><br><span class="line"><span class="keyword">const</span> getObserveDeep = <span class="function">(<span class="params">asyncSetData</span>) =&gt;</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数外移后代码逻辑更加清晰精简</span></span><br><span class="line"><span class="keyword">const</span> bindData = <span class="function">(<span class="params">vm, observeDeep</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> $data = observeDeep(vm.data)</span><br><span class="line">    vm.$data = $data</span><br><span class="line">    proxyData($data, vm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高阶函数是不是很腻害！代码瞬间就<strong>在没事的时候，在想的时候，到一个地方，不相同的地方，到这个地方，来了吧！可以瞧一瞧，不一样的地方，不相同的地方，改变了很多很多</strong></p><p><img src="/blog/imgs/tua-mp/很多很多.jpg" width="560"></p><p><strong>那么接下来你一定会偷偷地问自己，这么腻害的技术要去哪里学呢？</strong></p><p><img src="/blog/imgs/tua-mp/那么在哪里才能买得到呢.jpg" width="450"></p><ul><li><a href="https://slides.com/yangzhenyu/functional-programming-in-javascript/live" target="_blank" rel="noopener">slide</a></li><li><a href="http://buptsteve.github.io/blog/2017/10/10/9.fp-in-js-1/">JavaScript 函数式编程（一）</a></li><li><a href="http://buptsteve.github.io/blog/2017/11/23/10.fp-in-js-2/">JavaScript 函数式编程（二）</a></li><li>JavaScript 函数式编程（三），正在制作 slide 中…</li></ul><h2 id="9-依赖收集"><a href="#9-依赖收集" class="headerlink" title="9.依赖收集"></a>9.依赖收集</h2><p>其实以上代码还有一个目前解决不了的问题：我们不知道 <code>computed</code> 里定义的函数的依赖是什么。所以在 <code>data</code> 数据更新的时候我们只好全部再算一遍。</p><p>也就是说当 <code>data</code> 中的某个数据更新的时候，我们并不知道它会影响哪个 <code>computed</code> 中的属性，特别的还有 <code>computed</code> 依赖于 <code>computed</code> 的情况。</p><p><strong>计将安出？</strong></p><p>且听下回分解~溜了溜了，嘿嘿嘿…</p><p><img src="/blog/imgs/tua-mp/塘主.gif" alt="塘主.gif"></p><p>以上 to be continued…</p><blockquote><p>本文地址： <a href="https://buptsteve.github.io/blog/2018/05/21/11.say-goodbye-to-mina-setData/" target="_blank" rel="external">https://buptsteve.github.io/blog/2018/05/21/11.say-goodbye-to-mina-setData/</a></p><footer><cite><a href="https://buptsteve.github.io/blog">@BuptStEve's Blog</a></cite></footer></blockquote></div><nav class="post-nav"><div class="waves-block waves-effect prev fl"><a href="/blog/2018/06/03/12.say-goodbye-to-mina-native/" id="post-prev" class="post-nav-link"><div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div><h4 class="title">「12」终极蛇皮上帝视角之微信小程序之告别“刀耕火种”</h4></a></div><div class="waves-block waves-effect next fr"><a href="/blog/2017/11/23/10.fp-in-js-2/" id="post-next" class="post-nav-link"><div class="tips">Next<i class="icon icon-angle-right icon-lg icon-pl"></i></div><h4 class="title">「10」JavaScript 函数式编程（二）</h4></a></div></nav><div class="duoshuo"><div class="ds-thread" data-thread-key="11.say-goodbye-to-mina-setData" data-title="「11」终极蛇皮上帝视角之微信小程序之告别 setData" data-url="https://buptsteve.github.io/blog/2018/05/21/11.say-goodbye-to-mina-setData/index.html"></div><script>var duoshuoQuery={short_name:"buptsteve"};!function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src=("https:"==document.location.protocol?"https:":"http:")+"//static.duoshuo.com/embed.js",t.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)}()</script></div></div></div></article></div></main><div class="mask" id="mask"></div><a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a><script src="/blog/js/wave.min.js"></script><script src="/blog/js/main.js"></script><div class="search-panel" id="search-panel"><ul class="search-result" id="search-result"></ul></div><script type="text/template" id="search-tpl"><li class="item">
        <a href="/{path}" class="waves-block waves-effect">
            <div class="title ellipsis" title="{title}">{title}</div>
            
            <div class="flex-row flex-middle">
                <div class="tags ellipsis">
                    {tags}
                </div>

                <time class="flex-col time">{date}</time>
            </div>
        </a>
    </li></script><script src="/blog/js/search.js"></script><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="//www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-85691829-1","auto"),ga("send","pageview")</script></body></html>