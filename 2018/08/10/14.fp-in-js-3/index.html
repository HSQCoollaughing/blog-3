<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="keywords" content=""><meta name="theme-color" content="#3F51B5"><meta name="summary" content="BuptStEve"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>「14」JavaScript 函数式编程（三） | BuptStEve&#39;s Blog | Talk is cheap show me the offer!</title><meta name="description" content="slide 地址 四、Talk is cheap！Show me the … MONEY! 以下内容主要参考自 Professor Frisby Introduces Composable Functional JavaScript   4.1.容器（Box）假设有个函数，可以接收一个来自用户输入的数字字符串。我们需要对其预处理一下，去除多余空格，将其转换为数字并加一，最后返回该值对应的字母。代码"><meta name="keywords" content="FP,JavaScript,函数式"><meta property="og:type" content="article"><meta property="og:title" content="「14」JavaScript 函数式编程（三）"><meta property="og:url" content="https://buptsteve.github.io/blog/2018/08/10/14.fp-in-js-3/index.html"><meta property="og:site_name" content="BuptStEve&#39;s Blog"><meta property="og:description" content="slide 地址 四、Talk is cheap！Show me the … MONEY! 以下内容主要参考自 Professor Frisby Introduces Composable Functional JavaScript   4.1.容器（Box）假设有个函数，可以接收一个来自用户输入的数字字符串。我们需要对其预处理一下，去除多余空格，将其转换为数字并加一，最后返回该值对应的字母。代码"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/show-me-the-money.jpg"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/五官太紧凑.jpg"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/老阔疼.jpg"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/稳.jpg"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/diagram-functor.png"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/cat.png"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/dog.jpg"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/diagram-monad.png"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/side-effects.png"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/natural_transformation.png"><meta property="og:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/黑人问号4合一.jpg"><meta property="og:updated_time" content="2018-08-10T07:40:30.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="「14」JavaScript 函数式编程（三）"><meta name="twitter:description" content="slide 地址 四、Talk is cheap！Show me the … MONEY! 以下内容主要参考自 Professor Frisby Introduces Composable Functional JavaScript   4.1.容器（Box）假设有个函数，可以接收一个来自用户输入的数字字符串。我们需要对其预处理一下，去除多余空格，将其转换为数字并加一，最后返回该值对应的字母。代码"><meta name="twitter:image" content="https://buptsteve.github.io/blog/imgs/fp-in-js/show-me-the-money.jpg"><link rel="shortcut icon" href="/blog/img/favicon.ico"><link rel="stylesheet" href="/blog/css/style.css"><link rel="alternative" href="/blog/atom.xml" title="BuptStEve&#39;s Blog" type="application/atom+xml"></head><body><div id="loading" class="active"></div><nav id="menu" class="hide"><div class="inner flex-row-vertical"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off"><i class="icon icon-lg icon-close"></i></a><div class="brand-wrap"><div class="brand"><a href="/blog" class="avatar"><img src="/blog/img/logo.jpg"></a><hgroup class="introduce"><h5 class="nickname">Steve Young</h5><a href="mailto:yangzhenyu2016@gmail.com" title="yangzhenyu2016@gmail.com" class="mail">yangzhenyu2016@gmail.com</a></hgroup></div></div><div class="scroll-wrap flex-col"><ul class="nav"><li class="waves-block waves-effect"><a href="/blog/"><i class="icon icon-lg icon-home"></i> 主页</a></li><li class="waves-block waves-effect"><a href="/blog/archives"><i class="icon icon-lg icon-archives"></i> Archives</a></li><li class="waves-block waves-effect"><a href="/blog/tags"><i class="icon icon-lg icon-tags"></i> Tags</a></li><li class="waves-block waves-effect"><a href="https://github.com/buptsteve" target="_blank"><i class="icon icon-lg icon-github"></i> Github</a></li><li class="waves-block waves-effect"><a href="http://weibo.com/0osteveyoungo0" target="_blank"><i class="icon icon-lg icon-weibo"></i> Weibo</a></li></ul><footer class="footer"><p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC"></a></p><p>BuptStEve&#39;s Blog &copy; 2018</p><p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p><a href="/blog/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a></footer></div></div></nav><main id="main"><header class="top-header" id="header"><div class="flex-row"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle"><i class="icon icon-lg icon-navicon"></i></a><div class="flex-col header-title ellipsis">「14」JavaScript 函数式编程（三）</div><div class="search-wrap" id="search-wrap"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i></a> <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search"><i class="icon icon-lg icon-search"></i></a></div></div></header><header class="content-header"><div class="container"><h1 class="author">「14」JavaScript 函数式编程（三）</h1><h5 class="subtitle"><time datetime="2018-08-10T07:30:00.000Z" itemprop="datePublished" class="page-time">2018-08-10</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/全栈/">全栈</a></li></ul></h5></div></header><div class="container body-wrap"><article id="post-14.fp-in-js-3" class="article article-type-post" itemprop="blogPost"><div class="post-meta flex-row"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/FP/">FP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/函数式/">函数式</a></li></ul></div><div class="post-body"><aside class="post-widget" id="post-widget"><nav class="post-toc-wrap" id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#四、Talk-is-cheap！Show-me-the-…-MONEY"><span class="post-toc-text">四、Talk is cheap！Show me the … MONEY!</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-1-容器（Box）"><span class="post-toc-text">4.1.容器（Box）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-Either-Maybe"><span class="post-toc-text">4.2.Either / Maybe</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-3-Chain-FlatMap-bind-gt-gt"><span class="post-toc-text">4.3.Chain / FlatMap / bind / &gt;&gt;=</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-4-半群（Semigroup）"><span class="post-toc-text">4.4.半群（Semigroup）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-5-幺半群（Monoid）"><span class="post-toc-text">4.5.幺半群（Monoid）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-6-foldMap"><span class="post-toc-text">4.6.foldMap</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-套路"><span class="post-toc-text">1.套路</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-List、Map"><span class="post-toc-text">2.List、Map</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-利用-List、Map-重构"><span class="post-toc-text">3.利用 List、Map 重构</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-利用-foldMap-重构"><span class="post-toc-text">4.利用 foldMap 重构</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-7-LazyBox"><span class="post-toc-text">4.7.LazyBox</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-8-Task"><span class="post-toc-text">4.8.Task</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-基本介绍"><span class="post-toc-text">1.基本介绍</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-使用示例"><span class="post-toc-text">2.使用示例</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-原理意义"><span class="post-toc-text">3.原理意义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-异步嵌套示例"><span class="post-toc-text">4.异步嵌套示例</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-9-Applicative-Functor"><span class="post-toc-text">4.9.Applicative Functor</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-问题引入"><span class="post-toc-text">1.问题引入</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-基本介绍"><span class="post-toc-text">2.基本介绍</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-Lift-家族"><span class="post-toc-text">3.Lift 家族</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-Lift-应用"><span class="post-toc-text">4.Lift 应用</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-10-Traversable"><span class="post-toc-text">4.10.Traversable</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-问题引入-1"><span class="post-toc-text">1.问题引入</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-实现"><span class="post-toc-text">2.实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-11-自然变换（Natural-Transformations）"><span class="post-toc-text">4.11.自然变换（Natural Transformations）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-基本概念"><span class="post-toc-text">1.基本概念</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-应用场景"><span class="post-toc-text">2.应用场景</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-12-同构（Isomorphisms）"><span class="post-toc-text">4.12.同构（Isomorphisms）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-例如-String-和-Char-就是同构的。"><span class="post-toc-text">1. 例如 String 和 [Char] 就是同构的。</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-再来看看最多有一个参数的数组-a-和-Either-的同构关系"><span class="post-toc-text">2. 再来看看最多有一个参数的数组 [a] 和 Either 的同构关系</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考资料"><span class="post-toc-text">参考资料</span></a></li></ol></nav></aside><div class="post-main"><div class="post-content" id="post-content" itemprop="postContent"><p><strong><a href="https://slides.com/yangzhenyu/functional-programming-in-javascript" target="_blank" rel="noopener">slide 地址</a></strong></p><h2 id="四、Talk-is-cheap！Show-me-the-…-MONEY"><a href="#四、Talk-is-cheap！Show-me-the-…-MONEY" class="headerlink" title="四、Talk is cheap！Show me the … MONEY!"></a>四、Talk is cheap！Show me the … MONEY!</h2><blockquote><p>以下内容主要参考自 <a href="https://egghead.io/courses/professor-frisby-introduces-composable-functional-javascript" target="_blank" rel="noopener">Professor Frisby Introduces Composable Functional JavaScript</a></p></blockquote><p><img src="/blog/imgs/fp-in-js/show-me-the-money.jpg" alt="show-me-the-money"></p><h3 id="4-1-容器（Box）"><a href="#4-1-容器（Box）" class="headerlink" title="4.1.容器（Box）"></a>4.1.容器（Box）</h3><p>假设有个函数，可以接收一个来自用户输入的数字字符串。我们需要对其预处理一下，去除多余空格，将其转换为数字并加一，最后返回该值对应的字母。代码大概长这样…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nextCharForNumStr = <span class="function">(<span class="params">str</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">String</span>.fromCharCode(<span class="built_in">parseInt</span>(str.trim()) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">nextCharForNumStr(<span class="string">' 64 '</span>) <span class="comment">// "A"</span></span><br></pre></td></tr></table></figure><p>因缺思厅，这代码嵌套的也太紧凑了，看多了“老阔疼”，赶紧重构一把…</p><p><img src="/blog/imgs/fp-in-js/五官太紧凑.jpg" alt="五官太紧凑"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nextCharForNumStr = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> trimmed = str.trim()</span><br><span class="line">  <span class="keyword">const</span> number = <span class="built_in">parseInt</span>(trimmed)</span><br><span class="line">  <span class="keyword">const</span> nextNumber = number + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode(nextNumber)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nextCharForNumStr(<span class="string">' 64 '</span>) <span class="comment">// 'A'</span></span><br></pre></td></tr></table></figure><p>很显然，经过之前内容的熏（xi）陶（nao），一眼就可以看出这个修订版代码很不 Pointfree…</p><p>为了这些只用一次的中间变量还要去想或者去查翻译，也是容易“老阔疼”，再改再改~</p><p><img src="/blog/imgs/fp-in-js/老阔疼.jpg" alt="老阔疼"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nextCharForNumStr = <span class="function">(<span class="params">str</span>) =&gt;</span> [str]</span><br><span class="line">  .map(<span class="function"><span class="params">s</span> =&gt;</span> s.trim())</span><br><span class="line">  .map(<span class="function"><span class="params">s</span> =&gt;</span> <span class="built_in">parseInt</span>(s))</span><br><span class="line">  .map(<span class="function"><span class="params">i</span> =&gt;</span> i + <span class="number">1</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">i</span> =&gt;</span> <span class="built_in">String</span>.fromCharCode(i))</span><br><span class="line"></span><br><span class="line">nextCharForNumStr(<span class="string">' 64 '</span>) <span class="comment">// ['A']</span></span><br></pre></td></tr></table></figure><p>这次借助数组的 map 方法，我们将必须的4个步骤拆分成了4个小函数。</p><p>这样一来再也不用去想中间变量的名称到底叫什么，而且每一步做的事情十分的清晰，一眼就可以看出这段代码在干嘛。</p><p>我们将原本的字符串变量 str 放在数组中变成了 [str]，这里就像放在一个容器里一样。</p><blockquote><p>代码是不是感觉好 door~~ 了？</p></blockquote><p><img src="/blog/imgs/fp-in-js/稳.jpg" alt="稳"></p><p>不过在这里我们可以更进一步，让我们来创建一个新的类型 Box。我们将同样定义 map 方法，让其实现同样的功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Box = <span class="function">(<span class="params">x</span>) =&gt;</span> (&#123;</span><br><span class="line">  map: <span class="function"><span class="params">f</span> =&gt;</span> Box(f(x)),        <span class="comment">// 返回容器为了链式调用</span></span><br><span class="line">  fold: <span class="function"><span class="params">f</span> =&gt;</span> f(x),            <span class="comment">// 将元素从容器中取出</span></span><br><span class="line">  inspect: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`Box(<span class="subst">$&#123;x&#125;</span>)`</span>, <span class="comment">// 看容器里有啥</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextCharForNumStr = <span class="function">(<span class="params">str</span>) =&gt;</span> Box(str)</span><br><span class="line">  .map(<span class="function"><span class="params">s</span> =&gt;</span> s.trim())</span><br><span class="line">  .map(<span class="function"><span class="params">i</span> =&gt;</span> <span class="built_in">parseInt</span>(i))</span><br><span class="line">  .map(<span class="function"><span class="params">i</span> =&gt;</span> i + <span class="number">1</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">i</span> =&gt;</span> <span class="built_in">String</span>.fromCharCode(i))</span><br><span class="line">  .fold(<span class="function"><span class="params">c</span> =&gt;</span> c.toLowerCase()) <span class="comment">// 可以轻易地继续调用新的函数</span></span><br><span class="line"></span><br><span class="line">nextCharForNumStr(<span class="string">' 64 '</span>) <span class="comment">// a</span></span><br></pre></td></tr></table></figure><p>此外创建一个容器，除了像函数一样直接传递参数以外，还可以使用静态方法 <code>of</code>。</p><blockquote><p>函数式编程一般约定，函子有一个 of 方法，用来生成新的容器。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box(<span class="number">1</span>) === Box.of(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>其实这个 <code>Box</code> 就是一个函子（functor），因为它实现了 <code>map</code> 函数。当然你也可以叫它 <code>Mappable</code> 或者其他名称。</p><p>不过为了保持与范畴学定义的名称一致，我们就站在巨人的肩膀上不要再发明新名词啦~（后面小节的各种奇怪名词也是来源于数学名词）。</p><blockquote><p>functor 是实现了 map 函数并遵守一些特定规则的容器类型。</p></blockquote><p><strong>那么这些特定的规则具体是什么咧？</strong></p><p><strong>1. 规则一：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fx.map(f).map(g) === fx.map(<span class="function"><span class="params">x</span> =&gt;</span> f(g)(x))</span><br></pre></td></tr></table></figure><p>这其实就是函数组合…</p><p><strong>2. 规则二：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> id = <span class="function"><span class="params">x</span> =&gt;</span> x</span><br><span class="line"></span><br><span class="line">fx.map(id) === id(fx)</span><br></pre></td></tr></table></figure><p><img src="/blog/imgs/fp-in-js/diagram-functor.png" alt="diagram-functor"></p><h3 id="4-2-Either-Maybe"><a href="#4-2-Either-Maybe" class="headerlink" title="4.2.Either / Maybe"></a>4.2.Either / Maybe</h3><p><img src="/blog/imgs/fp-in-js/cat.png" alt="cat"></p><p>假设现在有个需求：获取对应颜色的十六进制的 RGB 值，并返回去掉<code>#</code>后的大写值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> findColor = <span class="function">(<span class="params">name</span>) =&gt;</span> (&#123;</span><br><span class="line">  red: <span class="string">'#ff4444'</span>,</span><br><span class="line">  blue: <span class="string">'#3b5998'</span>,</span><br><span class="line">  yellow: <span class="string">'#fff68f'</span>,</span><br><span class="line">&#125;)[name]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> redColor = findColor(<span class="string">'red'</span>)</span><br><span class="line">  .slice(<span class="number">1</span>)</span><br><span class="line">  .toUpperCase() <span class="comment">// FF4444</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> greenColor = findColor(<span class="string">'green'</span>)</span><br><span class="line">  .slice(<span class="number">1</span>)</span><br><span class="line">  .toUpperCase()</span><br><span class="line"><span class="comment">// Uncaught TypeError:</span></span><br><span class="line"><span class="comment">// Cannot read property 'slice' of undefined</span></span><br></pre></td></tr></table></figure><p>以上代码在输入已有颜色的 <code>key</code> 值时运行良好，不过一旦传入其他颜色就会报错。咋办咧？</p><p>暂且不提条件判断和各种奇技淫巧的错误处理。咱们来先看看函数式的解决方案~</p><p>函数式将错误处理抽象成一个 <code>Either</code> 容器，而这个容器由两个子容器 <code>Right</code> 和 <code>Left</code> 组成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Either 由 Right 和 Left 组成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Left = <span class="function">(<span class="params">x</span>) =&gt;</span> (&#123;</span><br><span class="line">  map: <span class="function"><span class="params">f</span> =&gt;</span> Left(x),            <span class="comment">// 忽略传入的 f 函数</span></span><br><span class="line">  fold: <span class="function">(<span class="params">f, g</span>) =&gt;</span> f(x),         <span class="comment">// 使用左边的函数</span></span><br><span class="line">  inspect: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`Left(<span class="subst">$&#123;x&#125;</span>)`</span>,  <span class="comment">// 看容器里有啥</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Right = <span class="function">(<span class="params">x</span>) =&gt;</span> (&#123;</span><br><span class="line">  map: <span class="function"><span class="params">f</span> =&gt;</span> Right(f(x)),        <span class="comment">// 返回容器为了链式调用</span></span><br><span class="line">  fold: <span class="function">(<span class="params">f, g</span>) =&gt;</span> g(x),         <span class="comment">// 使用右边的函数</span></span><br><span class="line">  inspect: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`Right(<span class="subst">$&#123;x&#125;</span>)`</span>, <span class="comment">// 看容器里有啥</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 来测试看看~</span></span><br><span class="line"><span class="keyword">const</span> right = Right(<span class="number">4</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">7</span> + <span class="number">1</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">x</span> =&gt;</span> x / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">right.inspect() <span class="comment">// Right(14.5)</span></span><br><span class="line">right.fold(<span class="function"><span class="params">e</span> =&gt;</span> <span class="string">'error'</span>, x =&gt; x) <span class="comment">// 14.5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> left = Left(<span class="number">4</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">7</span> + <span class="number">1</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">x</span> =&gt;</span> x / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">left.inspect() <span class="comment">// Left(4)</span></span><br><span class="line">left.fold(<span class="function"><span class="params">e</span> =&gt;</span> <span class="string">'error'</span>, x =&gt; x) <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>可以看出 <code>Right</code> 和 <code>Left</code> 相似于 <code>Box</code>：</p><ul><li>最大的不同就是 <code>fold</code> 函数，这里需要传两个回调函数，左边的给 <code>Left</code> 使用，右边的给 <code>Right</code> 使用。</li><li>其次就是 <code>Left</code> 的 <code>map</code> 函数忽略了传入的函数（因为出错了嘛，当然不能继续执行啦）。</li></ul><p>现在让我们回到之前的问题来~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fromNullable = <span class="function">(<span class="params">x</span>) =&gt;</span> x == <span class="literal">null</span></span><br><span class="line">  ? Left(<span class="literal">null</span>)</span><br><span class="line">  : Right(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> findColor = <span class="function">(<span class="params">name</span>) =&gt;</span> fromNullable((&#123;</span><br><span class="line">  red: <span class="string">'#ff4444'</span>,</span><br><span class="line">  blue: <span class="string">'#3b5998'</span>,</span><br><span class="line">  yellow: <span class="string">'#fff68f'</span>,</span><br><span class="line">&#125;)[name])</span><br><span class="line"></span><br><span class="line">findColor(<span class="string">'green'</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">c</span> =&gt;</span> c.slice(<span class="number">1</span>))</span><br><span class="line">  .fold(</span><br><span class="line">    e =&gt; <span class="string">'no color'</span>,</span><br><span class="line">    c =&gt; c.toUpperCase()</span><br><span class="line">  ) <span class="comment">// no color</span></span><br></pre></td></tr></table></figure><p>从以上代码不知道各位读者老爷们有没有看出使用 <code>Either</code> 的好处，那就是可以放心地对于这种类型的数据进行任何操作，而不是在每个函数里面小心翼翼地进行参数检查。</p><h3 id="4-3-Chain-FlatMap-bind-gt-gt"><a href="#4-3-Chain-FlatMap-bind-gt-gt" class="headerlink" title="4.3.Chain / FlatMap / bind / &gt;&gt;="></a>4.3.<code>Chain</code> / <code>FlatMap</code> / <code>bind</code> / <code>&gt;&gt;=</code></h3><p>假设现在有个 json 文件里面保存了端口，我们要读取这个文件获取端口，要是出错了返回默认值 3000。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config.json</span></span><br><span class="line">&#123; <span class="string">"port"</span>: <span class="number">8888</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// chain.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getPort = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> str = fs.readFileSync(<span class="string">'config.json'</span>)</span><br><span class="line">    <span class="keyword">const</span> &#123; port &#125; = <span class="built_in">JSON</span>.parse(str)</span><br><span class="line">    <span class="keyword">return</span> port</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3000</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = getPort()</span><br></pre></td></tr></table></figure><p>so easy~，下面让我们来用 Either 来重构下看看效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Left = <span class="function">(<span class="params">x</span>) =&gt;</span> (&#123; ... &#125;)</span><br><span class="line"><span class="keyword">const</span> Right = <span class="function">(<span class="params">x</span>) =&gt;</span> (&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tryCatch = <span class="function">(<span class="params">f</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Right(f())</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> Left(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getPort = <span class="function"><span class="params">()</span> =&gt;</span> tryCatch(</span><br><span class="line">    () =&gt; fs.readFileSync(<span class="string">'config.json'</span>)</span><br><span class="line">  )</span><br><span class="line">  .map(<span class="function"><span class="params">c</span> =&gt;</span> <span class="built_in">JSON</span>.parse(c))</span><br><span class="line">  .fold(<span class="function"><span class="params">e</span> =&gt;</span> <span class="number">3000</span>, c =&gt; c.port)</span><br></pre></td></tr></table></figure><blockquote><p>啊，常规操作，看起来不错哟~</p></blockquote><blockquote><p>不错你个蛇头…！</p></blockquote><p>以上代码有个 <code>bug</code>，当 <code>json</code> 文件写的有问题时，在 <code>JSON.parse</code> 时会出错，所以这步也要用 <code>tryCatch</code> 包起来。</p><p>但是，问题来了…</p><p>返回值这时候可能是 <code>Right(Right(&#39;&#39;))</code> 或者 <code>Right(Left(e))</code>（想想为什么不是 <code>Left(Right(&#39;&#39;))</code> 或者 <code>Left(Left(e))）</code>。</p><p>也就是说我们现在得到的是两层容器，就像俄罗斯套娃一样…</p><p>要取出容器中的容器中的值，我们就需要 <code>fold</code> 两次…！（若是再多几层…）</p><p><img height="400" alt="dog" src="/blog/imgs/fp-in-js/dog.jpg"></p><p>因缺思厅，所以聪明机智的函数式又想出一个新方法 chain~，其实很简单，就是我知道这里要返回容器了，那就不要再用容器包了呗。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Left = <span class="function">(<span class="params">x</span>) =&gt;</span> (&#123;</span><br><span class="line">  ...</span><br><span class="line">  chain: <span class="function"><span class="params">f</span> =&gt;</span> Left(x) <span class="comment">// 和 map 一样，直接返回 Left</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Right = <span class="function">(<span class="params">x</span>) =&gt;</span> (&#123;</span><br><span class="line">  ...</span><br><span class="line">  chain: <span class="function"><span class="params">f</span> =&gt;</span> f(x),   <span class="comment">// 直接返回，不使用容器再包一层了</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tryCatch = <span class="function">(<span class="params">f</span>) =&gt;</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getPort = <span class="function"><span class="params">()</span> =&gt;</span> tryCatch(</span><br><span class="line">    () =&gt; fs.readFileSync(<span class="string">'config.json'</span>)</span><br><span class="line">  )</span><br><span class="line">  .chain(<span class="function"><span class="params">c</span> =&gt;</span> tryCatch(<span class="built_in">JSON</span>.parse(c))) <span class="comment">// 使用 chain 和 tryCatch</span></span><br><span class="line">  .fold(</span><br><span class="line">    e =&gt; <span class="number">3000</span>,</span><br><span class="line">    c =&gt; c.port</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>其实这里的 <code>Left</code> 和 <code>Right</code> 就是单子（Monad），因为它实现了 <code>chain</code> 函数。</p><blockquote><p>monad 是实现了 chain 函数并遵守一些特定规则的容器类型。</p></blockquote><p>在继续介绍这些特定规则前，我们先定义一个 <code>join</code> 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的 m 指的是一种 Monad 实例</span></span><br><span class="line"><span class="keyword">const</span> join = <span class="function"><span class="params">m</span> =&gt;</span> m.chain(<span class="function"><span class="params">x</span> =&gt;</span> x)</span><br></pre></td></tr></table></figure><ol><li>规则一：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">join(m.map(join)) === join(join(m)</span><br></pre></td></tr></table></figure><ol start="2"><li>规则二：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的 M 指的是一种 Monad 类型</span></span><br><span class="line">join(M.of(m) === join(m.map(M.of))</span><br></pre></td></tr></table></figure><p>这条规则说明了 <code>map</code> 可被 <code>chain</code> 和 <code>of</code> 所定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.map(f) === m.chain(<span class="function"><span class="params">x</span> =&gt;</span> M.of(f(x)))</span><br></pre></td></tr></table></figure><p><strong>也就是说 <code>Monad</code> 一定是 <code>Functor</code></strong></p><p><code>Monad</code> 十分强大，之后我们将利用它处理各种副作用。但别对其感到困惑，<code>chain</code> 的主要作用不过将两种不同的类型连接（<code>join</code>）在一起罢了。</p><p><img src="/blog/imgs/fp-in-js/diagram-monad.png" alt="diagram-monad"></p><h3 id="4-4-半群（Semigroup）"><a href="#4-4-半群（Semigroup）" class="headerlink" title="4.4.半群（Semigroup）"></a>4.4.半群（Semigroup）</h3><blockquote><p>定义一：对于非空集合 S，若在 S 上定义了二元运算 ○，使得对于任意的 a, b ∈ S,有 a ○ b ∈ S，则称 {S, ○} 为广群。</p></blockquote><blockquote><p>定义二：若 {S, ○} 为广群，且运算 ○ 还满足结合律，即：任意 a, b, c ∈ S，有 (a ○ b) ○ c = a ○ (b ○ c)，则称 {S, ○} 为半群。</p></blockquote><p>举例来说，JavaScript 中有 concat 方法的对象都是半群。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串和 concat 是半群</span></span><br><span class="line"><span class="string">'1'</span>.concat(<span class="string">'2'</span>).concat(<span class="string">'3'</span>) === <span class="string">'1'</span>.concat(<span class="string">'2'</span>.concat(<span class="string">'3'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组和 concat 是半群</span></span><br><span class="line">[<span class="number">1</span>].concat([<span class="number">2</span>]).concat([<span class="number">3</span>]) === [<span class="number">1</span>].concat([<span class="number">2</span>].concat([<span class="number">3</span>]))</span><br></pre></td></tr></table></figure><p>虽然理论上对于 <code>&lt;Number, +&gt;</code> 来说它符合半群的定义：</p><ul><li>数字相加返回的仍然是数字（广群）</li><li>加法满足结合律（半群）</li></ul><p><strong>但是数字并没有 concat 方法</strong></p><p>没事儿，让我们来实现这个由 <code>&lt;Number, +&gt;</code> 组成的半群 Sum。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Sum = <span class="function">(<span class="params">x</span>) =&gt;</span> (&#123;</span><br><span class="line">  x,</span><br><span class="line">  concat: <span class="function">(<span class="params">&#123; x: y &#125;</span>) =&gt;</span> Sum(x + y), <span class="comment">// 采用解构获取值</span></span><br><span class="line">  inspect: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`Sum(<span class="subst">$&#123;x&#125;</span>)`</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Sum(<span class="number">1</span>)</span><br><span class="line">  .concat(Sum(<span class="number">2</span>))</span><br><span class="line">  .inspect() <span class="comment">// Sum(3)</span></span><br></pre></td></tr></table></figure><p>除此之外，<code>&lt;Boolean, &amp;&amp;&gt;</code> 也满足半群的定义~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> All = <span class="function">(<span class="params">x</span>) =&gt;</span> (&#123;</span><br><span class="line">  x,</span><br><span class="line">  concat: <span class="function">(<span class="params">&#123; x: y &#125;</span>) =&gt;</span> All(x &amp;&amp; y), <span class="comment">// 采用解构获取值</span></span><br><span class="line">  inspect: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`All(<span class="subst">$&#123;x&#125;</span>)`</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">All(<span class="literal">true</span>)</span><br><span class="line">  .concat(All(<span class="literal">false</span>))</span><br><span class="line">  .inspect() <span class="comment">// All(true)</span></span><br></pre></td></tr></table></figure><p>最后，让我们对于字符串创建一个新的半群 First，顾名思义，它会忽略除了第一个参数以外的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> First = <span class="function">(<span class="params">x</span>) =&gt;</span> (&#123;</span><br><span class="line">  x,</span><br><span class="line">  concat: <span class="function"><span class="params">()</span> =&gt;</span> First(x), <span class="comment">// 忽略后续的值</span></span><br><span class="line">  inspect: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`First(<span class="subst">$&#123;x&#125;</span>)`</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">First(<span class="string">'blah'</span>)</span><br><span class="line">  .concat(First(<span class="string">'yoyoyo'</span>))</span><br><span class="line">  .inspect() <span class="comment">// First('blah')</span></span><br></pre></td></tr></table></figure><blockquote><p>咿呀哟？是不是感觉这个半群和其他半群好像有点儿不太一样，不过具体是啥又说不上来…？</p></blockquote><p>这个问题留给下个小节。在此先说下这玩意儿有啥用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data1 = &#123;</span><br><span class="line">  name: <span class="string">'steve'</span>,</span><br><span class="line">  isPaid: <span class="literal">true</span>,</span><br><span class="line">  points: <span class="number">10</span>,</span><br><span class="line">  friends: [<span class="string">'jame'</span>],</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> data2 = &#123;</span><br><span class="line">  name: <span class="string">'steve'</span>,</span><br><span class="line">  isPaid: <span class="literal">false</span>,</span><br><span class="line">  points: <span class="number">2</span>,</span><br><span class="line">  friends: [<span class="string">'young'</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有两个数据，需要将其合并，那么利用半群，我们可以对 name 应用 First，对于 isPaid 应用 All，对于 points 应用 Sum，最后的 friends 已经是半群了…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Sum = <span class="function">(<span class="params">x</span>) =&gt;</span> (&#123; ... &#125;)</span><br><span class="line"><span class="keyword">const</span> All = <span class="function">(<span class="params">x</span>) =&gt;</span> (&#123; ... &#125;)</span><br><span class="line"><span class="keyword">const</span> First = <span class="function">(<span class="params">x</span>) =&gt;</span> (&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data1 = &#123;</span><br><span class="line">  name: First(<span class="string">'steve'</span>),</span><br><span class="line">  isPaid: All(<span class="literal">true</span>),</span><br><span class="line">  points: Sum(<span class="number">10</span>),</span><br><span class="line">  friends: [<span class="string">'jame'</span>],</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> data2 = &#123;</span><br><span class="line">  name: First(<span class="string">'steve'</span>),</span><br><span class="line">  isPaid: All(<span class="literal">false</span>),</span><br><span class="line">  points: Sum(<span class="number">2</span>),</span><br><span class="line">  friends: [<span class="string">'young'</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> concatObj = <span class="function">(<span class="params">obj1, obj2</span>) =&gt;</span> <span class="built_in">Object</span>.entries(obj1)</span><br><span class="line">  .map(<span class="function">(<span class="params">[ key, val ]</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="comment">// concat 两个对象的值</span></span><br><span class="line">    [key]: val.concat(obj2[key]),</span><br><span class="line">  &#125;))</span><br><span class="line">  .reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> (&#123; ...acc, ...cur &#125;))</span><br><span class="line"></span><br><span class="line">concatObj(data1, data2)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    name: First('steve'),</span></span><br><span class="line"><span class="comment">    isPaid: All(false),</span></span><br><span class="line"><span class="comment">    points: Sum(12),</span></span><br><span class="line"><span class="comment">    friends: ['jame', 'young'],</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="4-5-幺半群（Monoid）"><a href="#4-5-幺半群（Monoid）" class="headerlink" title="4.5.幺半群（Monoid）"></a>4.5.幺半群（Monoid）</h3><blockquote><p>幺半群是一个存在单位元（幺元）的半群。</p></blockquote><p>半群我们都懂，不过啥是单位元？</p><blockquote><p>单位元：对于半群 &lt;S, ○&gt;，存在 e ∈ S，使得任意 a ∈ S 有 a ○ e = e ○ a</p></blockquote><p>举例来说，对于数字加法这个半群来说，0就是它的单位元，所以 <code>&lt;Number, +, 0&gt;</code> 就构成一个幺半群。同理：</p><ul><li>对于 <code>&lt;Number, *&gt;</code> 来说单位元就是 1</li><li>对于 <code>&lt;Boolean, &amp;&amp;&gt;</code> 来说单位元就是 true</li><li>对于 <code>&lt;Boolean, ||&gt;</code> 来说单位元就是 false</li><li>对于 <code>&lt;Number, Min&gt;</code> 来说单位元就是 Infinity</li><li>对于 <code>&lt;Number, Max&gt;</code> 来说单位元就是 -Infinity</li></ul><p><strong>那么 <code>&lt;String, First&gt;</code> 是幺半群么？</strong></p><p>显然我们<strong>并不能</strong>找到这样一个单位元 e 满足</p><p><code>First(e).concat(First(&#39;steve&#39;)) === First(&#39;steve&#39;).concat(First(e))</code></p><p>这就是上一节留的小悬念，为何会感觉 First 与 Sum 和 All 不太一样的原因。</p><blockquote><p>格叽格叽，这两者有啥具体的差别么？</p></blockquote><p>其实看到幺半群的第一反应应该是<strong>默认值或初始值</strong>，例如 reduce 函数的第二个参数就是传入一个初始值或者说是默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sum</span></span><br><span class="line"><span class="keyword">const</span> Sum = <span class="function">(<span class="params">x</span>) =&gt;</span> (&#123;</span><br><span class="line">  ...</span><br><span class="line">  empty: <span class="function"><span class="params">()</span> =&gt;</span> Sum(<span class="number">0</span>), <span class="comment">// 单位元</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="params">xs</span> =&gt;</span> xs.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment">// 6</span></span><br><span class="line">sum([])         <span class="comment">// 0，而不是报错！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// all</span></span><br><span class="line"><span class="keyword">const</span> All = <span class="function">(<span class="params">x</span>) =&gt;</span> (&#123;</span><br><span class="line">  ...</span><br><span class="line">  empty: <span class="function"><span class="params">()</span> =&gt;</span> All(<span class="literal">true</span>), <span class="comment">// 单位元</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> all = <span class="function"><span class="params">xs</span> =&gt;</span> xs.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc &amp;&amp; cur, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">all([<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>]) <span class="comment">// false</span></span><br><span class="line">all([])                  <span class="comment">// true，而不是报错！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="keyword">const</span> First = <span class="function">(<span class="params">x</span>) =&gt;</span> (&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> first = <span class="function"><span class="params">xs</span> =&gt;</span> xs.reduce(acc, cur) =&gt; acc)</span><br><span class="line"></span><br><span class="line">first([<span class="string">'steve'</span>, <span class="string">'jame'</span>, <span class="string">'young'</span>]) <span class="comment">// steve</span></span><br><span class="line">first([])                         <span class="comment">// boom!!!</span></span><br></pre></td></tr></table></figure><p>从以上代码可以看出幺半群比半群要<strong>安全</strong>得多，</p><h3 id="4-6-foldMap"><a href="#4-6-foldMap" class="headerlink" title="4.6.foldMap"></a>4.6.foldMap</h3><h4 id="1-套路"><a href="#1-套路" class="headerlink" title="1.套路"></a>1.套路</h4><p>在上一节中幺半群的使用代码中，如果传入的都是幺半群实例而不是原始类型的话，你会发现其实都是一个套路…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Monoid = <span class="function">(<span class="params">x</span>) =&gt;</span> (&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> monoid = <span class="function"><span class="params">xs</span> =&gt;</span> xs.reduce(</span><br><span class="line">    (acc, cur) =&gt; acc.concat(cur),  <span class="comment">// 使用 concat 结合</span></span><br><span class="line">    Monoid.empty()                  <span class="comment">// 传入幺元</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">monoid([Monoid(a), Monoid(b), Monoid(c)]) <span class="comment">// 传入幺半群实例</span></span><br></pre></td></tr></table></figure><p>所以对于思维高度抽象的函数式来说，这样的代码肯定是需要继续重构精简的~</p><h4 id="2-List、Map"><a href="#2-List、Map" class="headerlink" title="2.List、Map"></a>2.List、Map</h4><p>在讲解如何重构之前，先介绍两个炒鸡常用的不可变数据结构：<code>List</code>、<code>Map</code>。</p><p>顾名思义，正好对应原生的 <code>Array</code> 和 <code>Object</code>。</p><h4 id="3-利用-List、Map-重构"><a href="#3-利用-List、Map-重构" class="headerlink" title="3.利用 List、Map 重构"></a>3.利用 List、Map 重构</h4><p>因为 <code>immutable</code> 库中的 <code>List</code> 和 <code>Map</code> 并没有 <code>empty</code> 属性和 <code>fold</code> 方法，所以我们首先扩展 List 和 Map~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; List, <span class="built_in">Map</span> &#125; <span class="keyword">from</span> <span class="string">'immutable'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> derived = &#123;</span><br><span class="line">  fold (empty) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc.concat(cur), empty)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List.prototype.empty = List()</span><br><span class="line">List.prototype.fold = derived.fold</span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span>.prototype.empty = <span class="built_in">Map</span>(&#123;&#125;)</span><br><span class="line"><span class="built_in">Map</span>.prototype.fold = derived.fold</span><br><span class="line"></span><br><span class="line"><span class="comment">// from https://github.com/DrBoolean/immutable-ext</span></span><br></pre></td></tr></table></figure><p>这样一来上一节的代码就可以精简成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">  .map(Sum)</span><br><span class="line">  .fold(Sum.empty())     <span class="comment">// Sum(6)</span></span><br><span class="line"></span><br><span class="line">List().fold(Sum.empty()) <span class="comment">// Sum(0)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span>(&#123; <span class="attr">steve</span>: <span class="number">1</span>, <span class="attr">young</span>: <span class="number">3</span> &#125;)</span><br><span class="line">  .map(Sum)</span><br><span class="line">  .fold(Sum.empty())     <span class="comment">// Sum(4)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span>().fold(Sum.empty())  <span class="comment">// Sum(0)</span></span><br></pre></td></tr></table></figure><h4 id="4-利用-foldMap-重构"><a href="#4-利用-foldMap-重构" class="headerlink" title="4.利用 foldMap 重构"></a>4.利用 foldMap 重构</h4><p>注意到 <code>map</code> 和 <code>fold</code> 这两步操作，从逻辑上来说是一个操作，所以我们可以新增 <code>foldMap</code> 方法来结合两者。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; List, <span class="built_in">Map</span> &#125; <span class="keyword">from</span> <span class="string">'immutable'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> derived = &#123;</span><br><span class="line">  fold (empty) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.foldMap(<span class="function"><span class="params">x</span> =&gt;</span> x, empty)</span><br><span class="line">  &#125;,</span><br><span class="line">  foldMap (f, empty) &#123;</span><br><span class="line">    <span class="keyword">return</span> empty != <span class="literal">null</span></span><br><span class="line">      <span class="comment">// 幺半群中将 f 的调用放在 reduce 中，提高效率</span></span><br><span class="line">      ? <span class="keyword">this</span>.reduce(</span><br><span class="line">          (acc, cur, idx) =&gt;</span><br><span class="line">            acc.concat(f(cur, idx)),</span><br><span class="line">          empty</span><br><span class="line">      )</span><br><span class="line">      : <span class="keyword">this</span></span><br><span class="line">        <span class="comment">// 在 map 中调用 f 是因为考虑到空的情况</span></span><br><span class="line">        .map(f)</span><br><span class="line">        .reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc.concat(cur))</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List.prototype.empty = List()</span><br><span class="line">List.prototype.fold = derived.fold</span><br><span class="line">List.prototype.foldMap = derived.foldMap</span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span>.prototype.empty = <span class="built_in">Map</span>(&#123;&#125;)</span><br><span class="line"><span class="built_in">Map</span>.prototype.fold = derived.fold</span><br><span class="line"><span class="built_in">Map</span>.prototype.foldMap = derived.foldMap</span><br><span class="line"></span><br><span class="line"><span class="comment">// from https://github.com/DrBoolean/immutable-ext</span></span><br></pre></td></tr></table></figure><p>所以最终版长这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">  .foldMap(Sum, Sum.empty()) <span class="comment">// Sum(6)</span></span><br><span class="line">List()</span><br><span class="line">  .foldMap(Sum, Sum.empty()) <span class="comment">// Sum(0)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">3</span> &#125;)</span><br><span class="line">  .foldMap(Sum, Sum.empty()) <span class="comment">// Sum(4)</span></span><br><span class="line"><span class="built_in">Map</span>()</span><br><span class="line">  .foldMap(Sum, Sum.empty()) <span class="comment">// Sum(0)</span></span><br></pre></td></tr></table></figure><h3 id="4-7-LazyBox"><a href="#4-7-LazyBox" class="headerlink" title="4.7.LazyBox"></a>4.7.LazyBox</h3><p>下面我们要来实现一个新容器 <code>LazyBox</code>。</p><p>顾名思义，这个容器很懒…</p><p>虽然你可以不停地用 <code>map</code> 给它分配任务，但是只要你不调用 <code>fold</code> 方法催它执行（就像 <code>deadline</code> 一样），它就死活不执行…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> LazyBox = <span class="function">(<span class="params">g</span>) =&gt;</span> (&#123;</span><br><span class="line">  map: <span class="function"><span class="params">f</span> =&gt;</span> LazyBox(<span class="function"><span class="params">()</span> =&gt;</span> f(g())),</span><br><span class="line">  fold: <span class="function"><span class="params">f</span> =&gt;</span> f(g()),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = LazyBox(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">' 64 '</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">s</span> =&gt;</span> s.trim())</span><br><span class="line">  .map(<span class="function"><span class="params">i</span> =&gt;</span> <span class="built_in">parseInt</span>(i))</span><br><span class="line">  .map(<span class="function"><span class="params">i</span> =&gt;</span> i + <span class="number">1</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">i</span> =&gt;</span> <span class="built_in">String</span>.fromCharCode(i))</span><br><span class="line">  <span class="comment">// 没有 fold 死活不执行</span></span><br><span class="line"></span><br><span class="line">result.fold(<span class="function"><span class="params">c</span> =&gt;</span> c.toLowerCase()) <span class="comment">// a</span></span><br></pre></td></tr></table></figure><h3 id="4-8-Task"><a href="#4-8-Task" class="headerlink" title="4.8.Task"></a>4.8.Task</h3><h4 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h4><p>有了上一节中 <code>LazyBox</code> 的基础之后，接下来我们来创建一个新的类型 <code>Task。</code></p><p>首先 <code>Task</code> 的构造函数可以接收一个函数以便延迟计算，当然也可以用 <code>of</code> 方法来创建实例，很自然的也有 <code>map</code>、<code>chain</code>、<code>concat</code>、<code>empty</code> 等方法。</p><p>与众不同的是它有个 <code>fork</code> 方法（类似于 <code>LazyBox</code> 中的 <code>fold</code> 方法，在 <code>fork</code> 执行前其他函数并不会执行），以及一个 <code>rejected</code> 方法，类似于 <code>Left</code>，忽略后续的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Task <span class="keyword">from</span> <span class="string">'data.task'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> showErr = <span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`err: <span class="subst">$&#123;e&#125;</span>`</span>)</span><br><span class="line"><span class="keyword">const</span> showSuc = <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`suc: <span class="subst">$&#123;x&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">Task</span><br><span class="line">  .of(<span class="number">1</span>)</span><br><span class="line">  .fork(showErr, showSuc) <span class="comment">// suc: 1</span></span><br><span class="line"></span><br><span class="line">Task</span><br><span class="line">  .of(<span class="number">1</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>)</span><br><span class="line">  .fork(showErr, showSuc) <span class="comment">// suc: 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似 Left</span></span><br><span class="line">Task</span><br><span class="line">  .rejected(<span class="number">1</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>)</span><br><span class="line">  .fork(showErr, showSuc) <span class="comment">// err: 1</span></span><br><span class="line"></span><br><span class="line">Task</span><br><span class="line">  .of(<span class="number">1</span>)</span><br><span class="line">  .chain(<span class="function"><span class="params">x</span> =&gt;</span> <span class="keyword">new</span> Task.of(x + <span class="number">1</span>))</span><br><span class="line">  .fork(showErr, showSuc) <span class="comment">// suc: 2</span></span><br></pre></td></tr></table></figure><h4 id="2-使用示例"><a href="#2-使用示例" class="headerlink" title="2.使用示例"></a>2.使用示例</h4><p>接下来让我们做一个发射飞弹的程序~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lauchMissiles = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  <span class="comment">// 和 promise 很像，不过 promise 会立即执行</span></span><br><span class="line">  <span class="comment">// 而且参数的位置也相反</span></span><br><span class="line">  <span class="keyword">new</span> Task(<span class="function">(<span class="params">rej, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'lauchMissiles'</span>)</span><br><span class="line">    res(<span class="string">'missile'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续对之前的任务添加后续操作（duang~给飞弹加特技！）</span></span><br><span class="line"><span class="keyword">const</span> app = lauchMissiles()</span><br><span class="line">  .map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="string">'!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时才执行（发射飞弹）</span></span><br><span class="line">app.fork(showErr, showSuc)</span><br></pre></td></tr></table></figure><h4 id="3-原理意义"><a href="#3-原理意义" class="headerlink" title="3.原理意义"></a>3.原理意义</h4><p>上面的代码乍一看好像没啥用，只不过是把待执行的代码用函数包起来了嘛，这还能吹上天？</p><p>还记得前面章节说到的副作用么？虽然说使用纯函数是没有副作用的，但是日常项目中有各种必须处理的副作用。</p><p>所以我们将有副作用的代码给包起来之后，这些新函数就都变成了纯函数，这样我们的整个应用的代码都是纯的~，并且在代码真正执行前（<code>fork</code> 前）还可以不断地 <code>compose</code> 别的函数，为我们的应用不断添加各种功能，这样一来整个应用的代码流程都会十分的简洁漂亮。</p><p><img src="/blog/imgs/fp-in-js/side-effects.png" alt="side-effects"></p><h4 id="4-异步嵌套示例"><a href="#4-异步嵌套示例" class="headerlink" title="4.异步嵌套示例"></a>4.异步嵌套示例</h4><p>以下代码做了 3 件事：</p><ol><li>读取 config1.json 中的数据</li><li>将内容中的 8 替换成 6</li><li>将新内容写到 config2.json 中</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  fs.readFile(<span class="string">'config1.json'</span>, <span class="string">'utf-8'</span>, (err, contents) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newContents = content.replace(<span class="regexp">/8/g</span>, <span class="string">'6'</span>)</span><br><span class="line"></span><br><span class="line">    fs.writeFile(<span class="string">'config2.json'</span>, newContents, (err, _) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'success!'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>让我们用 Task 来改写一下~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> Task <span class="keyword">from</span> <span class="string">'data.task'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cfg1 = <span class="string">'config1.json'</span></span><br><span class="line"><span class="keyword">const</span> cfg2 = <span class="string">'config2.json'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function">(<span class="params">file, enc</span>) =&gt;</span> (</span><br><span class="line">  <span class="keyword">new</span> Task(<span class="function">(<span class="params">rej, res</span>) =&gt;</span></span><br><span class="line">    fs.readFile(file, enc, (err, str) =&gt;</span><br><span class="line">      err ? rej(err) : res(str)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> writeFile = <span class="function">(<span class="params">file, str</span>) =&gt;</span> (</span><br><span class="line">  <span class="keyword">new</span> Task(<span class="function">(<span class="params">rej, res</span>) =&gt;</span></span><br><span class="line">    fs.writeFile(file, str, (err, suc) =&gt;</span><br><span class="line">      err ? rej(err) : res(suc)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = readFile(cfg1, <span class="string">'utf-8'</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">str</span> =&gt;</span> str.replace(<span class="regexp">/8/g</span>, <span class="string">'6'</span>))</span><br><span class="line">  .chain(<span class="function"><span class="params">str</span> =&gt;</span> writeFile(cfg2, str))</span><br><span class="line"></span><br><span class="line">app.fork(</span><br><span class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">`err: <span class="subst">$&#123;e&#125;</span>`</span>),</span><br><span class="line">  x =&gt; <span class="built_in">console</span>.log(<span class="string">`suc: <span class="subst">$&#123;x&#125;</span>`</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>代码一目了然，按照线性的先后顺序完成了任务，并且在其中还可以随意地插入或修改需求~</p><h3 id="4-9-Applicative-Functor"><a href="#4-9-Applicative-Functor" class="headerlink" title="4.9.Applicative Functor"></a>4.9.Applicative Functor</h3><h4 id="1-问题引入"><a href="#1-问题引入" class="headerlink" title="1.问题引入"></a>1.问题引入</h4><p><code>Applicative Functor</code> 提供了让不同的函子（functor）互相应用的能力。</p><blockquote><p>为啥我们需要函子的互相应用？什么是互相应用？</p></blockquote><p>先来看个简单例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="params">x</span> =&gt;</span> y =&gt; x + y</span><br><span class="line"></span><br><span class="line">add(Box.of(<span class="number">2</span>))(Box.of(<span class="number">3</span>)) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line">Box(<span class="number">2</span>).map(add).inspect() <span class="comment">// Box(y =&gt; 2 + y)</span></span><br></pre></td></tr></table></figure><p>现在我们有了一个容器，它的内部值为局部调用（partially applied）后的函数。接着我们想让它应用到 <code>Box(3)</code> 上，最后得到 <code>Box(5)</code> 的预期结果。</p><p>说到从容器中取值，那肯定第一个想到 <code>chain</code> 方法，让我们来试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Box(<span class="number">2</span>)</span><br><span class="line">  .chain(<span class="function"><span class="params">x</span> =&gt;</span> Box(<span class="number">3</span>).map(add(x)))</span><br><span class="line">  .inspect() <span class="comment">// Box(5)</span></span><br></pre></td></tr></table></figure><p>成功实现~，BUT，这种实现方法有个问题，那就是单子（Monad）的<strong>执行顺序</strong>问题。</p><p>我们这样实现的话，就必须等 <code>Box(2)</code> 执行完毕后，才能对 <code>Box(3)</code> 进行求值。假如这是两个异步任务，那么完全无法并行执行。</p><blockquote><p>别慌，吃口药~</p></blockquote><h4 id="2-基本介绍"><a href="#2-基本介绍" class="headerlink" title="2.基本介绍"></a>2.基本介绍</h4><p>下面介绍下主角：<code>ap</code>~：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Box = <span class="function">(<span class="params">x</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// 这里 box 是另一个 Box 的实例，x 是函数</span></span><br><span class="line">  ap: <span class="function"><span class="params">box</span> =&gt;</span> box.map(x),</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Box(add)</span><br><span class="line">  <span class="comment">// Box(y =&gt; 2 + y) ，咦？在哪儿见过？</span></span><br><span class="line">  .ap(Box(<span class="number">2</span>))</span><br><span class="line">  .ap(Box(<span class="number">3</span>)) <span class="comment">// Box(5)</span></span><br></pre></td></tr></table></figure><p><strong>运算规则</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F(x).map(f) === F(f).ap(F(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这就是为什么</span></span><br><span class="line">Box(<span class="number">2</span>).map(add) === Box(add).ap(Box(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><h4 id="3-Lift-家族"><a href="#3-Lift-家族" class="headerlink" title="3.Lift 家族"></a>3.Lift 家族</h4><p>由于日常编写代码的时候直接用 ap 的话模板代码太多，所以一般通过使用 Lift 家族系列函数来简化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F 该从哪儿来？</span></span><br><span class="line"><span class="keyword">const</span> fakeLiftA2 = <span class="function"><span class="params">f</span> =&gt;</span> fx =&gt; <span class="function"><span class="params">fy</span> =&gt;</span> F(f).ap(fx).ap(fy)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用运算规则转换一下~</span></span><br><span class="line"><span class="keyword">const</span> liftA2 = <span class="function"><span class="params">f</span> =&gt;</span> fx =&gt; <span class="function"><span class="params">fy</span> =&gt;</span> fx.map(f).ap(fy)</span><br><span class="line"></span><br><span class="line">liftA2(add, Box(<span class="number">2</span>), Box(<span class="number">4</span>)) <span class="comment">// Box(6)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理</span></span><br><span class="line"><span class="keyword">const</span> liftA3 = <span class="function"><span class="params">f</span> =&gt;</span> fx =&gt; <span class="function"><span class="params">fy</span> =&gt;</span> fz =&gt; fx.map(f).ap(fy).ap(fz)</span><br><span class="line"><span class="keyword">const</span> liftA4 = ...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> liftAN = ...</span><br></pre></td></tr></table></figure><h4 id="4-Lift-应用"><a href="#4-Lift-应用" class="headerlink" title="4.Lift 应用"></a>4.Lift 应用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假装是个 jQuery 接口~</span></span><br><span class="line"><span class="keyword">const</span> $ = <span class="function"><span class="params">selector</span> =&gt;</span></span><br><span class="line">  Either.of(&#123; selector, <span class="attr">height</span>: <span class="number">10</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getScreenSize = <span class="function"><span class="params">screen</span> =&gt;</span> head =&gt; <span class="function"><span class="params">foot</span> =&gt;</span></span><br><span class="line">  screen - (head.height + foot.height)</span><br><span class="line"></span><br><span class="line">liftA2(getScreenSize(<span class="number">800</span>))($(<span class="string">'header'</span>))($(<span class="string">'footer'</span>)) <span class="comment">// Right(780)</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List 的笛卡尔乘积</span></span><br><span class="line">List.of(<span class="function"><span class="params">x</span> =&gt;</span> y =&gt; <span class="function"><span class="params">z</span> =&gt;</span> [x, y, z].join(<span class="string">'-'</span>))</span><br><span class="line">  .ap(List.of(<span class="string">'tshirt'</span>, <span class="string">'sweater'</span>))</span><br><span class="line">  .ap(List.of(<span class="string">'white'</span>, <span class="string">'black'</span>))</span><br><span class="line">  .ap(List.of(<span class="string">'small'</span>, <span class="string">'medium'</span>, <span class="string">'large'</span>))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Db = (&#123;</span><br><span class="line">  find: <span class="function">(<span class="params">id, cb</span>) =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> Task(<span class="function">(<span class="params">rej, res</span>) =&gt;</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> res(&#123; id, <span class="attr">title</span>: <span class="string">`<span class="subst">$&#123;id&#125;</span>`</span>&#125;), <span class="number">100</span>)</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reportHeader = <span class="function">(<span class="params">p1, p2</span>) =&gt;</span></span><br><span class="line">  <span class="string">`Report: <span class="subst">$&#123;p1.title&#125;</span> compared to <span class="subst">$&#123;p2.title&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">Task.of(<span class="function"><span class="params">p1</span> =&gt;</span> p2 =&gt; reportHeader(p1, p2))</span><br><span class="line">  .ap(Db.find(<span class="number">20</span>))</span><br><span class="line">  .ap(Db.find(<span class="number">8</span>))</span><br><span class="line">  .fork(<span class="built_in">console</span>.error, <span class="built_in">console</span>.log) <span class="comment">// Report: 20 compared to 8</span></span><br><span class="line"></span><br><span class="line">liftA2</span><br><span class="line">  (<span class="function"><span class="params">p1</span> =&gt;</span> p2 =&gt; reportHeader(p1, p2))</span><br><span class="line">  (Db.find(<span class="number">20</span>))</span><br><span class="line">  (Db.find(<span class="number">8</span>))</span><br><span class="line">  .fork(<span class="built_in">console</span>.error, <span class="built_in">console</span>.log) <span class="comment">// Report: 20 compared to 8</span></span><br></pre></td></tr></table></figure><h3 id="4-10-Traversable"><a href="#4-10-Traversable" class="headerlink" title="4.10.Traversable"></a>4.10.Traversable</h3><h3 id="1-问题引入-1"><a href="#1-问题引入-1" class="headerlink" title="1.问题引入"></a>1.问题引入</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 详见 4.8.</span></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function">(<span class="params">file, enc</span>) =&gt;</span> (</span><br><span class="line">  <span class="keyword">new</span> Task(<span class="function">(<span class="params">rej, res</span>) =&gt;</span> ...)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> files = [<span class="string">'a.js'</span>, <span class="string">'b.js'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Task, Task]，我们得到了一个 Task 的数组</span></span><br><span class="line">files.map(<span class="function"><span class="params">file</span> =&gt;</span> readFile(file, <span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><p>然而我们想得到的是一个包含数组的 <code>Task([file1, file2])</code>，这样就可以调用它的 <code>fork</code> 方法，查看执行结果。</p><p>为了解决这个问题，函数式编程一般用一个叫做 <code>traverse</code> 的方法来实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">files</span><br><span class="line">  .traverse(Task.of, file =&gt; readFile(file, <span class="string">'utf-8'</span>))</span><br><span class="line">  .fork(<span class="built_in">console</span>.error, <span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure><p><code>traverse</code> 方法第一个参数是创建函子的函数，第二个参数是要应用在函子上的函数。</p><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h3><p>其实以上代码有 <code>bug</code>…，因为数组 Array 是没有 <code>traverse</code> 方法的。没事儿，让我们来实现一下~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.empty = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// traversable</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.traverse = <span class="function"><span class="keyword">function</span> (<span class="params">point, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.reduce(</span><br><span class="line">    (acc, cur) =&gt; acc</span><br><span class="line">      .map(<span class="function"><span class="params">z</span> =&gt;</span> y =&gt; z.concat(y))</span><br><span class="line">      .ap(fn(cur)),</span><br><span class="line">    point(<span class="keyword">this</span>.empty)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>看着有点儿晕？</p></blockquote><p>不急，首先看代码主体是一个 <code>reduce</code>，这个很熟了，就是从左到右遍历元素，其中的第二个参数传递的就是幺半群（monoid）的单位元（empty）。</p><p>再看第一个参数，主要就是通过 <code>applicative functor</code> 调用 <code>ap</code> 方法，再将其执行结果使用 <code>concat</code> 方法合并到数组中。</p><p>所以最后返回的就是 <code>Task([foo, bar])</code>，因此我们可以调用 <code>fork</code> 方法执行它。</p><h3 id="4-11-自然变换（Natural-Transformations）"><a href="#4-11-自然变换（Natural-Transformations）" class="headerlink" title="4.11.自然变换（Natural Transformations）"></a>4.11.自然变换（Natural Transformations）</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h4><p>自然变换就是一个函数，接受一个函子（functor），返回另一个函子。看看代码熟悉下~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> boxToEither = <span class="function"><span class="params">b</span> =&gt;</span> b.fold(Right)</span><br></pre></td></tr></table></figure><p>这个 <code>boxToEither</code> 函数就是一个自然变换（nt），它将函子 <code>Box</code> 转换成了另一个函子 <code>Either</code>。</p><blockquote><p>那么我们用 <code>Left</code> 行不行呢？</p></blockquote><p><strong>答案是不行！</strong></p><p>因为自然变换不仅是将一个函子转换成另一个函子，它还满足以下规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nt(x).map(f) == nt(x.map(f))</span><br></pre></td></tr></table></figure><p><img src="/blog/imgs/fp-in-js/natural_transformation.png" alt="natural_transformation"></p><p>举例来说就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> res1 = boxToEither(Box(<span class="number">100</span>))</span><br><span class="line">  .map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> res2 = boxToEither(</span><br><span class="line">  Box(<span class="number">100</span>).map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">res1 === res2 <span class="comment">// Right(200)</span></span><br></pre></td></tr></table></figure><p>即先对函子 <code>a</code> 做改变再将其转换为函子 <code>b</code>，是等价于现将函子 <code>a</code> 转换为函子 <code>b</code> 再做改变。</p><p>显然，<code>Left</code> 并不满足这个规则。所以任何满足这个规则的函数都是<strong>自然变换</strong>。</p><h4 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2.应用场景"></a>2.应用场景</h4><p>1.例1：得到一个数组小于等于 100 的最后一个数的两倍的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>, <span class="number">400</span>, <span class="number">5</span>, <span class="number">1000</span>]</span><br><span class="line"><span class="keyword">const</span> first = <span class="function"><span class="params">xs</span> =&gt;</span> fromNullable(xs[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">const</span> double = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span></span><br><span class="line"><span class="keyword">const</span> getLargeNums = <span class="function"><span class="params">xs</span> =&gt;</span> xs.filter(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">first(</span><br><span class="line">  getLargeNums(arr).map(double)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>根据自然变换，它显然和 <code>first(getLargeNums(arr)).map(double)</code> 是等价的。但是后者显然性能好得多。</p><p>再来看一个更复杂一点儿的例子：</p><p>2.例2：找到 id 为 3 的用户的最好的朋友的 id</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假 api</span></span><br><span class="line"><span class="keyword">const</span> fakeApi = <span class="function">(<span class="params">id</span>) =&gt;</span> (&#123;</span><br><span class="line">  id,</span><br><span class="line">  name: <span class="string">'user1'</span>,</span><br><span class="line">  bestFriendId: id + <span class="number">1</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假 Db</span></span><br><span class="line"><span class="keyword">const</span> Db = &#123;</span><br><span class="line">  find: <span class="function">(<span class="params">id</span>) =&gt;</span> <span class="keyword">new</span> Task(</span><br><span class="line">    (rej, res) =&gt; (</span><br><span class="line">      res(id &gt; <span class="number">2</span></span><br><span class="line">        ? Right(fakeApi(id))</span><br><span class="line">        : Left(<span class="string">'not found'</span>)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Task(Either(user))</span></span><br><span class="line"><span class="keyword">const</span> zero = Db.find(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一版</span></span><br><span class="line"><span class="comment">// Task(Either(Task(Either(user)))) ???</span></span><br><span class="line"><span class="keyword">const</span> one = zero</span><br><span class="line">  .map(<span class="function"><span class="params">either</span> =&gt;</span> either</span><br><span class="line">    .map(<span class="function"><span class="params">user</span> =&gt;</span> Db</span><br><span class="line">      .find(user.bestFriendId)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  .fork(</span><br><span class="line">    <span class="built_in">console</span>.error,</span><br><span class="line">    either =&gt; either <span class="comment">// Either(Task(Either(user)))</span></span><br><span class="line">      .map(<span class="function"><span class="params">t</span> =&gt;</span> t.fork( <span class="comment">// Task(Either(user))</span></span><br><span class="line">        <span class="built_in">console</span>.error,</span><br><span class="line">        either =&gt; either</span><br><span class="line">            .map(<span class="built_in">console</span>.log), <span class="comment">// Either(user)</span></span><br><span class="line">      ))</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p><img src="/blog/imgs/fp-in-js/黑人问号4合一.jpg" alt="黑人问号4合一"></p><p>这是什么鬼？？？</p><p>肯定不能这么干…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Task(Either(user))</span></span><br><span class="line"><span class="keyword">const</span> zero = Db.find(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二版</span></span><br><span class="line"><span class="keyword">const</span> two = zero</span><br><span class="line">  .chain(<span class="function"><span class="params">either</span> =&gt;</span> either</span><br><span class="line">    .fold(Task.rejected, Task.of) <span class="comment">// Task(user)</span></span><br><span class="line">    .chain(<span class="function"><span class="params">user</span> =&gt;</span> Db</span><br><span class="line">      .find(user.bestFriendId) <span class="comment">// Task(Either(user))</span></span><br><span class="line">    )</span><br><span class="line">    .chain(<span class="function"><span class="params">either</span> =&gt;</span> either</span><br><span class="line">      .fold(Task.rejected, Task.of) <span class="comment">// Task(user)</span></span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  .fork(</span><br><span class="line">    <span class="built_in">console</span>.error,</span><br><span class="line">    <span class="built_in">console</span>.log,</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>第二版的问题是多余的嵌套代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Task(Either(user))</span></span><br><span class="line"><span class="keyword">const</span> zero = Db.find(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三版</span></span><br><span class="line"><span class="keyword">const</span> three = zero</span><br><span class="line">  .chain(<span class="function"><span class="params">either</span> =&gt;</span> either</span><br><span class="line">    .fold(Task.rejected, Task.of) <span class="comment">// Task(user)</span></span><br><span class="line">  )</span><br><span class="line">  .chain(<span class="function"><span class="params">user</span> =&gt;</span> Db</span><br><span class="line">    .find(user.bestFriendId) <span class="comment">// Task(Either(user))</span></span><br><span class="line">  )</span><br><span class="line">  .chain(<span class="function"><span class="params">either</span> =&gt;</span> either</span><br><span class="line">    .fold(Task.rejected, Task.of) <span class="comment">// Task(user)</span></span><br><span class="line">  )</span><br><span class="line">  .fork(</span><br><span class="line">    <span class="built_in">console</span>.error,</span><br><span class="line">    <span class="built_in">console</span>.log,</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>第三版的问题是多余的重复逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Task(Either(user))</span></span><br><span class="line"><span class="keyword">const</span> zero = Db.find(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这其实就是自然变换</span></span><br><span class="line"><span class="comment">// 将 Either 变换成 Task</span></span><br><span class="line"><span class="keyword">const</span> eitherToTask = <span class="function">(<span class="params">e</span>) =&gt;</span> (</span><br><span class="line">  e.fold(Task.rejected, Task.of)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四版</span></span><br><span class="line"><span class="keyword">const</span> four = zero</span><br><span class="line">  .chain(eitherToTask) <span class="comment">// Task(user)</span></span><br><span class="line">  .chain(<span class="function"><span class="params">user</span> =&gt;</span> Db</span><br><span class="line">    .find(user.bestFriendId) <span class="comment">// Task(Either(user))</span></span><br><span class="line">  )</span><br><span class="line">  .chain(eitherToTask) <span class="comment">// Task(user)</span></span><br><span class="line">  .fork(</span><br><span class="line">    <span class="built_in">console</span>.error,</span><br><span class="line">    <span class="built_in">console</span>.log,</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出错版</span></span><br><span class="line"><span class="keyword">const</span> error = Db.find(<span class="number">2</span>) <span class="comment">// Task(Either(user))</span></span><br><span class="line">  <span class="comment">// Task.rejected('not found')</span></span><br><span class="line">  .chain(eitherToTask)</span><br><span class="line">  <span class="comment">// 这里永远不会被调用，被跳过了</span></span><br><span class="line">  .chain(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'hey man'</span>))</span><br><span class="line">  ...</span><br><span class="line">  .fork(</span><br><span class="line">    <span class="built_in">console</span>.error, <span class="comment">// not found</span></span><br><span class="line">    <span class="built_in">console</span>.log,</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h3 id="4-12-同构（Isomorphisms）"><a href="#4-12-同构（Isomorphisms）" class="headerlink" title="4.12.同构（Isomorphisms）"></a>4.12.同构（Isomorphisms）</h3><blockquote><p>同构是在数学对象之间定义的一类映射,它能揭示出在这些对象的属性或者操作之间存在的关系。</p></blockquote><p>简单来说就是两种不同类型的对象经过变形，保持结构并且不丢失数据。</p><p><strong>具体怎么做到的呢？</strong></p><p>其实同构就是一对儿函数：<code>to</code> 和 <code>from</code>，遵守以下规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">to(<span class="keyword">from</span>(x)) === x</span><br><span class="line"><span class="keyword">from</span>(to(y)) === y</span><br></pre></td></tr></table></figure><p>这其实说明了这两个类型都能够无损地保存同样的信息。</p><h4 id="1-例如-String-和-Char-就是同构的。"><a href="#1-例如-String-和-Char-就是同构的。" class="headerlink" title="1. 例如 String 和 [Char] 就是同构的。"></a>1. 例如 <code>String</code> 和 <code>[Char]</code> 就是同构的。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String ~ [Char]</span></span><br><span class="line"><span class="keyword">const</span> Iso = <span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> (&#123; to, <span class="keyword">from</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chars = Iso(</span><br><span class="line">  s =&gt; s.split(<span class="string">''</span>),</span><br><span class="line">  c =&gt; c.join(<span class="string">''</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'hello world'</span></span><br><span class="line"></span><br><span class="line">chars.from(chars.to(str)) === str</span><br></pre></td></tr></table></figure><p><strong>这能有啥用呢？</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> truncate = <span class="function">(<span class="params">str</span>) =&gt;</span> (</span><br><span class="line">  chars.from(</span><br><span class="line">    <span class="comment">// 我们先用 to 方法将其转成数组</span></span><br><span class="line">    <span class="comment">// 这样就能使用数组的各类方法</span></span><br><span class="line">    chars.to(str).slice(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">  ).concat(<span class="string">'...'</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">truncate(str) <span class="comment">// hel...</span></span><br></pre></td></tr></table></figure><h4 id="2-再来看看最多有一个参数的数组-a-和-Either-的同构关系"><a href="#2-再来看看最多有一个参数的数组-a-和-Either-的同构关系" class="headerlink" title="2. 再来看看最多有一个参数的数组 [a] 和 Either 的同构关系"></a>2. 再来看看最多有一个参数的数组 <code>[a]</code> 和 <code>Either</code> 的同构关系</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [a] ~ Either null a</span></span><br><span class="line"><span class="keyword">const</span> singleton = Iso(</span><br><span class="line">  e =&gt; e.fold(<span class="function"><span class="params">()</span> =&gt;</span> [], x =&gt; [x]),</span><br><span class="line">  ([ x ]) =&gt; x ? Right(x) : Left()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filterEither = <span class="function">(<span class="params">e, pred</span>) =&gt;</span> singleton</span><br><span class="line">  .from(</span><br><span class="line">    singleton</span><br><span class="line">      .to(e)</span><br><span class="line">      .filter(pred)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUCH = <span class="function">(<span class="params">str</span>) =&gt;</span> filterEither(</span><br><span class="line">  Right(str),</span><br><span class="line">  x =&gt; x.match(<span class="regexp">/h/ig</span>)</span><br><span class="line">).map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase())</span><br><span class="line"></span><br><span class="line">getUCH(<span class="string">'hello'</span>) <span class="comment">// Right(HELLO)</span></span><br><span class="line"></span><br><span class="line">getUCH(<span class="string">'ello'</span>) <span class="comment">// Left(undefined)</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/" target="_blank" rel="noopener">JS函数式编程指南</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/03/pointfree.html" target="_blank" rel="noopener">Pointfree 编程风格指南</a></li><li><a href="https://www.youtube.com/watch?v=m3svKOdZijA" target="_blank" rel="noopener">Hey Underscore, You’re Doing It Wrong!</a></li><li><a href="https://www.youtube.com/watch?v=yXJtrxVZmT4" target="_blank" rel="noopener">Functional Concepts with JavaScript: Part I</a></li><li><a href="https://egghead.io/courses/professor-frisby-introduces-composable-functional-javascript" target="_blank" rel="noopener">Professor Frisby Introduces Composable Functional JavaScript</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html" target="_blank" rel="noopener">函数式编程入门教程</a></li><li><a href="http://www.starcolon.com/Blog/explaining-functional-programming-in-layman-terms/index.html" target="_blank" rel="noopener">What are Functional Programming,<br>Monad, Monoid, Applicative, Functor ??</a></li></ul><p>以上 to be continued…</p><blockquote><p>本文地址： <a href="https://buptsteve.github.io/blog/2018/08/10/14.fp-in-js-3/" target="_blank" rel="external">https://buptsteve.github.io/blog/2018/08/10/14.fp-in-js-3/</a></p><footer><cite><a href="https://buptsteve.github.io/blog">@BuptStEve's Blog</a></cite></footer></blockquote></div><nav class="post-nav"><div class="waves-block waves-effect next fr"><a href="/blog/2018/06/17/13.how-to-encapsulate-image-in-mina/" id="post-next" class="post-nav-link"><div class="tips">Next<i class="icon icon-angle-right icon-lg icon-pl"></i></div><h4 class="title">「13」微信小程序之如何使用自定义组件封装原生 image 组件</h4></a></div></nav><div class="duoshuo"><div class="ds-thread" data-thread-key="14.fp-in-js-3" data-title="「14」JavaScript 函数式编程（三）" data-url="https://buptsteve.github.io/blog/2018/08/10/14.fp-in-js-3/index.html"></div><script>var duoshuoQuery={short_name:"buptsteve"};!function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src=("https:"==document.location.protocol?"https:":"http:")+"//static.duoshuo.com/embed.js",t.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)}()</script></div></div></div></article></div></main><div class="mask" id="mask"></div><a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a><script src="/blog/js/wave.min.js"></script><script src="/blog/js/main.js"></script><div class="search-panel" id="search-panel"><ul class="search-result" id="search-result"></ul></div><script type="text/template" id="search-tpl"><li class="item">
        <a href="/{path}" class="waves-block waves-effect">
            <div class="title ellipsis" title="{title}">{title}</div>
            
            <div class="flex-row flex-middle">
                <div class="tags ellipsis">
                    {tags}
                </div>

                <time class="flex-col time">{date}</time>
            </div>
        </a>
    </li></script><script src="/blog/js/search.js"></script><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="//www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-85691829-1","auto"),ga("send","pageview")</script></body></html>